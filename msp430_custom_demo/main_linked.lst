
main_linked.elf:     file format elf32-msp430

SYMBOL TABLE:
00005c00 l    d  .text	00000000 .text
00008110 l    d  .rodata	00000000 .rodata
00001c00 l    d  .data	00000000 .data
00001c08 l    d  .bss	00000000 .bss
00002490 l    d  .noinit	00000000 .noinit
0000ff80 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 uart_A3.cpp
0000748a l     F .text	0000000a _GLOBAL__sub_I_uart_A3
00005ca6 l       .text	00000000 __br_unexpected_
00000000 l    df *ABS*	00000000 tasks.c
00005caa l     F .text	00000042 prvAddCurrentTaskToDelayedList
00001c16 l     O .bss	00000002 xTickCount
00001c1c l     O .bss	00000002 pxOverflowDelayedTaskList
00001c1e l     O .bss	00000002 pxDelayedTaskList
00001c00 l     O .data	00000002 xNextTaskUnblockTime
00001c18 l     O .bss	00000002 uxCurrentNumberOfTasks
00001c22 l     O .bss	00000028 pxReadyTasksLists
00001c4a l     O .bss	0000000a xDelayedTaskList1
00001c54 l     O .bss	0000000a xDelayedTaskList2
00001c5e l     O .bss	0000000a xPendingReadyList
00001c68 l     O .bss	0000000a xTasksWaitingTermination
00001c12 l     O .bss	00000002 xSchedulerRunning
00001c20 l     O .bss	00000002 uxTaskNumber
00001c14 l     O .bss	00000002 uxTopReadyPriority
00001c1a l     O .bss	00000002 uxTasksDeleted
000061ca l     F .text	0000008a prvIdleTask
00001c10 l     O .bss	00000002 uxSchedulerSuspended
00001c0a l     O .bss	00000002 xNumOfOverflows
00001c0e l     O .bss	00000002 uxPendedTicks
00001c0c l     O .bss	00000002 xYieldPending
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 queue.c
00006524 l     F .text	00000030 prvCopyDataFromQueue
00006554 l     F .text	00000080 prvCopyDataToQueue
000065d4 l     F .text	000000de prvUnlockQueue
00000000 l    df *ABS*	00000000 heap_1.c
00001c72 l     O .bss	00000002 pucAlignedHeap.2290
00001c74 l     O .bss	00000708 ucHeap
0000237c l     O .bss	00000002 xNextFreeByte
00000000 l    df *ABS*	00000000 port.c
00000000 l    df *ABS*	00000000 uart.cpp
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 rand.c
00001c04 l     O .data	00000004 next
00000000 l    df *ABS*	00000000 fp-bit.c
0000768a l     F .text	0000027c _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000690 g       *ABS*	00000000 __UCA3ABCTL
0000063c g       *ABS*	00000000 __UCB1ICTL
000002aa g       *ABS*	00000000 __PFSEL_L
00007126 g     F .text	00000030 _ZN8__UART__4peekERh
000005c1 g       *ABS*	00000000 __UCA0CTLW0_H
00005ca6  w      .text	00000000 __isr_37
00000267 g       *ABS*	00000000 __PDREN_H
000004e6 g       *ABS*	00000000 __RES1_L
00000122 g       *ABS*	00000000 __PMMCTL1_L
00005ca6  w      .text	00000000 __isr_47
00006e82 g     F .text	0000007a _Z6task_1Pv
00000151 g       *ABS*	00000000 __CRCDI_H
00000714 g       *ABS*	00000000 __ADC12MCTL4
0000016d g       *ABS*	00000000 __UCSCTL6_H
00005ca6  w      .text	00000000 __isr_51
00000008 g       *ABS*	00000000 __data_size
0000073a g       *ABS*	00000000 __ADC12MEM13
00000346 g       *ABS*	00000000 __TA0CCTL2
00000504 g       *ABS*	00000000 __DMACTL2_L
00005ca6  w      .text	00000000 __isr_14
000002ab g       *ABS*	00000000 __PFSEL_H
00000140 g       *ABS*	00000000 __FCTL1
000004d7 g       *ABS*	00000000 __MPYS32H_H
00006cc8 g     F .text	0000000a xPortGetFreeHeapSize
000005dc g       *ABS*	00000000 __UCA0ICTL_L
00000723 g       *ABS*	00000000 __ADC12MEM1_H
00005ca6  w      .text	00000000 __isr_57
000004b2 g       *ABS*	00000000 __RTCTIM1_L
00000392 g       *ABS*	00000000 __TA1CCR0
00006e4c g     F .text	00000036 _Z6task_2Pv
00000321 g       *ABS*	00000000 __PJIN_H
0000021d g       *ABS*	00000000 __PAIFG_H
00007000 g     F .text	0000003e _ZN8__UART__7putcharEh
0000060c g       *ABS*	00000000 __UCA1RXBUF
00000358 g       *ABS*	00000000 __TA0CCR3
00000700 g       *ABS*	00000000 __ADC12CTL0_L
00007398 g     F .text	00000056 _Z24uart_A3_interrupt_vectorv
00000727 g       *ABS*	00000000 __ADC12MEM3_H
0000019f g       *ABS*	00000000 __SYSRSTIV_H
000003cc g       *ABS*	00000000 __TB0CCTL5
000071fc g     F .text	0000000e _Z34uart_A3_disable_uart_A3_interruptsv
000004d2 g       *ABS*	00000000 __MPY32H_L
00006dee g     F .text	0000005e prvTickISR
00000633 g       *ABS*	00000000 __UCB1I2CSA_H
000004d9 g       *ABS*	00000000 __MAC32L_H
00000724 g       *ABS*	00000000 __ADC12MEM2_L
0000053a g       *ABS*	00000000 __DMA2SZ
00000248 g       *ABS*	00000000 __PCDS
00000247 g       *ABS*	00000000 __PCREN_H
00005ca6  w      .text	00000000 __isr_24
00000284 g       *ABS*	00000000 __PEDIR
000003e0 g       *ABS*	00000000 __TB0EX0
000006bc g       *ABS*	00000000 __UCB3ICTL_L
00000268 g       *ABS*	00000000 __PDDS
00005ca6  w      .text	00000000 __isr_4
0000021b g       *ABS*	00000000 __PAIE_H
00000240 g       *ABS*	00000000 __PCIN
00000640 g       *ABS*	00000000 __UCA2CTLW0
00000228 g       *ABS*	00000000 __PBDS_L
00000224 g       *ABS*	00000000 __PBDIR
0000012f g       *ABS*	00000000 __PMMRIE_H
000005d2 g       *ABS*	00000000 __UCA0IRCTL_L
0000069e g       *ABS*	00000000 __UCA3IV
000004c8 g       *ABS*	00000000 __OP2
00000249 g       *ABS*	00000000 __PCDS_H
000004ae g       *ABS*	00000000 __RTCIV
00005ca6  w      .text	00000000 __isr_33
00000244 g       *ABS*	00000000 __PCDIR_L
0000062e g       *ABS*	00000000 __UCB1TXBUF
00000289 g       *ABS*	00000000 __PEDS_H
0000070a g       *ABS*	00000000 __ADC12IFG
0000021c g       *ABS*	00000000 __PAIFG
000005c0 g       *ABS*	00000000 __UCA0CTLW0_L
0000073b g       *ABS*	00000000 __ADC12MEM13_H
000005e0 g       *ABS*	00000000 __UCB0CTLW0_L
00000600 g       *ABS*	00000000 __UCA1CTLW0
000005dc g       *ABS*	00000000 __UCA0ICTL
000004e4 g       *ABS*	00000000 __RES0_L
00000666 g       *ABS*	00000000 __UCB2BRW_L
000004ca g       *ABS*	00000000 __RESLO_L
0000024a g       *ABS*	00000000 __PCSEL
000004e4 g       *ABS*	00000000 __RES0
0000021e g       *ABS*	00000000 __P2IV
000005de g       *ABS*	00000000 __UCA0IV
000004df g       *ABS*	00000000 __MACS32H_H
000071ee g     F .text	0000000e _Z33uart_A3_enable_uart_A3_interruptsv
0000695e g     F .text	00000064 xQueueGenericSendFromISR
000005e0 g       *ABS*	00000000 __UCB0CTLW0
00000324 g       *ABS*	00000000 __PJDIR_L
00007c62 g     F .text	00000090 __fixsfsi
00000282 g       *ABS*	00000000 __PEOUT
000005e6 g       *ABS*	00000000 __UCB0BRW_L
00000283 g       *ABS*	00000000 __PEOUT_H
0000051a g       *ABS*	00000000 __DMA0SZ
0000026b g       *ABS*	00000000 __PDSEL_H
000004c3 g       *ABS*	00000000 __MPYS_H
00000612 g       *ABS*	00000000 __UCA1IRCTL
00010000 g       .vectors	00000000 _efartext
000004b9 g       *ABS*	00000000 __RTCAMINHR_H
00000626 g       *ABS*	00000000 __UCB1BRW
00000356 g       *ABS*	00000000 __TA0CCR2
000005fc g       *ABS*	00000000 __UCB0ICTL
000005c7 g       *ABS*	00000000 __UCA0BRW_H
000004c0 g       *ABS*	00000000 __MPY
000006a6 g       *ABS*	00000000 __UCB3BRW_L
000004ca g       *ABS*	00000000 __RESLO
000004c6 g       *ABS*	00000000 __MACS
00001c08 g     O .bss	00000002 pxCurrentTCB
0000034a g       *ABS*	00000000 __TA0CCTL4
00000717 g       *ABS*	00000000 __ADC12MCTL7
0000070f g       *ABS*	00000000 __ADC12IV_H
000005c0 g       *ABS*	00000000 __UCA0CTLW0
00000261 g       *ABS*	00000000 __PDIN_H
0000016f g       *ABS*	00000000 __UCSCTL7_H
0000019d g       *ABS*	00000000 __SYSSNIV_H
00000686 g       *ABS*	00000000 __UCA3BRW
000002a1 g       *ABS*	00000000 __PFIN_H
0000073e g       *ABS*	00000000 __ADC12MEM15_L
00000104 g       *ABS*	00000000 __SFRRPCR
00000146 g       *ABS*	00000000 __FCTL4
0000822c g       *ABS*	00000000 _etext
00000328 g       *ABS*	00000000 __PJDS_L
000004d8 g       *ABS*	00000000 __MAC32L_L
00000200 g       *ABS*	00000000 __PAIN_L
00000508 g       *ABS*	00000000 __DMACTL4_L
0000064e g       *ABS*	00000000 __UCA2TXBUF
00000183 g       *ABS*	00000000 __SYSBSLC_H
000002aa g       *ABS*	00000000 __PFSEL
0000072d g       *ABS*	00000000 __ADC12MEM6_H
000004e2 g       *ABS*	00000000 __OP2H
000004ea g       *ABS*	00000000 __RES3_L
00000502 g       *ABS*	00000000 __DMACTL1_L
00007952 g     F .text	00000050 __subsf3
000004d3 g       *ABS*	00000000 __MPY32H_H
00000202 g       *ABS*	00000000 __PAOUT_L
00000705 g       *ABS*	00000000 __ADC12CTL2_H
00000360 g       *ABS*	00000000 __TA0EX0
0000022a g       *ABS*	00000000 __PBSEL_L
000073ee g     F .text	00000078 _Z20uart_A3_uninitializev
00000536 g       *ABS*	00000000 __DMA2DA
000004c6 g       *ABS*	00000000 __MACS_L
00005ca6  w      .text	00000000 __isr_19
00000888 g       *ABS*	00000000 __bss_size
00000711 g       *ABS*	00000000 __ADC12MCTL1
00000207 g       *ABS*	00000000 __PAREN_H
000004de g       *ABS*	00000000 __MACS32H
00000632 g       *ABS*	00000000 __UCB1I2CSA
00000732 g       *ABS*	00000000 __ADC12MEM9
00005ca6  w      .text	00000000 __isr_29
00000128 g       *ABS*	00000000 __SVSMIO_L
00000268 g       *ABS*	00000000 __PDDS_L
000003ee g       *ABS*	00000000 __TB0IV
000004ba g       *ABS*	00000000 __RTCADOWDAY_L
00005ca6  w      .text	00000000 __isr_23
00005c00  w      .text	00000000 __watchdog_support
00000224 g       *ABS*	00000000 __PBDIR_L
000004eb g       *ABS*	00000000 __RES3_H
00005c9e  w      .text	00000000 __stop_progExec__
00006d2a g     F .text	00000066 xPortStartScheduler
00000218 g       *ABS*	00000000 __PAIES
0000050f g       *ABS*	00000000 __DMAIV_H
00000352 g       *ABS*	00000000 __TA0CCR0
00000731 g       *ABS*	00000000 __ADC12MEM8_H
00005f70 g     F .text	0000000e vTaskEndScheduler
00000631 g       *ABS*	00000000 __UCB1I2COA_H
00007494 g     F .text	000000e4 memcpy
0000635a g     F .text	0000002a vTaskPlaceOnEventList
0000060a g       *ABS*	00000000 __UCA1STAT
0000067e g       *ABS*	00000000 __UCB2IV
00005cec g     F .text	000001d0 xTaskGenericCreate
00000322 g       *ABS*	00000000 __PJOUT
0000073f g       *ABS*	00000000 __ADC12MEM15_H
00000220 g       *ABS*	00000000 __PBIN
000004e8 g       *ABS*	00000000 __RES2_L
00000326 g       *ABS*	00000000 __PJREN
0000020a g       *ABS*	00000000 __PASEL_L
000003d4 g       *ABS*	00000000 __TB0CCR1
00000282 g       *ABS*	00000000 __PEOUT_L
00000516 g       *ABS*	00000000 __DMA0DA
00006fa6 g     F .text	00000012 _ZN8__UART__C1Ev
00006be2 g     F .text	00000024 xQueuePeekFromISR
0000061d g       *ABS*	00000000 __UCA1ICTL_H
000004d6 g       *ABS*	00000000 __MPYS32H
000006b2 g       *ABS*	00000000 __UCB3I2CSA
0000020a g       *ABS*	00000000 __PASEL
00005ca6  w      .text	00000000 __isr_32
00000160 g       *ABS*	00000000 __UCSCTL0_L
00000218 g       *ABS*	00000000 __PAIES_L
00006cc0 g     F .text	00000002 vPortFree
00000104 g       *ABS*	00000000 __SFRRPCR_L
00000124 g       *ABS*	00000000 __SVSMHCTL_L
00000671 g       *ABS*	00000000 __UCB2I2COA_H
00000140 g       *ABS*	00000000 __FCTL1_L
00005ca6  w      .text	00000000 __isr_11
000070d2 g     F .text	00000054 _ZN8__UART__4putsEPKcj
00006dee g       .text	00000000 __isr_54
00000329 g       *ABS*	00000000 __PJDS_H
00000340 g       *ABS*	00000000 __TA0CTL
00000203 g       *ABS*	00000000 __PAOUT_H
00000166 g       *ABS*	00000000 __UCSCTL3
00000323 g       *ABS*	00000000 __PJOUT_H
00000287 g       *ABS*	00000000 __PEREN_H
00007652 g     F .text	00000000 __udivsi3
000004e2 g       *ABS*	00000000 __OP2H_L
000006a0 g       *ABS*	00000000 __UCB3CTLW0
00000200 g       *ABS*	00000000 __PAIN
00000226 g       *ABS*	00000000 __PBREN_L
00000123 g       *ABS*	00000000 __PMMCTL1_H
000004d0 g       *ABS*	00000000 __MPY32L
000004dc g       *ABS*	00000000 __MACS32L_L
000004a0 g       *ABS*	00000000 __RTCCTL01
00000608 g       *ABS*	00000000 __UCA1MCTL
00000531 g       *ABS*	00000000 __DMA2CTL_H
00005ca6  w      .text	00000000 __isr_42
0000062a g       *ABS*	00000000 __UCB1STAT
00000738 g       *ABS*	00000000 __ADC12MEM12_L
00000700 g       *ABS*	00000000 __ADC12CTL0
00000280 g       *ABS*	00000000 __PEIN_L
00000285 g       *ABS*	00000000 __PEDIR_H
00000161 g       *ABS*	00000000 __UCSCTL0_H
00000344 g       *ABS*	00000000 __TA0CCTL1
000002a2 g       *ABS*	00000000 __PFOUT
0000648e g     F .text	00000024 vListInsertEnd
00000180 g       *ABS*	00000000 __SYSCTL_L
0000018c g       *ABS*	00000000 __SYSJMBO0
0000ff80 g     O .vectors	00000080 __ivtbl_64
00000652 g       *ABS*	00000000 __UCA2IRCTL_L
00000390 g       *ABS*	00000000 __TA1R
000005f1 g       *ABS*	00000000 __UCB0I2COA_H
00000171 g       *ABS*	00000000 __UCSCTL8_H
00000154 g       *ABS*	00000000 __CRCINIRES_L
00005ca6  w      .text	00000000 __isr_49
00000165 g       *ABS*	00000000 __UCSCTL2_H
000005cc g       *ABS*	00000000 __UCA0RXBUF
00000670 g       *ABS*	00000000 __UCB2I2COA
00000621 g       *ABS*	00000000 __UCB1CTLW0_H
00007364 g     F .text	0000001a _Z25uart_A3_enable_uart_A3_txv
00000158 g       *ABS*	00000000 __RCCTL0
000004ec g       *ABS*	00000000 __MPY32CTL0
00000712 g       *ABS*	00000000 __ADC12MCTL2
00000350 g       *ABS*	00000000 __TA0R
00000600 g       *ABS*	00000000 __UCA1CTLW0_L
00005ca6  w      .text	00000000 __isr_16
0000068e g       *ABS*	00000000 __UCA3TXBUF
0000070c g       *ABS*	00000000 __ADC12IE_L
000006b1 g       *ABS*	00000000 __UCB3I2COA_H
000004ed g       *ABS*	00000000 __MPY32CTL0_H
000005f3 g       *ABS*	00000000 __UCB0I2CSA_H
00000511 g       *ABS*	00000000 __DMA0CTL_H
00007156 g     F .text	00000004 _ZN8__UART__11get_rxCountEv
00005ca6  w      .text	00000000 __isr_59
000004c9 g       *ABS*	00000000 __OP2_H
00000667 g       *ABS*	00000000 __UCB2BRW_H
00005ca6  w      .text	00000000 __isr_39
00000610 g       *ABS*	00000000 __UCA1ABCTL
00000242 g       *ABS*	00000000 __PCOUT_L
0000012c g       *ABS*	00000000 __PMMIFG_L
00000205 g       *ABS*	00000000 __PADIR_H
0000018c g       *ABS*	00000000 __SYSJMBO0_L
0000070e g       *ABS*	00000000 __ADC12IV_L
00006488 g     F .text	00000006 vListInitialiseItem
0000019c g       *ABS*	00000000 __SYSSNIV_L
000002a4 g       *ABS*	00000000 __PFDIR_L
0000068a g       *ABS*	00000000 __UCA3STAT
00000601 g       *ABS*	00000000 __UCA1CTLW0_H
00006efc g     F .text	000000aa _Z18hardwareInitializev
000004c7 g       *ABS*	00000000 __MACS_H
00001c02 g     O .data	00000002 usCriticalNesting
0000072f g       *ABS*	00000000 __ADC12MEM7_H
00005ca6  w      .text	00000000 __isr_26
0000024a g       *ABS*	00000000 __PCSEL_L
00000380 g       *ABS*	00000000 __TA1CTL
00007166 g     F .text	00000048 _ZN8__UART__15__on_rx_receiveEh
0000018a g       *ABS*	00000000 __SYSJMBI1
000005ea g       *ABS*	00000000 __UCB0STAT
00005ca6  w      .text	00000000 __isr_5
00000726 g       *ABS*	00000000 __ADC12MEM3_L
0000019e g       *ABS*	00000000 __SYSRSTIV_L
00000262 g       *ABS*	00000000 __PDOUT_L
0000822c g       *ABS*	00000000 __data_load_start
000004ba g       *ABS*	00000000 __RTCADOWDAY
00005ca6 g       .text	00000000 __dtors_end
000002a7 g       *ABS*	00000000 __PFREN_H
00000522 g       *ABS*	00000000 __DMA1SA
000004b6 g       *ABS*	00000000 __RTCYEAR_L
00000718 g       *ABS*	00000000 __ADC12MCTL8
000004b5 g       *ABS*	00000000 __RTCDATE_H
000004b3 g       *ABS*	00000000 __RTCTIM1_H
000003da g       *ABS*	00000000 __TB0CCR4
00000228 g       *ABS*	00000000 __PBDS
00000530 g       *ABS*	00000000 __DMA2CTL
000005ca g       *ABS*	00000000 __UCA0STAT
000004c1 g       *ABS*	00000000 __MPY_H
000005d3 g       *ABS*	00000000 __UCA0IRCTL_H
0000016e g       *ABS*	00000000 __UCSCTL7
00006c70 g     F .text	00000050 pvPortMalloc
00000732 g       *ABS*	00000000 __ADC12MEM9_L
00005ca6  w      .text	00000000 __isr_46
000004a8 g       *ABS*	00000000 __RTCPS0CTL
00000327 g       *ABS*	00000000 __PJREN_H
00000504 g       *ABS*	00000000 __DMACTL2
00005ca6  w      .text	00000000 __isr_2
00000246 g       *ABS*	00000000 __PCREN
00000187 g       *ABS*	00000000 __SYSJMBC_H
0000065d g       *ABS*	00000000 __UCA2ICTL_H
00000348 g       *ABS*	00000000 __TA0CCTL3
00000736 g       *ABS*	00000000 __ADC12MEM11
00006c3c g     F .text	00000014 vQueueDelete
0000028a g       *ABS*	00000000 __PESEL_L
00006d90 g     F .text	00000002 vPortEndScheduler
00000738 g       *ABS*	00000000 __ADC12MEM12
000006aa g       *ABS*	00000000 __UCB3STAT
0000646e g     F .text	0000001a vListInitialise
00000144 g       *ABS*	00000000 __FCTL3
00005ca6  w      .text	00000000 __isr_10
00000652 g       *ABS*	00000000 __UCA2IRCTL
00000500 g       *ABS*	00000000 __DMACTL0_L
00000728 g       *ABS*	00000000 __ADC12MEM4
00005ca6  w      .text	00000000 __isr_53
0000703e g     F .text	00000094 _ZN8__UART__4getsEPhj
0000065c g       *ABS*	00000000 __UCA2ICTL
00000739 g       *ABS*	00000000 __ADC12MEM12_H
00000163 g       *ABS*	00000000 __UCSCTL1_H
00000222 g       *ABS*	00000000 __PBOUT
0000018d g       *ABS*	00000000 __SYSJMBO0_H
00005f8a g     F .text	00000030 xTaskGetTickCount
0000036e g       *ABS*	00000000 __TA0IV
0000050e g       *ABS*	00000000 __DMAIV
000067c6 g     F .text	00000198 xQueueGenericSend
00000219 g       *ABS*	00000000 __PAIES_H
0000071d g       *ABS*	00000000 __ADC12MCTL13
000004da g       *ABS*	00000000 __MAC32H
00005ca6  w      .text	00000000 __isr_41
0000067c g       *ABS*	00000000 __UCB2ICTL
000003ce g       *ABS*	00000000 __TB0CCTL6
0000072c g       *ABS*	00000000 __ADC12MEM6
00000612 g       *ABS*	00000000 __UCA1IRCTL_L
00008002 g     F .text	0000010c __unpack_f
00000382 g       *ABS*	00000000 __TA1CCTL0
00000208 g       *ABS*	00000000 __PADS_L
000004e0 g       *ABS*	00000000 __OP2L_L
00000240 g       *ABS*	00000000 __PCIN_L
000004cc g       *ABS*	00000000 __RESHI
00000672 g       *ABS*	00000000 __UCB2I2CSA
000005f2 g       *ABS*	00000000 __UCB0I2CSA
00000284 g       *ABS*	00000000 __PEDIR_L
000004b2 g       *ABS*	00000000 __RTCTIM1
0000066a g       *ABS*	00000000 __UCB2STAT
000004c4 g       *ABS*	00000000 __MAC_L
00000715 g       *ABS*	00000000 __ADC12MCTL5
000004a9 g       *ABS*	00000000 __RTCPS0CTL_H
00002490 g     O .noinit	00000002 __wdt_clear_value
000071ae g     F .text	00000040 _ZN8__UART__15__on_tx_receiveEPh
000002a6 g       *ABS*	00000000 __PFREN_L
0000018a g       *ABS*	00000000 __SYSJMBI1_L
0000237e g     O .bss	00000112 uart_A3
00000128 g       *ABS*	00000000 __SVSMIO
000005f0 g       *ABS*	00000000 __UCB0I2COA_L
0000720a g     F .text	0000015a _Z17uart_A3_configurej6PARITY
000004a1 g       *ABS*	00000000 __RTCCTL01_H
00000328 g       *ABS*	00000000 __PJDS
000006ac g       *ABS*	00000000 __UCB3RXBUF
0000073a g       *ABS*	00000000 __ADC12MEM13_L
00000606 g       *ABS*	00000000 __UCA1BRW
00000647 g       *ABS*	00000000 __UCA2BRW_H
0000019e g       *ABS*	00000000 __SYSRSTIV
00000681 g       *ABS*	00000000 __UCA3CTLW0_H
00000510 g       *ABS*	00000000 __DMA0CTL
000004ea g       *ABS*	00000000 __RES3
0000069c g       *ABS*	00000000 __UCA3ICTL_L
0000024b g       *ABS*	00000000 __PCSEL_H
00000703 g       *ABS*	00000000 __ADC12CTL1_H
00006384 g     F .text	0000006c xTaskRemoveFromEventList
00005ca6  w      .text	00000000 __isr_7
00000607 g       *ABS*	00000000 __UCA1BRW_H
000004bb g       *ABS*	00000000 __RTCADOWDAY_H
0000018f g       *ABS*	00000000 __SYSJMBO1_H
000006b0 g       *ABS*	00000000 __UCB3I2COA
0000026a g       *ABS*	00000000 __PDSEL
00005ca6  w      .text	00000000 __isr_60
00005ca6  w      .text	00000000 __isr_25
00005ca6  w      .text	00000000 __isr_36
000005f2 g       *ABS*	00000000 __UCB0I2CSA_L
00000168 g       *ABS*	00000000 __UCSCTL4
00000646 g       *ABS*	00000000 __UCA2BRW
000075d4 g     F .text	00000024 rand_r
00007680 g     F .text	00000000 __umodsi3
00000728 g       *ABS*	00000000 __ADC12MEM4_L
00000101 g       *ABS*	00000000 __SFRIE1_H
00000632 g       *ABS*	00000000 __UCB1I2CSA_L
00000680 g       *ABS*	00000000 __UCA3CTLW0_L
00000103 g       *ABS*	00000000 __SFRIFG1_H
0000072e g       *ABS*	00000000 __ADC12MEM7
00000220 g       *ABS*	00000000 __PBIN_L
00006fa6 g     F .text	00000012 _ZN8__UART__C2Ev
00007e3c g     F .text	000001c6 __pack_f
000005f0 g       *ABS*	00000000 __UCB0I2COA
000004dc g       *ABS*	00000000 __MACS32L
0000062c g       *ABS*	00000000 __UCB1RXBUF
00005ebc g     F .text	00000082 vTaskDelete
00000266 g       *ABS*	00000000 __PDREN
0000018e g       *ABS*	00000000 __SYSJMBO1_L
00000186 g       *ABS*	00000000 __SYSJMBC
0000035a g       *ABS*	00000000 __TA0CCR4
00005ca6  w      .text	00000000 __isr_34
000004da g       *ABS*	00000000 __MAC32H_L
000004d8 g       *ABS*	00000000 __MAC32L
000004cc g       *ABS*	00000000 __RESHI_L
00000280 g       *ABS*	00000000 __PEIN
0000016b g       *ABS*	00000000 __UCSCTL5_H
00005ca6  w      .text	00000000 __isr_0
00000260 g       *ABS*	00000000 __PDIN_L
000004b4 g       *ABS*	00000000 __RTCDATE
00000141 g       *ABS*	00000000 __FCTL1_H
00000206 g       *ABS*	00000000 __PAREN_L
00000688 g       *ABS*	00000000 __UCA3MCTL
00007dd2 g     F .text	0000006a __clzsi2
000005c8 g       *ABS*	00000000 __UCA0MCTL
00000164 g       *ABS*	00000000 __UCSCTL2_L
00005c28  w      .text	00000000 __do_clear_bss
00000146 g       *ABS*	00000000 __FCTL4_L
00006402 g     F .text	00000066 xTaskCheckForTimeOut
00000206 g       *ABS*	00000000 __PAREN
000004d4 g       *ABS*	00000000 __MPYS32L
00000506 g       *ABS*	00000000 __DMACTL3_L
0000071f g       *ABS*	00000000 __ADC12MCTL15
00000242 g       *ABS*	00000000 __PCOUT
00007398 g       .text	00000000 __isr_44
00000640 g       *ABS*	00000000 __UCA2CTLW0_L
0000067c g       *ABS*	00000000 __UCB2ICTL_L
00000704 g       *ABS*	00000000 __ADC12CTL2_L
0000073c g       *ABS*	00000000 __ADC12MEM14
0000019b g       *ABS*	00000000 __SYSUNIV_H
0000015d g       *ABS*	00000000 __WDTCTL_H
0000012e g       *ABS*	00000000 __PMMRIE_L
0000016c g       *ABS*	00000000 __UCSCTL6
00000243 g       *ABS*	00000000 __PCOUT_H
00000520 g       *ABS*	00000000 __DMA1CTL_L
000004b8 g       *ABS*	00000000 __RTCAMINHR
00000326 g       *ABS*	00000000 __PJREN_L
0000072b g       *ABS*	00000000 __ADC12MEM5_H
00000186 g       *ABS*	00000000 __SYSJMBC_L
00005f7e g     F .text	0000000c vTaskSuspendAll
000004e7 g       *ABS*	00000000 __RES1_H
000004db g       *ABS*	00000000 __MAC32H_H
000004a0 g       *ABS*	00000000 __RTCCTL01_L
00000155 g       *ABS*	00000000 __CRCINIRES_H
00005fba g     F .text	00000006 xTaskGetTickCountFromISR
00000722 g       *ABS*	00000000 __ADC12MEM1_L
00000710 g       *ABS*	00000000 __ADC12MCTL0
000006bd g       *ABS*	00000000 __UCB3ICTL_H
000075f8 g     F .text	00000026 rand
0000016c g       *ABS*	00000000 __UCSCTL6_L
000005fc g       *ABS*	00000000 __UCB0ICTL_L
00000736 g       *ABS*	00000000 __ADC12MEM11_L
00005ca6  w      .text	00000000 __isr_28
00000100 g       *ABS*	00000000 __SFRIE1
00000720 g       *ABS*	00000000 __ADC12MEM0
00007bc0 g     F .text	000000a2 __floatsisf
00000181 g       *ABS*	00000000 __SYSCTL_H
000064f0 g     F .text	00000034 uxListRemove
000006a0 g       *ABS*	00000000 __UCB3CTLW0_L
000004b0 g       *ABS*	00000000 __RTCTIM0_L
0000028a g       *ABS*	00000000 __PESEL
000003c4 g       *ABS*	00000000 __TB0CCTL1
00007652 g       .text	00000000 __ext_udivmod32
000004ec g       *ABS*	00000000 __MPY32CTL0_L
000004ac g       *ABS*	00000000 __RTCPS_L
00000501 g       *ABS*	00000000 __DMACTL0_H
00007628 g       .text	00000000 __mulsi3
000006ae g       *ABS*	00000000 __UCB3TXBUF
000062e4 g     F .text	00000076 vTaskSwitchContext
000003de g       *ABS*	00000000 __TB0CCR6
0000069d g       *ABS*	00000000 __UCA3ICTL_H
0000810e  w      .text	00000000 _unexpected_
00005ca6  w      .text	00000000 __isr_8
0000072a g       *ABS*	00000000 __ADC12MEM5
00000229 g       *ABS*	00000000 __PBDS_H
00000734 g       *ABS*	00000000 __ADC12MEM10_L
000002a3 g       *ABS*	00000000 __PFOUT_H
0000020e g       *ABS*	00000000 __P1IV
000004c0 g       *ABS*	00000000 __MPY_L
00005ca6  w      .text	00000000 __isr_20
00000160 g       *ABS*	00000000 __UCSCTL0
0000016a g       *ABS*	00000000 __UCSCTL5
00000626 g       *ABS*	00000000 __UCB1BRW_L
000003ae g       *ABS*	00000000 __TA1IV
00005ca6  w      .text	00000000 __isr_61
000004d4 g       *ABS*	00000000 __MPYS32L_L
0000071e g       *ABS*	00000000 __ADC12MCTL14
00005ca6  w      .text	00000000 __isr_3
00000121 g       *ABS*	00000000 __PMMCTL0_H
000004a3 g       *ABS*	00000000 __RTCCTL23_H
00000246 g       *ABS*	00000000 __PCREN_L
00006fb8 g     F .text	00000048 _ZN8__UART__7getcharERh
0000070c g       *ABS*	00000000 __ADC12IE
00000672 g       *ABS*	00000000 __UCB2I2CSA_L
00000613 g       *ABS*	00000000 __UCA1IRCTL_H
000004ab g       *ABS*	00000000 __RTCPS1CTL_H
000003d0 g       *ABS*	00000000 __TB0R
00000724 g       *ABS*	00000000 __ADC12MEM2
00000693 g       *ABS*	00000000 __UCA3IRCTL_H
0000070a g       *ABS*	00000000 __ADC12IFG_L
000004e5 g       *ABS*	00000000 __RES0_H
0000052a g       *ABS*	00000000 __DMA1SZ
00000673 g       *ABS*	00000000 __UCB2I2CSA_H
00005ca6  w      .text	00000000 __isr_48
00000102 g       *ABS*	00000000 __SFRIFG1
00000508 g       *ABS*	00000000 __DMACTL4
000003ca g       *ABS*	00000000 __TB0CCTL4
00005fc0 g     F .text	00000006 uxTaskGetNumberOfTasks
00000105 g       *ABS*	00000000 __SFRRPCR_H
00005ca6  w      .text	00000000 __isr_18
000003dc g       *ABS*	00000000 __TB0CCR5
00005c00  w      .text	00000000 _reset_vector__
000002a0 g       *ABS*	00000000 __PFIN_L
00000145 g       *ABS*	00000000 __FCTL3_H
00000125 g       *ABS*	00000000 __SVSMHCTL_H
00005ca4 g       .text	00000000 __ctors_start
00005ca6  w      .text	00000000 __isr_12
00000167 g       *ABS*	00000000 __UCSCTL3_H
000003c2 g       *ABS*	00000000 __TB0CCTL0
00008124 g     O .rodata	00000008 __thenan_sf
000006b3 g       *ABS*	00000000 __UCB3I2CSA_H
00005ca6  w      .text	00000000 __isr_55
00006d92 g     F .text	0000005c vPortYield
0000072e g       *ABS*	00000000 __ADC12MEM7_L
0000069c g       *ABS*	00000000 __UCA3ICTL
00005c10  w      .text	00000000 __do_copy_data
00000648 g       *ABS*	00000000 __UCA2MCTL
000004a2 g       *ABS*	00000000 __RTCCTL23_L
00005ca6  w      .text	00000000 __isr_43
00000606 g       *ABS*	00000000 __UCA1BRW_L
0000018b g       *ABS*	00000000 __SYSJMBI1_H
00000223 g       *ABS*	00000000 __PBOUT_H
00000342 g       *ABS*	00000000 __TA0CCTL0
00000182 g       *ABS*	00000000 __SYSBSLC_L
00000730 g       *ABS*	00000000 __ADC12MEM8
000006b2 g       *ABS*	00000000 __UCB3I2CSA_L
00000722 g       *ABS*	00000000 __ADC12MEM1
0000060e g       *ABS*	00000000 __UCA1TXBUF
00001c08 g       .bss	00000000 __bss_start
00007578 g     F .text	0000005c memset
00000620 g       *ABS*	00000000 __UCB1CTLW0_L
00000730 g       *ABS*	00000000 __ADC12MEM8_L
00005c52 g     F .text	0000004c main
00000201 g       *ABS*	00000000 __PAIN_H
00000661 g       *ABS*	00000000 __UCB2CTLW0_H
0000063e g       *ABS*	00000000 __UCB1IV
00000100 g       *ABS*	00000000 __SFRIE1_L
00005ca6  w      .text	00000000 __isr_50
00000124 g       *ABS*	00000000 __SVSMHCTL
0000761e g     F .text	0000000a srand
00005ca6  w      .text	00000000 __isr_13
000005fe g       *ABS*	00000000 __UCB0IV
0000073d g       *ABS*	00000000 __ADC12MEM14_H
000064b2 g     F .text	0000003e vListInsert
00005ca6  w      .text	00000000 __isr_56
00000244 g       *ABS*	00000000 __PCDIR
00000262 g       *ABS*	00000000 __PDOUT
0000065c g       *ABS*	00000000 __UCA2ICTL_L
00000264 g       *ABS*	00000000 __PDDIR_L
00000222 g       *ABS*	00000000 __PBOUT_L
000004cd g       *ABS*	00000000 __RESHI_H
00000512 g       *ABS*	00000000 __DMA0SA
00000502 g       *ABS*	00000000 __DMACTL1
000004cb g       *ABS*	00000000 __RESLO_H
000004a2 g       *ABS*	00000000 __RTCCTL23
00000129 g       *ABS*	00000000 __SVSMIO_H
00000735 g       *ABS*	00000000 __ADC12MEM10_H
00006288 g     F .text	0000005c vTaskDelayUntil
00000733 g       *ABS*	00000000 __ADC12MEM9_H
0000715a g     F .text	0000000c _ZN8__UART__11get_txCountEv
000004ad g       *ABS*	00000000 __RTCPS_H
00000269 g       *ABS*	00000000 __PDDS_H
000004d5 g       *ABS*	00000000 __MPYS32L_H
00005ca6  w      .text	00000000 __isr_27
000006b0 g       *ABS*	00000000 __UCB3I2COA_L
00005ca6  w      .text	00000000 __isr_38
00006b7e g     F .text	00000064 xQueueReceiveFromISR
00010000 g       .vectors	00000000 _vectors_end
00000734 g       *ABS*	00000000 __ADC12MEM10
0000070d g       *ABS*	00000000 __ADC12IE_H
00006764 g     F .text	00000062 xQueueGenericCreate
0000016e g       *ABS*	00000000 __UCSCTL7_L
000079a2 g     F .text	0000021e __mulsf3
0000050e g       *ABS*	00000000 __DMAIV_L
000004c2 g       *ABS*	00000000 __MPYS_L
00000532 g       *ABS*	00000000 __DMA2SA
0000061c g       *ABS*	00000000 __UCA1ICTL
000004aa g       *ABS*	00000000 __RTCPS1CTL
0000065e g       *ABS*	00000000 __UCA2IV
00000320 g       *ABS*	00000000 __PJIN_L
00000245 g       *ABS*	00000000 __PCDIR_H
0000061e g       *ABS*	00000000 __UCA1IV
00000188 g       *ABS*	00000000 __SYSJMBI0
00000719 g       *ABS*	00000000 __ADC12MCTL9
00000650 g       *ABS*	00000000 __UCA2ABCTL
00000630 g       *ABS*	00000000 __UCB1I2COA
00000354 g       *ABS*	00000000 __TA0CCR1
0000071a g       *ABS*	00000000 __ADC12MCTL10
00000288 g       *ABS*	00000000 __PEDS_L
00000701 g       *ABS*	00000000 __ADC12CTL0_H
00000692 g       *ABS*	00000000 __UCA3IRCTL
00000266 g       *ABS*	00000000 __PDREN_L
00000530 g       *ABS*	00000000 __DMA2CTL_L
000004c5 g       *ABS*	00000000 __MAC_H
000003d2 g       *ABS*	00000000 __TB0CCR0
00000147 g       *ABS*	00000000 __FCTL4_H
00000386 g       *ABS*	00000000 __TA1CCTL2
00000204 g       *ABS*	00000000 __PADIR_L
00000127 g       *ABS*	00000000 __SVSMLCTL_H
000005e6 g       *ABS*	00000000 __UCB0BRW
000004e1 g       *ABS*	00000000 __OP2L_H
000060d8 g     F .text	000000f2 xTaskResumeAll
000006bc g       *ABS*	00000000 __UCB3ICTL
000005e7 g       *ABS*	00000000 __UCB0BRW_H
00000150 g       *ABS*	00000000 __CRCDI
0000063d g       *ABS*	00000000 __UCB1ICTL_H
0000812c g     O .rodata	00000100 __clz_tab
00005f3e g     F .text	00000032 vTaskStartScheduler
00000509 g       *ABS*	00000000 __DMACTL4_H
000004d2 g       *ABS*	00000000 __MPY32H
00000202 g       *ABS*	00000000 __PAOUT
00000702 g       *ABS*	00000000 __ADC12CTL1
00000204 g       *ABS*	00000000 __PADIR
00000120 g       *ABS*	00000000 __PMMCTL0_L
00000248 g       *ABS*	00000000 __PCDS_L
0000021a g       *ABS*	00000000 __PAIE_L
0000073c g       *ABS*	00000000 __ADC12MEM14_L
000005ec g       *ABS*	00000000 __UCB0RXBUF
000004d6 g       *ABS*	00000000 __MPYS32H_L
00006c5e g     F .text	00000012 xQueueIsQueueFullFromISR
000002a8 g       *ABS*	00000000 __PFDS
0000070e g       *ABS*	00000000 __ADC12IV
00000702 g       *ABS*	00000000 __ADC12CTL1_L
00000520 g       *ABS*	00000000 __DMA1CTL
00000120 g       *ABS*	00000000 __PMMCTL0
000004e8 g       *ABS*	00000000 __RES2
0000070b g       *ABS*	00000000 __ADC12IFG_H
000005c6 g       *ABS*	00000000 __UCA0BRW
000002a8 g       *ABS*	00000000 __PFDS_L
00005ca6  w      .text	00000000 __isr_9
00000505 g       *ABS*	00000000 __DMACTL2_H
00000208 g       *ABS*	00000000 __PADS
00000166 g       *ABS*	00000000 __UCSCTL3_L
000004b6 g       *ABS*	00000000 __RTCYEAR
000005ce g       *ABS*	00000000 __UCA0TXBUF
00000384 g       *ABS*	00000000 __TA1CCTL1
00000286 g       *ABS*	00000000 __PEREN
00000666 g       *ABS*	00000000 __UCB2BRW
00005ca6  w      .text	00000000 __isr_35
00000162 g       *ABS*	00000000 __UCSCTL1
000004e6 g       *ABS*	00000000 __RES1
00000164 g       *ABS*	00000000 __UCSCTL2
00000170 g       *ABS*	00000000 __UCSCTL8_L
0000012d g       *ABS*	00000000 __PMMIFG_H
00000720 g       *ABS*	00000000 __ADC12MEM0_L
00005c0c  w      .text	00000000 __init_stack
000005d0 g       *ABS*	00000000 __UCA0ABCTL
00000263 g       *ABS*	00000000 __PDOUT_H
00000188 g       *ABS*	00000000 __SYSJMBI0_L
00000716 g       *ABS*	00000000 __ADC12MCTL6
00006468 g     F .text	00000006 vTaskMissedYield
00000168 g       *ABS*	00000000 __UCSCTL4_L
000005d2 g       *ABS*	00000000 __UCA0IRCTL
00000670 g       *ABS*	00000000 __UCB2I2COA_L
0000022a g       *ABS*	00000000 __PBSEL
0000012c g       *ABS*	00000000 __PMMIFG
00007466 g     F .text	00000024 _Z18uart_A3_initializev
00006c06 g     F .text	00000030 uxQueueMessagesWaiting
000069c2 g     F .text	000001bc xQueueGenericReceive
00005ca6  w      .text	00000000 __isr_30
000004b4 g       *ABS*	00000000 __RTCDATE_L
0000067d g       *ABS*	00000000 __UCB2ICTL_H
00000396 g       *ABS*	00000000 __TA1CCR2
00000510 g       *ABS*	00000000 __DMA0CTL_L
000006a7 g       *ABS*	00000000 __UCB3BRW_H
00000150 g       *ABS*	00000000 __CRCDI_L
00000686 g       *ABS*	00000000 __UCA3BRW_L
00005fc6 g     F .text	00000112 xTaskIncrementTick
00005ca6 g       .text	00000000 __dtors_start
00005ca6  w      .text	00000000 __isr_6
00000687 g       *ABS*	00000000 __UCA3BRW_H
00005ca6 g       .text	00000000 __ctors_end
000004c2 g       *ABS*	00000000 __MPYS
00000154 g       *ABS*	00000000 __CRCINIRES
00000394 g       *ABS*	00000000 __TA1CCR1
00000126 g       *ABS*	00000000 __SVSMLCTL
000006be g       *ABS*	00000000 __UCB3IV
00000169 g       *ABS*	00000000 __UCSCTL4_H
00005ca6  w      .text	00000000 __isr_22
000004d0 g       *ABS*	00000000 __MPY32L_L
000004dd g       *ABS*	00000000 __MACS32L_H
00005c00 g       *ABS*	00000000 __stack
000004d1 g       *ABS*	00000000 __MPY32L_H
00000260 g       *ABS*	00000000 __PDIN
00000620 g       *ABS*	00000000 __UCB1CTLW0
000004b7 g       *ABS*	00000000 __RTCYEAR_H
000005dd g       *ABS*	00000000 __UCA0ICTL_H
00005ca6  w      .text	00000000 __isr_1
0000071c g       *ABS*	00000000 __ADC12MCTL12
000066b2 g     F .text	000000b2 xQueueGenericReset
0000072c g       *ABS*	00000000 __ADC12MEM6_L
00001c08 g       .data	00000000 _edata
0000012e g       *ABS*	00000000 __PMMRIE
0000015c g       *ABS*	00000000 __WDTCTL_L
00002492 g       *ABS*	00000000 _end
0000028b g       *ABS*	00000000 __PESEL_H
000004b8 g       *ABS*	00000000 __RTCAMINHR_L
000004ce g       *ABS*	00000000 __SUMEXT_L
000006a1 g       *ABS*	00000000 __UCB3CTLW0_H
00000170 g       *ABS*	00000000 __UCSCTL8
00005ca6  w      .text	00000000 __isr_31
00000506 g       *ABS*	00000000 __DMACTL3
000003d8 g       *ABS*	00000000 __TB0CCR3
000002a9 g       *ABS*	00000000 __PFDS_H
000004de g       *ABS*	00000000 __MACS32H_L
00000660 g       *ABS*	00000000 __UCB2CTLW0_L
00006cc2 g     F .text	00000006 vPortInitialiseBlocks
000002a2 g       *ABS*	00000000 __PFOUT_L
0000063c g       *ABS*	00000000 __UCB1ICTL_L
00000646 g       *ABS*	00000000 __UCA2BRW_L
00000286 g       *ABS*	00000000 __PEREN_L
000004b0 g       *ABS*	00000000 __RTCTIM0
000004ac g       *ABS*	00000000 __RTCPS
00005ca6  w      .text	00000000 __isr_45
000003c6 g       *ABS*	00000000 __TB0CCTL2
00000521 g       *ABS*	00000000 __DMA1CTL_H
00007cf2 g     F .text	000000e0 __floatunsisf
0000068c g       *ABS*	00000000 __UCA3RXBUF
0000073e g       *ABS*	00000000 __ADC12MEM15
000004e9 g       *ABS*	00000000 __RES2_H
000005c6 g       *ABS*	00000000 __UCA0BRW_L
00006254 g     F .text	00000034 vTaskDelay
000004c4 g       *ABS*	00000000 __MAC
0000021a g       *ABS*	00000000 __PAIE
00000325 g       *ABS*	00000000 __PJDIR_H
00005c9e  w      .text	00000000 _endless_loop__
00000500 g       *ABS*	00000000 __DMACTL0
00000144 g       *ABS*	00000000 __FCTL3_L
00000630 g       *ABS*	00000000 __UCB1I2COA_L
0000064c g       *ABS*	00000000 __UCA2RXBUF
00005ca6  w      .text	00000000 __isr_15
00000726 g       *ABS*	00000000 __ADC12MEM3
00000221 g       *ABS*	00000000 __PBIN_H
00005ca6  w      .text	00000000 __isr_58
00000660 g       *ABS*	00000000 __UCB2CTLW0
00000241 g       *ABS*	00000000 __PCIN_H
0000019a g       *ABS*	00000000 __SYSUNIV_L
000004aa g       *ABS*	00000000 __RTCPS1CTL_L
00000653 g       *ABS*	00000000 __UCA2IRCTL_H
00000122 g       *ABS*	00000000 __PMMCTL1
000003c0 g       *ABS*	00000000 __TB0CTL
0000019a g       *ABS*	00000000 __SYSUNIV
0000022b g       *ABS*	00000000 __PBSEL_H
00000721 g       *ABS*	00000000 __ADC12MEM0_H
000002a6 g       *ABS*	00000000 __PFREN
00000281 g       *ABS*	00000000 __PEIN_H
000002a5 g       *ABS*	00000000 __PFDIR_H
00000503 g       *ABS*	00000000 __DMACTL1_H
00000209 g       *ABS*	00000000 __PADS_H
000005ee g       *ABS*	00000000 __UCB0TXBUF
0000016a g       *ABS*	00000000 __UCSCTL5_L
00000704 g       *ABS*	00000000 __ADC12CTL2
000004e0 g       *ABS*	00000000 __OP2L
0000066c g       *ABS*	00000000 __UCB2RXBUF
00006cd2 g     F .text	00000058 pxPortInitialiseStack
0000061c g       *ABS*	00000000 __UCA1ICTL_L
00000159 g       *ABS*	00000000 __RCCTL0_H
000004cf g       *ABS*	00000000 __SUMEXT_H
0000020b g       *ABS*	00000000 __PASEL_H
00005c10  w      .text	00000000 __low_level_init
00000288 g       *ABS*	00000000 __PEDS
00000189 g       *ABS*	00000000 __SYSJMBI0_H
00000227 g       *ABS*	00000000 __PBREN_H
000006a6 g       *ABS*	00000000 __UCB3BRW
000004a8 g       *ABS*	00000000 __RTCPS0CTL_L
00005ca6  w      .text	00000000 __isr_17
000003d6 g       *ABS*	00000000 __TB0CCR2
00000158 g       *ABS*	00000000 __RCCTL0_L
00000692 g       *ABS*	00000000 __UCA3IRCTL_L
000063f0 g     F .text	00000012 vTaskSetTimeOutState
00000641 g       *ABS*	00000000 __UCA2CTLW0_H
00001c00 g       .data	00000000 __data_start
00005ca6  w      .text	00000000 __isr_21
000003a0 g       *ABS*	00000000 __TA1EX0
00000627 g       *ABS*	00000000 __UCB1BRW_H
00005ca6  w      .text	00000000 __isr_62
00000729 g       *ABS*	00000000 __ADC12MEM4_H
00000162 g       *ABS*	00000000 __UCSCTL1_L
00000526 g       *ABS*	00000000 __DMA1DA
000005e1 g       *ABS*	00000000 __UCB0CTLW0_H
00006c36 g     F .text	00000006 uxQueueMessagesWaitingFromISR
00006c50 g     F .text	0000000e xQueueIsQueueEmptyFromISR
0000015c g       *ABS*	00000000 __WDTCTL
00000713 g       *ABS*	00000000 __ADC12MCTL3
00000182 g       *ABS*	00000000 __SYSBSLC
000002a0 g       *ABS*	00000000 __PFIN
0000018e g       *ABS*	00000000 __SYSJMBO1
000002a4 g       *ABS*	00000000 __PFDIR
0000021c g       *ABS*	00000000 __PAIFG_L
00000102 g       *ABS*	00000000 __SFRIFG1_L
00000680 g       *ABS*	00000000 __UCA3CTLW0
00000322 g       *ABS*	00000000 __PJOUT_L
00000180 g       *ABS*	00000000 __SYSCTL
00000507 g       *ABS*	00000000 __DMACTL3_H
000004e3 g       *ABS*	00000000 __OP2H_H
0000066e g       *ABS*	00000000 __UCB2TXBUF
00000225 g       *ABS*	00000000 __PBDIR_H
0000064a g       *ABS*	00000000 __UCA2STAT
000003c8 g       *ABS*	00000000 __TB0CCTL3
00000737 g       *ABS*	00000000 __ADC12MEM11_H
000004b1 g       *ABS*	00000000 __RTCTIM0_H
0000071b g       *ABS*	00000000 __ADC12MCTL11
00000264 g       *ABS*	00000000 __PDDIR
00007906 g     F .text	0000004c __addsf3
0000026a g       *ABS*	00000000 __PDSEL_L
00000725 g       *ABS*	00000000 __ADC12MEM2_H
0000737e g     F .text	0000001a _Z26uart_A3_disable_uart_A3_txv
00005ca6  w      .text	00000000 __isr_52
00000320 g       *ABS*	00000000 __PJIN
000005fd g       *ABS*	00000000 __UCB0ICTL_H
0000019c g       *ABS*	00000000 __SYSSNIV
000004ce g       *ABS*	00000000 __SUMEXT
00000126 g       *ABS*	00000000 __SVSMLCTL_L
00000265 g       *ABS*	00000000 __PDDIR_H
00000324 g       *ABS*	00000000 __PJDIR
0000072a g       *ABS*	00000000 __ADC12MEM5_L
000004c8 g       *ABS*	00000000 __OP2_L
00005ca6  w      .text	00000000 __isr_40
00000226 g       *ABS*	00000000 __PBREN
00005c3e  w      .text	00000000 __do_global_ctors



Disassembly of section .text:

00005c00 <__watchdog_support>:
    5c00:	55 42 5c 01 	mov.b	&0x015c,r5	
    5c04:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08
    5c08:	82 45 90 24 	mov	r5,	&0x2490	

00005c0c <__init_stack>:
    5c0c:	31 40 00 5c 	mov	#23552,	r1	;#0x5c00

00005c10 <__do_copy_data>:
    5c10:	3f 40 08 00 	mov	#8,	r15	;#0x0008
    5c14:	0f 93       	tst	r15		
    5c16:	08 24       	jz	$+18     	;abs 0x5c28
    5c18:	92 42 90 24 	mov	&0x2490,&0x015c	
    5c1c:	5c 01 
    5c1e:	2f 83       	decd	r15		
    5c20:	9f 4f 2c 82 	mov	-32212(r15),7168(r15);0x822c(r15), 0x1c00(r15)
    5c24:	00 1c 
    5c26:	f8 23       	jnz	$-14     	;abs 0x5c18

00005c28 <__do_clear_bss>:
    5c28:	3f 40 88 08 	mov	#2184,	r15	;#0x0888
    5c2c:	0f 93       	tst	r15		
    5c2e:	07 24       	jz	$+16     	;abs 0x5c3e
    5c30:	92 42 90 24 	mov	&0x2490,&0x015c	
    5c34:	5c 01 
    5c36:	1f 83       	dec	r15		
    5c38:	cf 43 08 1c 	mov.b	#0,	7176(r15);r3 As==00, 0x1c08(r15)
    5c3c:	f9 23       	jnz	$-12     	;abs 0x5c30

00005c3e <__do_global_ctors>:
    5c3e:	3b 40 a4 5c 	mov	#23716,	r11	;#0x5ca4
    5c42:	3a 40 a6 5c 	mov	#23718,	r10	;#0x5ca6
    5c46:	92 42 90 24 	mov	&0x2490,&0x015c	
    5c4a:	5c 01 
    5c4c:	bb 12       	call	@r11+		
    5c4e:	0b 9a       	cmp	r10,	r11	
    5c50:	fa 23       	jnz	$-10     	;abs 0x5c46

00005c52 <main>:
		vTaskDelay(LED_DELAY2/2);
	}
}
int main( void )
{
	hardwareInitialize();
    5c52:	b0 12 fc 6e 	call	#0x6efc	
	uart_A3.configure(9600,EVEN_PARITY);
    5c56:	0e 43       	clr	r14		
    5c58:	3f 40 80 25 	mov	#9600,	r15	;#0x2580
    5c5c:	92 12 86 24 	call	&0x2486	
	xTaskCreate(task_1, (signed char *) "task_1",100,0,1,0);
    5c60:	03 12       	push	#0		;r3 As==00
    5c62:	03 12       	push	#0		;r3 As==00
    5c64:	03 12       	push	#0		;r3 As==00
    5c66:	13 12       	push	#1		;r3 As==01
    5c68:	0c 43       	clr	r12		
    5c6a:	3d 40 64 00 	mov	#100,	r13	;#0x0064
    5c6e:	3e 40 15 81 	mov	#-32491,r14	;#0x8115
    5c72:	3f 40 82 6e 	mov	#28290,	r15	;#0x6e82
    5c76:	b0 12 ec 5c 	call	#0x5cec	
    5c7a:	31 52       	add	#8,	r1	;r2 As==11
	xTaskCreate(task_2, (signed char *) "task_2",100,0,1,0);
    5c7c:	03 12       	push	#0		;r3 As==00
    5c7e:	03 12       	push	#0		;r3 As==00
    5c80:	03 12       	push	#0		;r3 As==00
    5c82:	13 12       	push	#1		;r3 As==01
    5c84:	0c 43       	clr	r12		
    5c86:	3d 40 64 00 	mov	#100,	r13	;#0x0064
    5c8a:	3e 40 1c 81 	mov	#-32484,r14	;#0x811c
    5c8e:	3f 40 4c 6e 	mov	#28236,	r15	;#0x6e4c
    5c92:	b0 12 ec 5c 	call	#0x5cec	
    5c96:	31 52       	add	#8,	r1	;r2 As==11
	vTaskStartScheduler();
    5c98:	b0 12 3e 5f 	call	#0x5f3e	
	return -1;
}
    5c9c:	3f 43       	mov	#-1,	r15	;r3 As==11

00005c9e <__stop_progExec__>:
    5c9e:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    5ca2:	fd 3f       	jmp	$-4      	;abs 0x5c9e

00005ca4 <__ctors_start>:
    5ca4:	8a 74 30 40 	subc	r4,	16432(r10);0x4030(r10)

00005ca6 <__ctors_end>:
    5ca6:	30 40 0e 81 	br	#0x810e	

00005caa <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    5caa:	0b 12       	push	r11		
    5cac:	0b 4f       	mov	r15,	r11	
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    5cae:	1f 42 08 1c 	mov	&0x1c08,r15	
    5cb2:	8f 4b 02 00 	mov	r11,	2(r15)	;0x0002(r15)

	if( xTimeToWake < xTickCount )
    5cb6:	1f 42 16 1c 	mov	&0x1c16,r15	
    5cba:	0b 9f       	cmp	r15,	r11	
    5cbc:	08 2c       	jc	$+18     	;abs 0x5cce
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    5cbe:	1e 42 08 1c 	mov	&0x1c08,r14	
    5cc2:	1f 42 1c 1c 	mov	&0x1c1c,r15	
    5cc6:	2e 53       	incd	r14		
    5cc8:	b0 12 b2 64 	call	#0x64b2	
    5ccc:	0d 3c       	jmp	$+28     	;abs 0x5ce8
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    5cce:	1e 42 08 1c 	mov	&0x1c08,r14	
    5cd2:	1f 42 1e 1c 	mov	&0x1c1e,r15	
    5cd6:	2e 53       	incd	r14		
    5cd8:	b0 12 b2 64 	call	#0x64b2	

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    5cdc:	1f 42 00 1c 	mov	&0x1c00,r15	
    5ce0:	0b 9f       	cmp	r15,	r11	
    5ce2:	02 2c       	jc	$+6      	;abs 0x5ce8
		{
			xNextTaskUnblockTime = xTimeToWake;
    5ce4:	82 4b 00 1c 	mov	r11,	&0x1c00	
		}
	}
}
    5ce8:	3b 41       	pop	r11		
    5cea:	30 41       	ret			

00005cec <xTaskGenericCreate>:
	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    5cec:	7b 15       	pushm	#8,	r11	
    5cee:	06 4f       	mov	r15,	r6	
    5cf0:	0a 4e       	mov	r14,	r10	
    5cf2:	09 4d       	mov	r13,	r9	
    5cf4:	05 4c       	mov	r12,	r5	
    5cf6:	17 41 12 00 	mov	18(r1),	r7	;0x0012(r1)
    5cfa:	18 41 16 00 	mov	22(r1),	r8	;0x0016(r1)
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    5cfe:	3f 40 22 00 	mov	#34,	r15	;#0x0022
    5d02:	b0 12 70 6c 	call	#0x6c70	
    5d06:	0b 4f       	mov	r15,	r11	

	if( pxNewTCB != NULL )
    5d08:	0f 93       	tst	r15		
    5d0a:	ce 24       	jz	$+414    	;abs 0x5ea8
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5d0c:	08 93       	tst	r8		
    5d0e:	d3 20       	jnz	$+424    	;abs 0x5eb6
    5d10:	0f 49       	mov	r9,	r15	
    5d12:	5f 02       	rlam	#1,	r15	
    5d14:	b0 12 70 6c 	call	#0x6c70	
    5d18:	08 4f       	mov	r15,	r8	
    5d1a:	8b 4f 18 00 	mov	r15,	24(r11)	;0x0018(r11)

		if( pxNewTCB->pxStack == NULL )
    5d1e:	0f 93       	tst	r15		
    5d20:	05 20       	jnz	$+12     	;abs 0x5d2c
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    5d22:	0f 4b       	mov	r11,	r15	
    5d24:	b0 12 c0 6c 	call	#0x6cc0	
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    5d28:	3f 43       	mov	#-1,	r15	;r3 As==11
    5d2a:	c3 3c       	jmp	$+392    	;abs 0x5eb2
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    5d2c:	0d 49       	mov	r9,	r13	
    5d2e:	5d 02       	rlam	#1,	r13	
    5d30:	3e 40 a5 00 	mov	#165,	r14	;#0x00a5
    5d34:	0f 48       	mov	r8,	r15	
    5d36:	b0 12 78 75 	call	#0x7578	
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    5d3a:	39 53       	add	#-1,	r9	;r3 As==11
    5d3c:	59 02       	rlam	#1,	r9	
    5d3e:	19 5b 18 00 	add	24(r11),r9	;0x0018(r11)
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    5d42:	04 49       	mov	r9,	r4	
    5d44:	34 f0 fe ff 	and	#-2,	r4	;#0xfffe
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    5d48:	eb 4a 1a 00 	mov.b	@r10,	26(r11)	;0x001a(r11)

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    5d4c:	ca 93 00 00 	tst.b	0(r10)		;0x0000(r10)
    5d50:	0f 24       	jz	$+32     	;abs 0x5d70

	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
    5d52:	1a 53       	inc	r10		
    5d54:	09 4b       	mov	r11,	r9	
    5d56:	39 50 1b 00 	add	#27,	r9	;#0x001b
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
    5d5a:	18 43       	mov	#1,	r8	;r3 As==01
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    5d5c:	e9 4a 00 00 	mov.b	@r10,	0(r9)	;0x0000(r9)

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    5d60:	ca 93 00 00 	tst.b	0(r10)		;0x0000(r10)
    5d64:	05 24       	jz	$+12     	;abs 0x5d70
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
    5d66:	18 53       	inc	r8		
    5d68:	1a 53       	inc	r10		
    5d6a:	19 53       	inc	r9		
    5d6c:	38 92       	cmp	#8,	r8	;r2 As==11
    5d6e:	f6 23       	jnz	$-18     	;abs 0x5d5c
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
    5d70:	cb 43 21 00 	mov.b	#0,	33(r11)	;r3 As==00, 0x0021(r11)
    5d74:	0a 47       	mov	r7,	r10	
    5d76:	27 92       	cmp	#4,	r7	;r2 As==10
    5d78:	02 28       	jnc	$+6      	;abs 0x5d7e
    5d7a:	3a 40 03 00 	mov	#3,	r10	;#0x0003
	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
	{
		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    5d7e:	8b 4a 16 00 	mov	r10,	22(r11)	;0x0016(r11)
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    5d82:	08 4b       	mov	r11,	r8	
    5d84:	28 53       	incd	r8		
    5d86:	0f 48       	mov	r8,	r15	
    5d88:	b0 12 88 64 	call	#0x6488	
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    5d8c:	0f 4b       	mov	r11,	r15	
    5d8e:	3f 50 0c 00 	add	#12,	r15	;#0x000c
    5d92:	b0 12 88 64 	call	#0x6488	

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    5d96:	8b 4b 08 00 	mov	r11,	8(r11)	;0x0008(r11)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5d9a:	2e 42       	mov	#4,	r14	;r2 As==10
    5d9c:	0e 8a       	sub	r10,	r14	
    5d9e:	8b 4e 0c 00 	mov	r14,	12(r11)	;0x000c(r11)
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    5da2:	8b 4b 12 00 	mov	r11,	18(r11)	;0x0012(r11)
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    5da6:	0d 45       	mov	r5,	r13	
    5da8:	0e 46       	mov	r6,	r14	
    5daa:	0f 44       	mov	r4,	r15	
    5dac:	b0 12 d2 6c 	call	#0x6cd2	
    5db0:	8b 4f 00 00 	mov	r15,	0(r11)	;0x0000(r11)
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    5db4:	81 93 14 00 	tst	20(r1)		;0x0014(r1)
    5db8:	04 24       	jz	$+10     	;abs 0x5dc2
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    5dba:	1f 41 14 00 	mov	20(r1),	r15	;0x0014(r1)
    5dbe:	8f 4b 00 00 	mov	r11,	0(r15)	;0x0000(r15)
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    5dc2:	32 c2       	dint			
    5dc4:	03 43       	nop			
    5dc6:	1f 42 02 1c 	mov	&0x1c02,r15	
    5dca:	1f 53       	inc	r15		
    5dcc:	82 4f 02 1c 	mov	r15,	&0x1c02	
		{
			uxCurrentNumberOfTasks++;
    5dd0:	1f 42 18 1c 	mov	&0x1c18,r15	
    5dd4:	1f 53       	inc	r15		
    5dd6:	82 4f 18 1c 	mov	r15,	&0x1c18	
			if( pxCurrentTCB == NULL )
    5dda:	1f 42 08 1c 	mov	&0x1c08,r15	
    5dde:	0f 93       	tst	r15		
    5de0:	29 20       	jnz	$+84     	;abs 0x5e34
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    5de2:	82 4b 08 1c 	mov	r11,	&0x1c08	

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    5de6:	1f 42 18 1c 	mov	&0x1c18,r15	
    5dea:	1f 93       	cmp	#1,	r15	;r3 As==01
    5dec:	2e 20       	jnz	$+94     	;abs 0x5e4a
    5dee:	0a 43       	clr	r10		
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5df0:	0f 4a       	mov	r10,	r15	
    5df2:	5f 06       	rlam	#2,	r15	
    5df4:	0f 5a       	add	r10,	r15	
    5df6:	5f 02       	rlam	#1,	r15	
    5df8:	3f 50 22 1c 	add	#7202,	r15	;#0x1c22
    5dfc:	b0 12 6e 64 	call	#0x646e	

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
    5e00:	1a 53       	inc	r10		
    5e02:	2a 92       	cmp	#4,	r10	;r2 As==10
    5e04:	f5 23       	jnz	$-20     	;abs 0x5df0
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5e06:	3f 40 4a 1c 	mov	#7242,	r15	;#0x1c4a
    5e0a:	b0 12 6e 64 	call	#0x646e	
	vListInitialise( &xDelayedTaskList2 );
    5e0e:	3f 40 54 1c 	mov	#7252,	r15	;#0x1c54
    5e12:	b0 12 6e 64 	call	#0x646e	
	vListInitialise( &xPendingReadyList );
    5e16:	3f 40 5e 1c 	mov	#7262,	r15	;#0x1c5e
    5e1a:	b0 12 6e 64 	call	#0x646e	

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    5e1e:	3f 40 68 1c 	mov	#7272,	r15	;#0x1c68
    5e22:	b0 12 6e 64 	call	#0x646e	
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5e26:	b2 40 4a 1c 	mov	#7242,	&0x1c1e	;#0x1c4a
    5e2a:	1e 1c 
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5e2c:	b2 40 54 1c 	mov	#7252,	&0x1c1c	;#0x1c54
    5e30:	1c 1c 
    5e32:	0b 3c       	jmp	$+24     	;abs 0x5e4a
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    5e34:	1f 42 12 1c 	mov	&0x1c12,r15	
    5e38:	0f 93       	tst	r15		
    5e3a:	07 20       	jnz	$+16     	;abs 0x5e4a
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    5e3c:	1f 42 08 1c 	mov	&0x1c08,r15	
    5e40:	17 9f 16 00 	cmp	22(r15),r7	;0x0016(r15)
    5e44:	02 28       	jnc	$+6      	;abs 0x5e4a
					{
						pxCurrentTCB = pxNewTCB;
    5e46:	82 4b 08 1c 	mov	r11,	&0x1c08	
					}
				}
			}

			uxTaskNumber++;
    5e4a:	92 53 20 1c 	inc	&0x1c20	
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    5e4e:	1d 4b 16 00 	mov	22(r11),r13	;0x0016(r11)
    5e52:	1f 42 14 1c 	mov	&0x1c14,r15	
    5e56:	0f 9d       	cmp	r13,	r15	
    5e58:	02 2c       	jc	$+6      	;abs 0x5e5e
    5e5a:	82 4d 14 1c 	mov	r13,	&0x1c14	
    5e5e:	0f 4d       	mov	r13,	r15	
    5e60:	5f 06       	rlam	#2,	r15	
    5e62:	0d 5f       	add	r15,	r13	
    5e64:	5d 02       	rlam	#1,	r13	
    5e66:	0e 48       	mov	r8,	r14	
    5e68:	0f 4d       	mov	r13,	r15	
    5e6a:	3f 50 22 1c 	add	#7202,	r15	;#0x1c22
    5e6e:	b0 12 8e 64 	call	#0x648e	

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    5e72:	1f 42 02 1c 	mov	&0x1c02,r15	
    5e76:	0f 93       	tst	r15		
    5e78:	0a 24       	jz	$+22     	;abs 0x5e8e
    5e7a:	1f 42 02 1c 	mov	&0x1c02,r15	
    5e7e:	3f 53       	add	#-1,	r15	;r3 As==11
    5e80:	82 4f 02 1c 	mov	r15,	&0x1c02	
    5e84:	1f 42 02 1c 	mov	&0x1c02,r15	
    5e88:	0f 93       	tst	r15		
    5e8a:	01 20       	jnz	$+4      	;abs 0x5e8e
    5e8c:	32 d2       	eint			
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    5e8e:	1f 42 12 1c 	mov	&0x1c12,r15	
    5e92:	0f 93       	tst	r15		
    5e94:	0b 24       	jz	$+24     	;abs 0x5eac
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    5e96:	1f 42 08 1c 	mov	&0x1c08,r15	
    5e9a:	8f 97 16 00 	cmp	r7,	22(r15)	;0x0016(r15)
    5e9e:	08 2c       	jc	$+18     	;abs 0x5eb0
			{
				portYIELD_WITHIN_API();
    5ea0:	b0 12 92 6d 	call	#0x6d92	
    5ea4:	1f 43       	mov	#1,	r15	;r3 As==01
    5ea6:	05 3c       	jmp	$+12     	;abs 0x5eb2
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    5ea8:	3f 43       	mov	#-1,	r15	;r3 As==11
    5eaa:	03 3c       	jmp	$+8      	;abs 0x5eb2
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    5eac:	1f 43       	mov	#1,	r15	;r3 As==01
    5eae:	01 3c       	jmp	$+4      	;abs 0x5eb2
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    5eb0:	1f 43       	mov	#1,	r15	;r3 As==01
			}
		}
	}

	return xReturn;
}
    5eb2:	74 17       	popm	#8,	r11	
    5eb4:	30 41       	ret			
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5eb6:	8f 48 18 00 	mov	r8,	24(r15)	;0x0018(r15)
    5eba:	38 3f       	jmp	$-398    	;abs 0x5d2c

00005ebc <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
    5ebc:	1b 15       	pushm	#2,	r11	
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    5ebe:	32 c2       	dint			
    5ec0:	03 43       	nop			
    5ec2:	1e 42 02 1c 	mov	&0x1c02,r14	
    5ec6:	1e 53       	inc	r14		
    5ec8:	82 4e 02 1c 	mov	r14,	&0x1c02	
		{
			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    5ecc:	0f 93       	tst	r15		
    5ece:	03 20       	jnz	$+8      	;abs 0x5ed6
    5ed0:	1b 42 08 1c 	mov	&0x1c08,r11	
    5ed4:	01 3c       	jmp	$+4      	;abs 0x5ed8
    5ed6:	0b 4f       	mov	r15,	r11	

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
    5ed8:	0a 4b       	mov	r11,	r10	
    5eda:	2a 53       	incd	r10		
    5edc:	0f 4a       	mov	r10,	r15	
    5ede:	b0 12 f0 64 	call	#0x64f0	
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5ee2:	8b 93 14 00 	tst	20(r11)	;0x0014(r11)
    5ee6:	05 24       	jz	$+12     	;abs 0x5ef2
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5ee8:	0f 4b       	mov	r11,	r15	
    5eea:	3f 50 0c 00 	add	#12,	r15	;#0x000c
    5eee:	b0 12 f0 64 	call	#0x64f0	
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    5ef2:	0e 4a       	mov	r10,	r14	
    5ef4:	3f 40 68 1c 	mov	#7272,	r15	;#0x1c68
    5ef8:	b0 12 8e 64 	call	#0x648e	

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    5efc:	1f 42 1a 1c 	mov	&0x1c1a,r15	
    5f00:	1f 53       	inc	r15		
    5f02:	82 4f 1a 1c 	mov	r15,	&0x1c1a	

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    5f06:	92 53 20 1c 	inc	&0x1c20	

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    5f0a:	1f 42 02 1c 	mov	&0x1c02,r15	
    5f0e:	0f 93       	tst	r15		
    5f10:	0a 24       	jz	$+22     	;abs 0x5f26
    5f12:	1f 42 02 1c 	mov	&0x1c02,r15	
    5f16:	3f 53       	add	#-1,	r15	;r3 As==11
    5f18:	82 4f 02 1c 	mov	r15,	&0x1c02	
    5f1c:	1f 42 02 1c 	mov	&0x1c02,r15	
    5f20:	0f 93       	tst	r15		
    5f22:	01 20       	jnz	$+4      	;abs 0x5f26
    5f24:	32 d2       	eint			

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    5f26:	1f 42 12 1c 	mov	&0x1c12,r15	
    5f2a:	0f 93       	tst	r15		
    5f2c:	06 24       	jz	$+14     	;abs 0x5f3a
		{
			if( pxTCB == pxCurrentTCB )
    5f2e:	1f 42 08 1c 	mov	&0x1c08,r15	
    5f32:	0b 9f       	cmp	r15,	r11	
    5f34:	02 20       	jnz	$+6      	;abs 0x5f3a
			{
				portYIELD_WITHIN_API();
    5f36:	b0 12 92 6d 	call	#0x6d92	
			}
		}
	}
    5f3a:	1a 17       	popm	#2,	r11	
    5f3c:	30 41       	ret			

00005f3e <vTaskStartScheduler>:
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    5f3e:	03 12       	push	#0		;r3 As==00
    5f40:	03 12       	push	#0		;r3 As==00
    5f42:	03 12       	push	#0		;r3 As==00
    5f44:	03 12       	push	#0		;r3 As==00
    5f46:	0c 43       	clr	r12		
    5f48:	3d 40 32 00 	mov	#50,	r13	;#0x0032
    5f4c:	3e 40 10 81 	mov	#-32496,r14	;#0x8110
    5f50:	3f 40 ca 61 	mov	#25034,	r15	;#0x61ca
    5f54:	b0 12 ec 5c 	call	#0x5cec	
    5f58:	31 52       	add	#8,	r1	;r2 As==11
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    5f5a:	1f 93       	cmp	#1,	r15	;r3 As==01
    5f5c:	08 20       	jnz	$+18     	;abs 0x5f6e
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    5f5e:	32 c2       	dint			
    5f60:	03 43       	nop			

		xSchedulerRunning = pdTRUE;
    5f62:	92 43 12 1c 	mov	#1,	&0x1c12	;r3 As==01
		xTickCount = ( portTickType ) 0U;
    5f66:	82 43 16 1c 	mov	#0,	&0x1c16	;r3 As==00
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5f6a:	b0 12 2a 6d 	call	#0x6d2a	
    5f6e:	30 41       	ret			

00005f70 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    5f70:	32 c2       	dint			
    5f72:	03 43       	nop			
	xSchedulerRunning = pdFALSE;
    5f74:	82 43 12 1c 	mov	#0,	&0x1c12	;r3 As==00
	vPortEndScheduler();
    5f78:	b0 12 90 6d 	call	#0x6d90	
}
    5f7c:	30 41       	ret			

00005f7e <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    5f7e:	1f 42 10 1c 	mov	&0x1c10,r15	
    5f82:	1f 53       	inc	r15		
    5f84:	82 4f 10 1c 	mov	r15,	&0x1c10	
}
    5f88:	30 41       	ret			

00005f8a <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    5f8a:	32 c2       	dint			
    5f8c:	03 43       	nop			
    5f8e:	1f 42 02 1c 	mov	&0x1c02,r15	
    5f92:	1f 53       	inc	r15		
    5f94:	82 4f 02 1c 	mov	r15,	&0x1c02	
	{
		xTicks = xTickCount;
    5f98:	1f 42 16 1c 	mov	&0x1c16,r15	
	}
	taskEXIT_CRITICAL();
    5f9c:	1e 42 02 1c 	mov	&0x1c02,r14	
    5fa0:	0e 93       	tst	r14		
    5fa2:	0a 24       	jz	$+22     	;abs 0x5fb8
    5fa4:	1e 42 02 1c 	mov	&0x1c02,r14	
    5fa8:	3e 53       	add	#-1,	r14	;r3 As==11
    5faa:	82 4e 02 1c 	mov	r14,	&0x1c02	
    5fae:	1e 42 02 1c 	mov	&0x1c02,r14	
    5fb2:	0e 93       	tst	r14		
    5fb4:	01 20       	jnz	$+4      	;abs 0x5fb8
    5fb6:	32 d2       	eint			

	return xTicks;
}
    5fb8:	30 41       	ret			

00005fba <xTaskGetTickCountFromISR>:
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    5fba:	1f 42 16 1c 	mov	&0x1c16,r15	
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    5fbe:	30 41       	ret			

00005fc0 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    5fc0:	1f 42 18 1c 	mov	&0x1c18,r15	
}
    5fc4:	30 41       	ret			

00005fc6 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

portBASE_TYPE xTaskIncrementTick( void )
{
    5fc6:	3b 15       	pushm	#4,	r11	

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    5fc8:	1f 42 10 1c 	mov	&0x1c10,r15	
    5fcc:	0f 93       	tst	r15		
    5fce:	79 20       	jnz	$+244    	;abs 0x60c2
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    5fd0:	1f 42 16 1c 	mov	&0x1c16,r15	
    5fd4:	1f 53       	inc	r15		
    5fd6:	82 4f 16 1c 	mov	r15,	&0x1c16	

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
    5fda:	19 42 16 1c 	mov	&0x1c16,r9	

			if( xConstTickCount == ( portTickType ) 0U )
    5fde:	09 93       	tst	r9		
    5fe0:	1f 20       	jnz	$+64     	;abs 0x6020
			{
				taskSWITCH_DELAYED_LISTS();
    5fe2:	1f 42 1e 1c 	mov	&0x1c1e,r15	
    5fe6:	1e 42 1c 1c 	mov	&0x1c1c,r14	
    5fea:	82 4e 1e 1c 	mov	r14,	&0x1c1e	
    5fee:	82 4f 1c 1c 	mov	r15,	&0x1c1c	
    5ff2:	1f 42 0a 1c 	mov	&0x1c0a,r15	
    5ff6:	1f 53       	inc	r15		
    5ff8:	82 4f 0a 1c 	mov	r15,	&0x1c0a	
    5ffc:	1f 42 1e 1c 	mov	&0x1c1e,r15	
    6000:	8f 93 00 00 	tst	0(r15)		;0x0000(r15)
    6004:	03 20       	jnz	$+8      	;abs 0x600c
    6006:	b2 43 00 1c 	mov	#-1,	&0x1c00	;r3 As==11
    600a:	0a 3c       	jmp	$+22     	;abs 0x6020
    600c:	1f 42 1e 1c 	mov	&0x1c1e,r15	
    6010:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    6014:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    6018:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    601c:	82 4f 00 1c 	mov	r15,	&0x1c00	

			/* See if this tick has made a timeout expire.  Tasks are stored in the
			queue in the order of their wake time - meaning once one tasks has been
			found whose block time has not expired there is no need not look any
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    6020:	1f 42 00 1c 	mov	&0x1c00,r15	
    6024:	09 9f       	cmp	r15,	r9	
    6026:	04 2c       	jc	$+10     	;abs 0x6030

portBASE_TYPE xTaskIncrementTick( void )
{
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
    6028:	08 43       	clr	r8		
    602a:	3e 3c       	jmp	$+126    	;abs 0x60a8
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
    602c:	18 43       	mov	#1,	r8	;r3 As==01
    602e:	01 3c       	jmp	$+4      	;abs 0x6032

			/* See if this tick has made a timeout expire.  Tasks are stored in the
			queue in the order of their wake time - meaning once one tasks has been
			found whose block time has not expired there is no need not look any
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    6030:	08 43       	clr	r8		
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6032:	1e 42 1e 1c 	mov	&0x1c1e,r14	
    6036:	8e 93 00 00 	tst	0(r14)		;0x0000(r14)
    603a:	03 20       	jnz	$+8      	;abs 0x6042
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    603c:	b2 43 00 1c 	mov	#-1,	&0x1c00	;r3 As==11
						break;
    6040:	33 3c       	jmp	$+104    	;abs 0x60a8
					{
						/* The delayed list is not empty, get the value of the item
						at the head of the delayed list.  This is the time at which
						the task at the head of the delayed list must be removed
						from the Blocked state. */
						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    6042:	1e 42 1e 1c 	mov	&0x1c1e,r14	
    6046:	1e 4e 06 00 	mov	6(r14),	r14	;0x0006(r14)
    604a:	1b 4e 06 00 	mov	6(r14),	r11	;0x0006(r14)
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    604e:	1e 4b 02 00 	mov	2(r11),	r14	;0x0002(r11)

						if( xConstTickCount < xItemValue )
    6052:	09 9e       	cmp	r14,	r9	
    6054:	03 2c       	jc	$+8      	;abs 0x605c
						{
							/* It is not time to unblock this item yet, but the item
							value is the time at which the task at the head of the
							blocked list must be removed from the Blocked state -
							so record the item value in xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    6056:	82 4e 00 1c 	mov	r14,	&0x1c00	
							break;
    605a:	26 3c       	jmp	$+78     	;abs 0x60a8
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    605c:	0a 4b       	mov	r11,	r10	
    605e:	2a 53       	incd	r10		
    6060:	0f 4a       	mov	r10,	r15	
    6062:	b0 12 f0 64 	call	#0x64f0	

						/* Is the task waiting on an event also?  If so remove it
						from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    6066:	8b 93 14 00 	tst	20(r11)	;0x0014(r11)
    606a:	05 24       	jz	$+12     	;abs 0x6076
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    606c:	0f 4b       	mov	r11,	r15	
    606e:	3f 50 0c 00 	add	#12,	r15	;#0x000c
    6072:	b0 12 f0 64 	call	#0x64f0	
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    6076:	1d 4b 16 00 	mov	22(r11),r13	;0x0016(r11)
    607a:	1f 42 14 1c 	mov	&0x1c14,r15	
    607e:	0f 9d       	cmp	r13,	r15	
    6080:	02 2c       	jc	$+6      	;abs 0x6086
    6082:	82 4d 14 1c 	mov	r13,	&0x1c14	
    6086:	0e 4d       	mov	r13,	r14	
    6088:	5e 06       	rlam	#2,	r14	
    608a:	0d 5e       	add	r14,	r13	
    608c:	5d 02       	rlam	#1,	r13	
    608e:	0e 4a       	mov	r10,	r14	
    6090:	0f 4d       	mov	r13,	r15	
    6092:	3f 50 22 1c 	add	#7202,	r15	;#0x1c22
    6096:	b0 12 8e 64 	call	#0x648e	
						{
							/* Preemption is on, but a context switch should only
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    609a:	1e 42 08 1c 	mov	&0x1c08,r14	
    609e:	9b 9e 16 00 	cmp	22(r14),22(r11)	;0x0016(r14), 0x0016(r11)
    60a2:	16 00 
    60a4:	c3 2f       	jc	$-120    	;abs 0x602c
    60a6:	c5 3f       	jmp	$-116    	;abs 0x6032
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    60a8:	1f 42 08 1c 	mov	&0x1c08,r15	
    60ac:	1e 4f 16 00 	mov	22(r15),r14	;0x0016(r15)
    60b0:	5e 06       	rlam	#2,	r14	
    60b2:	1e 5f 16 00 	add	22(r15),r14	;0x0016(r15)
    60b6:	0f 4e       	mov	r14,	r15	
    60b8:	5f 02       	rlam	#1,	r15	
    60ba:	af 93 22 1c 	cmp	#2,	7202(r15);r3 As==10, 0x1c22(r15)
    60be:	08 2c       	jc	$+18     	;abs 0x60d0
    60c0:	08 3c       	jmp	$+18     	;abs 0x60d2
		}
		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
	}
	else
	{
		++uxPendedTicks;
    60c2:	1f 42 0e 1c 	mov	&0x1c0e,r15	
    60c6:	1f 53       	inc	r15		
    60c8:	82 4f 0e 1c 	mov	r15,	&0x1c0e	

portBASE_TYPE xTaskIncrementTick( void )
{
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
    60cc:	08 43       	clr	r8		
    60ce:	01 3c       	jmp	$+4      	;abs 0x60d2
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
			{
				xSwitchRequired = pdTRUE;
    60d0:	18 43       	mov	#1,	r8	;r3 As==01
		}
	}
	#endif /* configUSE_TICK_HOOK */

	return xSwitchRequired;
}
    60d2:	0f 48       	mov	r8,	r15	
    60d4:	38 17       	popm	#4,	r11	
    60d6:	30 41       	ret			

000060d8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    60d8:	3b 15       	pushm	#4,	r11	
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    60da:	32 c2       	dint			
    60dc:	03 43       	nop			
    60de:	1f 42 02 1c 	mov	&0x1c02,r15	
    60e2:	1f 53       	inc	r15		
    60e4:	82 4f 02 1c 	mov	r15,	&0x1c02	
	{
		--uxSchedulerSuspended;
    60e8:	1f 42 10 1c 	mov	&0x1c10,r15	
    60ec:	3f 53       	add	#-1,	r15	;r3 As==11
    60ee:	82 4f 10 1c 	mov	r15,	&0x1c10	

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    60f2:	1f 42 10 1c 	mov	&0x1c10,r15	
    60f6:	0f 93       	tst	r15		
    60f8:	55 20       	jnz	$+172    	;abs 0x61a4
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    60fa:	1f 42 18 1c 	mov	&0x1c18,r15	
    60fe:	0f 93       	tst	r15		
    6100:	29 20       	jnz	$+84     	;abs 0x6154
    6102:	53 3c       	jmp	$+168    	;abs 0x61aa
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    6104:	1f 42 64 1c 	mov	&0x1c64,r15	
    6108:	1b 4f 06 00 	mov	6(r15),	r11	;0x0006(r15)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    610c:	0f 4b       	mov	r11,	r15	
    610e:	3f 50 0c 00 	add	#12,	r15	;#0x000c
    6112:	b0 12 f0 64 	call	#0x64f0	
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    6116:	0a 4b       	mov	r11,	r10	
    6118:	2a 53       	incd	r10		
    611a:	0f 4a       	mov	r10,	r15	
    611c:	b0 12 f0 64 	call	#0x64f0	
					prvAddTaskToReadyList( pxTCB );
    6120:	1d 4b 16 00 	mov	22(r11),r13	;0x0016(r11)
    6124:	1f 42 14 1c 	mov	&0x1c14,r15	
    6128:	0f 9d       	cmp	r13,	r15	
    612a:	02 2c       	jc	$+6      	;abs 0x6130
    612c:	82 4d 14 1c 	mov	r13,	&0x1c14	
    6130:	0f 4d       	mov	r13,	r15	
    6132:	5f 06       	rlam	#2,	r15	
    6134:	0d 5f       	add	r15,	r13	
    6136:	5d 02       	rlam	#1,	r13	
    6138:	0e 4a       	mov	r10,	r14	
    613a:	0f 4d       	mov	r13,	r15	
    613c:	3f 50 22 1c 	add	#7202,	r15	;#0x1c22
    6140:	b0 12 8e 64 	call	#0x648e	

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6144:	1f 42 08 1c 	mov	&0x1c08,r15	
    6148:	9b 9f 16 00 	cmp	22(r15),22(r11)	;0x0016(r15), 0x0016(r11)
    614c:	16 00 
    614e:	05 28       	jnc	$+12     	;abs 0x615a
					{
						xYieldRequired = pdTRUE;
    6150:	18 43       	mov	#1,	r8	;r3 As==01
    6152:	03 3c       	jmp	$+8      	;abs 0x615a
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    6154:	08 43       	clr	r8		
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    6156:	39 40 5e 1c 	mov	#7262,	r9	;#0x1c5e
    615a:	89 93 00 00 	tst	0(r9)		;0x0000(r9)
    615e:	d2 23       	jnz	$-90     	;abs 0x6104
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
    6160:	1f 42 0e 1c 	mov	&0x1c0e,r15	
    6164:	0f 93       	tst	r15		
    6166:	12 24       	jz	$+38     	;abs 0x618c
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
    6168:	1f 42 0e 1c 	mov	&0x1c0e,r15	
    616c:	0f 93       	tst	r15		
    616e:	0e 24       	jz	$+30     	;abs 0x618c
					{
						if( xTaskIncrementTick() != pdFALSE )
    6170:	b0 12 c6 5f 	call	#0x5fc6	
    6174:	0f 93       	tst	r15		
    6176:	01 24       	jz	$+4      	;abs 0x617a
						{
							xYieldRequired = pdTRUE;
    6178:	18 43       	mov	#1,	r8	;r3 As==01
						}
						--uxPendedTicks;
    617a:	1f 42 0e 1c 	mov	&0x1c0e,r15	
    617e:	3f 53       	add	#-1,	r15	;r3 As==11
    6180:	82 4f 0e 1c 	mov	r15,	&0x1c0e	
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
    6184:	1f 42 0e 1c 	mov	&0x1c0e,r15	
    6188:	0f 93       	tst	r15		
    618a:	f2 23       	jnz	$-26     	;abs 0x6170
						}
						--uxPendedTicks;
					}
				}

				if( ( xYieldRequired == pdTRUE ) || ( xYieldPending == pdTRUE ) )
    618c:	18 93       	cmp	#1,	r8	;r3 As==01
    618e:	04 24       	jz	$+10     	;abs 0x6198
    6190:	1f 42 0c 1c 	mov	&0x1c0c,r15	
    6194:	1f 93       	cmp	#1,	r15	;r3 As==01
    6196:	08 20       	jnz	$+18     	;abs 0x61a8
				{
					xAlreadyYielded = pdTRUE;
					xYieldPending = pdFALSE;
    6198:	82 43 0c 1c 	mov	#0,	&0x1c0c	;r3 As==00
					portYIELD_WITHIN_API();
    619c:	b0 12 92 6d 	call	#0x6d92	
					}
				}

				if( ( xYieldRequired == pdTRUE ) || ( xYieldPending == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    61a0:	1f 43       	mov	#1,	r15	;r3 As==01
    61a2:	03 3c       	jmp	$+8      	;abs 0x61aa
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;
    61a4:	0f 43       	clr	r15		
    61a6:	01 3c       	jmp	$+4      	;abs 0x61aa
    61a8:	0f 43       	clr	r15		
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    61aa:	1e 42 02 1c 	mov	&0x1c02,r14	
    61ae:	0e 93       	tst	r14		
    61b0:	0a 24       	jz	$+22     	;abs 0x61c6
    61b2:	1e 42 02 1c 	mov	&0x1c02,r14	
    61b6:	3e 53       	add	#-1,	r14	;r3 As==11
    61b8:	82 4e 02 1c 	mov	r14,	&0x1c02	
    61bc:	1e 42 02 1c 	mov	&0x1c02,r14	
    61c0:	0e 93       	tst	r14		
    61c2:	01 20       	jnz	$+4      	;abs 0x61c6
    61c4:	32 d2       	eint			

	return xAlreadyYielded;
}
    61c6:	38 17       	popm	#4,	r11	
    61c8:	30 41       	ret			

000061ca <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    61ca:	2b 15       	pushm	#3,	r11	
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    61cc:	3b 40 68 1c 	mov	#7272,	r11	;#0x1c68

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    61d0:	39 40 22 1c 	mov	#7202,	r9	;#0x1c22
    61d4:	35 3c       	jmp	$+108    	;abs 0x6240

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
    61d6:	b0 12 7e 5f 	call	#0x5f7e	
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    61da:	2a 4b       	mov	@r11,	r10	
			( void ) xTaskResumeAll();
    61dc:	b0 12 d8 60 	call	#0x60d8	

			if( xListIsEmpty == pdFALSE )
    61e0:	0a 93       	tst	r10		
    61e2:	2e 24       	jz	$+94     	;abs 0x6240
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    61e4:	32 c2       	dint			
    61e6:	03 43       	nop			
    61e8:	1f 42 02 1c 	mov	&0x1c02,r15	
    61ec:	1f 53       	inc	r15		
    61ee:	82 4f 02 1c 	mov	r15,	&0x1c02	
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    61f2:	1f 42 6e 1c 	mov	&0x1c6e,r15	
    61f6:	1a 4f 06 00 	mov	6(r15),	r10	;0x0006(r15)
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    61fa:	0f 4a       	mov	r10,	r15	
    61fc:	2f 53       	incd	r15		
    61fe:	b0 12 f0 64 	call	#0x64f0	
					--uxCurrentNumberOfTasks;
    6202:	1f 42 18 1c 	mov	&0x1c18,r15	
    6206:	3f 53       	add	#-1,	r15	;r3 As==11
    6208:	82 4f 18 1c 	mov	r15,	&0x1c18	
					--uxTasksDeleted;
    620c:	1f 42 1a 1c 	mov	&0x1c1a,r15	
    6210:	3f 53       	add	#-1,	r15	;r3 As==11
    6212:	82 4f 1a 1c 	mov	r15,	&0x1c1a	
				}
				taskEXIT_CRITICAL();
    6216:	1f 42 02 1c 	mov	&0x1c02,r15	
    621a:	0f 93       	tst	r15		
    621c:	0a 24       	jz	$+22     	;abs 0x6232
    621e:	1f 42 02 1c 	mov	&0x1c02,r15	
    6222:	3f 53       	add	#-1,	r15	;r3 As==11
    6224:	82 4f 02 1c 	mov	r15,	&0x1c02	
    6228:	1f 42 02 1c 	mov	&0x1c02,r15	
    622c:	0f 93       	tst	r15		
    622e:	01 20       	jnz	$+4      	;abs 0x6232
    6230:	32 d2       	eint			
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    6232:	1f 4a 18 00 	mov	24(r10),r15	;0x0018(r10)
    6236:	b0 12 c0 6c 	call	#0x6cc0	
		vPortFree( pxTCB );
    623a:	0f 4a       	mov	r10,	r15	
    623c:	b0 12 c0 6c 	call	#0x6cc0	
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    6240:	1f 42 1a 1c 	mov	&0x1c1a,r15	
    6244:	0f 93       	tst	r15		
    6246:	c7 23       	jnz	$-112    	;abs 0x61d6

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    6248:	a9 93 00 00 	cmp	#2,	0(r9)	;r3 As==10, 0x0000(r9)
    624c:	f9 2b       	jnc	$-12     	;abs 0x6240
			{
				taskYIELD();
    624e:	b0 12 92 6d 	call	#0x6d92	
    6252:	f6 3f       	jmp	$-18     	;abs 0x6240

00006254 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    6254:	0b 12       	push	r11		
    6256:	0b 4f       	mov	r15,	r11	
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    6258:	0f 93       	tst	r15		
    625a:	12 24       	jz	$+38     	;abs 0x6280
		{
			vTaskSuspendAll();
    625c:	b0 12 7e 5f 	call	#0x5f7e	
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    6260:	1f 42 16 1c 	mov	&0x1c16,r15	
    6264:	0b 5f       	add	r15,	r11	

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
    6266:	1e 42 08 1c 	mov	&0x1c08,r14	
    626a:	0f 4e       	mov	r14,	r15	
    626c:	2f 53       	incd	r15		
    626e:	b0 12 f0 64 	call	#0x64f0	
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    6272:	0f 4b       	mov	r11,	r15	
    6274:	b0 12 aa 5c 	call	#0x5caa	
			}
			xAlreadyYielded = xTaskResumeAll();
    6278:	b0 12 d8 60 	call	#0x60d8	
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    627c:	0f 93       	tst	r15		
    627e:	02 20       	jnz	$+6      	;abs 0x6284
		{
			portYIELD_WITHIN_API();
    6280:	b0 12 92 6d 	call	#0x6d92	
		}
	}
    6284:	3b 41       	pop	r11		
    6286:	30 41       	ret			

00006288 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    6288:	1b 15       	pushm	#2,	r11	
    628a:	0a 4f       	mov	r15,	r10	
    628c:	0b 4e       	mov	r14,	r11	
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    628e:	b0 12 7e 5f 	call	#0x5f7e	
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
    6292:	1d 42 16 1c 	mov	&0x1c16,r13	

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    6296:	2f 4a       	mov	@r10,	r15	
    6298:	0b 5f       	add	r15,	r11	

			if( xConstTickCount < *pxPreviousWakeTime )
    629a:	0d 9f       	cmp	r15,	r13	
    629c:	07 2c       	jc	$+16     	;abs 0x62ac
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    629e:	0b 9f       	cmp	r15,	r11	
    62a0:	1c 2c       	jc	$+58     	;abs 0x62da
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    62a2:	8a 4b 00 00 	mov	r11,	0(r10)	;0x0000(r10)

			if( xShouldDelay != pdFALSE )
    62a6:	0d 9b       	cmp	r11,	r13	
    62a8:	0e 2c       	jc	$+30     	;abs 0x62c6
    62aa:	05 3c       	jmp	$+12     	;abs 0x62b6
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    62ac:	0b 9f       	cmp	r15,	r11	
    62ae:	12 28       	jnc	$+38     	;abs 0x62d4
    62b0:	0d 9b       	cmp	r11,	r13	
    62b2:	10 28       	jnc	$+34     	;abs 0x62d4
    62b4:	12 3c       	jmp	$+38     	;abs 0x62da
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
    62b6:	1f 42 08 1c 	mov	&0x1c08,r15	
    62ba:	2f 53       	incd	r15		
    62bc:	b0 12 f0 64 	call	#0x64f0	
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    62c0:	0f 4b       	mov	r11,	r15	
    62c2:	b0 12 aa 5c 	call	#0x5caa	
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    62c6:	b0 12 d8 60 	call	#0x60d8	

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    62ca:	0f 93       	tst	r15		
    62cc:	09 20       	jnz	$+20     	;abs 0x62e0
		{
			portYIELD_WITHIN_API();
    62ce:	b0 12 92 6d 	call	#0x6d92	
    62d2:	06 3c       	jmp	$+14     	;abs 0x62e0
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    62d4:	8a 4b 00 00 	mov	r11,	0(r10)	;0x0000(r10)
    62d8:	ee 3f       	jmp	$-34     	;abs 0x62b6
    62da:	8a 4b 00 00 	mov	r11,	0(r10)	;0x0000(r10)
    62de:	f3 3f       	jmp	$-24     	;abs 0x62c6
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    62e0:	1a 17       	popm	#2,	r11	
    62e2:	30 41       	ret			

000062e4 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    62e4:	1f 42 10 1c 	mov	&0x1c10,r15	
    62e8:	0f 93       	tst	r15		
    62ea:	0a 20       	jnz	$+22     	;abs 0x6300
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    62ec:	1f 42 14 1c 	mov	&0x1c14,r15	
    62f0:	0e 4f       	mov	r15,	r14	
    62f2:	5e 06       	rlam	#2,	r14	
    62f4:	0f 5e       	add	r14,	r15	
    62f6:	5f 02       	rlam	#1,	r15	
    62f8:	8f 93 22 1c 	tst	7202(r15)	;0x1c22(r15)
    62fc:	04 24       	jz	$+10     	;abs 0x6306
    62fe:	11 3c       	jmp	$+36     	;abs 0x6322
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    6300:	92 43 0c 1c 	mov	#1,	&0x1c0c	;r3 As==01
    6304:	30 41       	ret			
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    6306:	1f 42 14 1c 	mov	&0x1c14,r15	
    630a:	3f 53       	add	#-1,	r15	;r3 As==11
    630c:	82 4f 14 1c 	mov	r15,	&0x1c14	
    6310:	1f 42 14 1c 	mov	&0x1c14,r15	
    6314:	0e 4f       	mov	r15,	r14	
    6316:	5e 06       	rlam	#2,	r14	
    6318:	0f 5e       	add	r14,	r15	
    631a:	5f 02       	rlam	#1,	r15	
    631c:	8f 93 22 1c 	tst	7202(r15)	;0x1c22(r15)
    6320:	f2 27       	jz	$-26     	;abs 0x6306
    6322:	1f 42 14 1c 	mov	&0x1c14,r15	
    6326:	0e 4f       	mov	r15,	r14	
    6328:	5e 06       	rlam	#2,	r14	
    632a:	0f 5e       	add	r14,	r15	
    632c:	5f 02       	rlam	#1,	r15	
    632e:	3f 50 22 1c 	add	#7202,	r15	;#0x1c22
    6332:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    6336:	1e 4e 02 00 	mov	2(r14),	r14	;0x0002(r14)
    633a:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
    633e:	0d 4f       	mov	r15,	r13	
    6340:	2d 52       	add	#4,	r13	;r2 As==10
    6342:	0e 9d       	cmp	r13,	r14	
    6344:	03 20       	jnz	$+8      	;abs 0x634c
    6346:	9f 4e 02 00 	mov	2(r14),	2(r15)	;0x0002(r14), 0x0002(r15)
    634a:	02 00 
    634c:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    6350:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    6354:	82 4f 08 1c 	mov	r15,	&0x1c08	
    6358:	30 41       	ret			

0000635a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
    635a:	0b 12       	push	r11		
    635c:	0b 4e       	mov	r14,	r11	
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    635e:	1d 42 08 1c 	mov	&0x1c08,r13	
    6362:	0e 4d       	mov	r13,	r14	
    6364:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    6368:	b0 12 b2 64 	call	#0x64b2	

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
    636c:	1f 42 08 1c 	mov	&0x1c08,r15	
    6370:	2f 53       	incd	r15		
    6372:	b0 12 f0 64 	call	#0x64f0	
	}
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    6376:	1f 42 16 1c 	mov	&0x1c16,r15	
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    637a:	0f 5b       	add	r11,	r15	
    637c:	b0 12 aa 5c 	call	#0x5caa	
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    6380:	3b 41       	pop	r11		
    6382:	30 41       	ret			

00006384 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    6384:	1b 15       	pushm	#2,	r11	
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    6386:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    638a:	1b 4f 06 00 	mov	6(r15),	r11	;0x0006(r15)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    638e:	0a 4b       	mov	r11,	r10	
    6390:	3a 50 0c 00 	add	#12,	r10	;#0x000c
    6394:	0f 4a       	mov	r10,	r15	
    6396:	b0 12 f0 64 	call	#0x64f0	

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    639a:	1f 42 10 1c 	mov	&0x1c10,r15	
    639e:	0f 93       	tst	r15		
    63a0:	18 20       	jnz	$+50     	;abs 0x63d2
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    63a2:	3a 50 f6 ff 	add	#-10,	r10	;#0xfff6
    63a6:	0f 4a       	mov	r10,	r15	
    63a8:	b0 12 f0 64 	call	#0x64f0	
		prvAddTaskToReadyList( pxUnblockedTCB );
    63ac:	1d 4b 16 00 	mov	22(r11),r13	;0x0016(r11)
    63b0:	1f 42 14 1c 	mov	&0x1c14,r15	
    63b4:	0f 9d       	cmp	r13,	r15	
    63b6:	02 2c       	jc	$+6      	;abs 0x63bc
    63b8:	82 4d 14 1c 	mov	r13,	&0x1c14	
    63bc:	0f 4d       	mov	r13,	r15	
    63be:	5f 06       	rlam	#2,	r15	
    63c0:	0d 5f       	add	r15,	r13	
    63c2:	5d 02       	rlam	#1,	r13	
    63c4:	0e 4a       	mov	r10,	r14	
    63c6:	0f 4d       	mov	r13,	r15	
    63c8:	3f 50 22 1c 	add	#7202,	r15	;#0x1c22
    63cc:	b0 12 8e 64 	call	#0x648e	
    63d0:	05 3c       	jmp	$+12     	;abs 0x63dc
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    63d2:	0e 4a       	mov	r10,	r14	
    63d4:	3f 40 5e 1c 	mov	#7262,	r15	;#0x1c5e
    63d8:	b0 12 8e 64 	call	#0x648e	
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    63dc:	1e 42 08 1c 	mov	&0x1c08,r14	
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    63e0:	1f 43       	mov	#1,	r15	;r3 As==01
    63e2:	9b 9e 16 00 	cmp	22(r14),22(r11)	;0x0016(r14), 0x0016(r11)
    63e6:	16 00 
    63e8:	01 2c       	jc	$+4      	;abs 0x63ec
    63ea:	0f 43       	clr	r15		
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    63ec:	1a 17       	popm	#2,	r11	
    63ee:	30 41       	ret			

000063f0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    63f0:	1e 42 0a 1c 	mov	&0x1c0a,r14	
    63f4:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
	pxTimeOut->xTimeOnEntering = xTickCount;
    63f8:	1e 42 16 1c 	mov	&0x1c16,r14	
    63fc:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
}
    6400:	30 41       	ret			

00006402 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    6402:	1b 15       	pushm	#2,	r11	
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    6404:	32 c2       	dint			
    6406:	03 43       	nop			
    6408:	1d 42 02 1c 	mov	&0x1c02,r13	
    640c:	1d 53       	inc	r13		
    640e:	82 4d 02 1c 	mov	r13,	&0x1c02	
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
    6412:	1d 42 16 1c 	mov	&0x1c16,r13	
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    6416:	1c 42 0a 1c 	mov	&0x1c0a,r12	
    641a:	2c 9f       	cmp	@r15,	r12	
    641c:	03 24       	jz	$+8      	;abs 0x6424
    641e:	1d 9f 02 00 	cmp	2(r15),	r13	;0x0002(r15)
    6422:	0f 2c       	jc	$+32     	;abs 0x6442
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    6424:	1b 4f 02 00 	mov	2(r15),	r11	;0x0002(r15)
    6428:	2c 4e       	mov	@r14,	r12	
    642a:	0a 4d       	mov	r13,	r10	
    642c:	0a 8b       	sub	r11,	r10	
    642e:	0a 9c       	cmp	r12,	r10	
    6430:	0a 2c       	jc	$+22     	;abs 0x6446
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    6432:	0b 8d       	sub	r13,	r11	
    6434:	0b 5c       	add	r12,	r11	
    6436:	8e 4b 00 00 	mov	r11,	0(r14)	;0x0000(r14)
			vTaskSetTimeOutState( pxTimeOut );
    643a:	b0 12 f0 63 	call	#0x63f0	
			xReturn = pdFALSE;
    643e:	0f 43       	clr	r15		
    6440:	03 3c       	jmp	$+8      	;abs 0x6448
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    6442:	1f 43       	mov	#1,	r15	;r3 As==01
    6444:	01 3c       	jmp	$+4      	;abs 0x6448
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    6446:	1f 43       	mov	#1,	r15	;r3 As==01
		}
	}
	taskEXIT_CRITICAL();
    6448:	1e 42 02 1c 	mov	&0x1c02,r14	
    644c:	0e 93       	tst	r14		
    644e:	0a 24       	jz	$+22     	;abs 0x6464
    6450:	1e 42 02 1c 	mov	&0x1c02,r14	
    6454:	3e 53       	add	#-1,	r14	;r3 As==11
    6456:	82 4e 02 1c 	mov	r14,	&0x1c02	
    645a:	1e 42 02 1c 	mov	&0x1c02,r14	
    645e:	0e 93       	tst	r14		
    6460:	01 20       	jnz	$+4      	;abs 0x6464
    6462:	32 d2       	eint			

	return xReturn;
}
    6464:	1a 17       	popm	#2,	r11	
    6466:	30 41       	ret			

00006468 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    6468:	92 43 0c 1c 	mov	#1,	&0x1c0c	;r3 As==01
}
    646c:	30 41       	ret			

0000646e <vListInitialise>:
void vListInitialise( xList * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    646e:	0e 4f       	mov	r15,	r14	
    6470:	2e 52       	add	#4,	r14	;r2 As==10
    6472:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    6476:	bf 43 04 00 	mov	#-1,	4(r15)	;r3 As==11, 0x0004(r15)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    647a:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    647e:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    6482:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
}
    6486:	30 41       	ret			

00006488 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    6488:	8f 43 08 00 	mov	#0,	8(r15)	;r3 As==00, 0x0008(r15)
}
    648c:	30 41       	ret			

0000648e <vListInsertEnd>:
xListItem * pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;
    648e:	1d 4f 02 00 	mov	2(r15),	r13	;0x0002(r15)

	pxNewListItem->pxNext = pxIndex;
    6492:	8e 4d 02 00 	mov	r13,	2(r14)	;0x0002(r14)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    6496:	9e 4d 04 00 	mov	4(r13),	4(r14)	;0x0004(r13), 0x0004(r14)
    649a:	04 00 
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    649c:	1c 4d 04 00 	mov	4(r13),	r12	;0x0004(r13)
    64a0:	8c 4e 02 00 	mov	r14,	2(r12)	;0x0002(r12)
	pxIndex->pxPrevious = pxNewListItem;
    64a4:	8d 4e 04 00 	mov	r14,	4(r13)	;0x0004(r13)

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    64a8:	8e 4f 08 00 	mov	r15,	8(r14)	;0x0008(r14)

	( pxList->uxNumberOfItems )++;
    64ac:	9f 53 00 00 	inc	0(r15)		;0x0000(r15)
}
    64b0:	30 41       	ret			

000064b2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
{
    64b2:	0b 12       	push	r11		
xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    64b4:	2b 4e       	mov	@r14,	r11	
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    64b6:	3b 93       	cmp	#-1,	r11	;r3 As==11
    64b8:	03 20       	jnz	$+8      	;abs 0x64c0
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    64ba:	1d 4f 08 00 	mov	8(r15),	r13	;0x0008(r15)
    64be:	08 3c       	jmp	$+18     	;abs 0x64d0
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    64c0:	0d 4f       	mov	r15,	r13	
    64c2:	2d 52       	add	#4,	r13	;r2 As==10
    64c4:	01 3c       	jmp	$+4      	;abs 0x64c8
    64c6:	0d 4c       	mov	r12,	r13	
    64c8:	1c 4d 02 00 	mov	2(r13),	r12	;0x0002(r13)
    64cc:	2b 9c       	cmp	@r12,	r11	
    64ce:	fb 2f       	jc	$-8      	;abs 0x64c6
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    64d0:	1c 4d 02 00 	mov	2(r13),	r12	;0x0002(r13)
    64d4:	8e 4c 02 00 	mov	r12,	2(r14)	;0x0002(r14)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    64d8:	8c 4e 04 00 	mov	r14,	4(r12)	;0x0004(r12)
	pxNewListItem->pxPrevious = pxIterator;
    64dc:	8e 4d 04 00 	mov	r13,	4(r14)	;0x0004(r14)
	pxIterator->pxNext = pxNewListItem;
    64e0:	8d 4e 02 00 	mov	r14,	2(r13)	;0x0002(r13)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    64e4:	8e 4f 08 00 	mov	r15,	8(r14)	;0x0008(r14)

	( pxList->uxNumberOfItems )++;
    64e8:	9f 53 00 00 	inc	0(r15)		;0x0000(r15)
}
    64ec:	3b 41       	pop	r11		
    64ee:	30 41       	ret			

000064f0 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    64f0:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    64f4:	9e 4f 04 00 	mov	4(r15),	4(r14)	;0x0004(r15), 0x0004(r14)
    64f8:	04 00 
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    64fa:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    64fe:	9e 4f 02 00 	mov	2(r15),	2(r14)	;0x0002(r15), 0x0002(r14)
    6502:	02 00 

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    6504:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    6508:	1d 4e 02 00 	mov	2(r14),	r13	;0x0002(r14)
    650c:	0d 9f       	cmp	r15,	r13	
    650e:	03 20       	jnz	$+8      	;abs 0x6516
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    6510:	9e 4d 04 00 	mov	4(r13),	2(r14)	;0x0004(r13), 0x0002(r14)
    6514:	02 00 
	}

	pxItemToRemove->pvContainer = NULL;
    6516:	8f 43 08 00 	mov	#0,	8(r15)	;r3 As==00, 0x0008(r15)
	( pxList->uxNumberOfItems )--;
    651a:	2f 4e       	mov	@r14,	r15	
    651c:	3f 53       	add	#-1,	r15	;r3 As==11
    651e:	8e 4f 00 00 	mov	r15,	0(r14)	;0x0000(r14)

	return pxList->uxNumberOfItems;
}
    6522:	30 41       	ret			

00006524 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
{
    6524:	0b 12       	push	r11		
    6526:	0c 4e       	mov	r14,	r12	
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    6528:	2b 4f       	mov	@r15,	r11	
    652a:	0b 93       	tst	r11		
    652c:	11 24       	jz	$+36     	;abs 0x6550
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    652e:	1d 4f 20 00 	mov	32(r15),r13	;0x0020(r15)
    6532:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    6536:	0e 5d       	add	r13,	r14	
    6538:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    653c:	1e 9f 02 00 	cmp	2(r15),	r14	;0x0002(r15)
    6540:	02 28       	jnc	$+6      	;abs 0x6546
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    6542:	8f 4b 06 00 	mov	r11,	6(r15)	;0x0006(r15)
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    6546:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    654a:	0f 4c       	mov	r12,	r15	
    654c:	b0 12 94 74 	call	#0x7494	
	}
}
    6550:	3b 41       	pop	r11		
    6552:	30 41       	ret			

00006554 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    6554:	1b 15       	pushm	#2,	r11	
    6556:	0b 4f       	mov	r15,	r11	
    6558:	0a 4d       	mov	r13,	r10	
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    655a:	1f 4f 20 00 	mov	32(r15),r15	;0x0020(r15)
    655e:	0f 93       	tst	r15		
    6560:	32 24       	jz	$+102    	;abs 0x65c6
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    6562:	0d 93       	tst	r13		
    6564:	11 20       	jnz	$+36     	;abs 0x6588
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    6566:	0d 4f       	mov	r15,	r13	
    6568:	1f 4b 04 00 	mov	4(r11),	r15	;0x0004(r11)
    656c:	b0 12 94 74 	call	#0x7494	
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    6570:	1f 4b 04 00 	mov	4(r11),	r15	;0x0004(r11)
    6574:	1f 5b 20 00 	add	32(r11),r15	;0x0020(r11)
    6578:	8b 4f 04 00 	mov	r15,	4(r11)	;0x0004(r11)
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    657c:	1f 9b 02 00 	cmp	2(r11),	r15	;0x0002(r11)
    6580:	22 28       	jnc	$+70     	;abs 0x65c6
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    6582:	ab 4b 04 00 	mov	@r11,	4(r11)	;0x0004(r11)
    6586:	1f 3c       	jmp	$+64     	;abs 0x65c6
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6588:	0d 4f       	mov	r15,	r13	
    658a:	1f 4b 06 00 	mov	6(r11),	r15	;0x0006(r11)
    658e:	b0 12 94 74 	call	#0x7494	
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    6592:	1f 4b 20 00 	mov	32(r11),r15	;0x0020(r11)
    6596:	3f e3       	inv	r15		
    6598:	1f 53       	inc	r15		
    659a:	1e 4b 06 00 	mov	6(r11),	r14	;0x0006(r11)
    659e:	0e 5f       	add	r15,	r14	
    65a0:	8b 4e 06 00 	mov	r14,	6(r11)	;0x0006(r11)
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    65a4:	2e 9b       	cmp	@r11,	r14	
    65a6:	04 2c       	jc	$+10     	;abs 0x65b0
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    65a8:	1f 5b 02 00 	add	2(r11),	r15	;0x0002(r11)
    65ac:	8b 4f 06 00 	mov	r15,	6(r11)	;0x0006(r11)
		}

		if( xPosition == queueOVERWRITE )
    65b0:	2a 93       	cmp	#2,	r10	;r3 As==10
    65b2:	09 20       	jnz	$+20     	;abs 0x65c6
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    65b4:	1f 4b 1c 00 	mov	28(r11),r15	;0x001c(r11)
    65b8:	0f 93       	tst	r15		
    65ba:	05 24       	jz	$+12     	;abs 0x65c6
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    65bc:	1f 4b 1c 00 	mov	28(r11),r15	;0x001c(r11)
    65c0:	3f 53       	add	#-1,	r15	;r3 As==11
    65c2:	8b 4f 1c 00 	mov	r15,	28(r11)	;0x001c(r11)
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
    65c6:	1f 4b 1c 00 	mov	28(r11),r15	;0x001c(r11)
    65ca:	1f 53       	inc	r15		
    65cc:	8b 4f 1c 00 	mov	r15,	28(r11)	;0x001c(r11)
}
    65d0:	1a 17       	popm	#2,	r11	
    65d2:	30 41       	ret			

000065d4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
    65d4:	1b 15       	pushm	#2,	r11	
    65d6:	0b 4f       	mov	r15,	r11	

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    65d8:	32 c2       	dint			
    65da:	03 43       	nop			
    65dc:	1f 42 02 1c 	mov	&0x1c02,r15	
    65e0:	1f 53       	inc	r15		
    65e2:	82 4f 02 1c 	mov	r15,	&0x1c02	
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    65e6:	1f 4b 24 00 	mov	36(r11),r15	;0x0024(r11)
    65ea:	1f 93       	cmp	#1,	r15	;r3 As==01
    65ec:	1b 38       	jl	$+56     	;abs 0x6624
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    65ee:	8b 93 12 00 	tst	18(r11)	;0x0012(r11)
    65f2:	05 20       	jnz	$+12     	;abs 0x65fe
    65f4:	17 3c       	jmp	$+48     	;abs 0x6624
    65f6:	8b 93 12 00 	tst	18(r11)	;0x0012(r11)
    65fa:	04 20       	jnz	$+10     	;abs 0x6604
    65fc:	13 3c       	jmp	$+40     	;abs 0x6624
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    65fe:	0a 4b       	mov	r11,	r10	
    6600:	3a 50 12 00 	add	#18,	r10	;#0x0012
    6604:	0f 4a       	mov	r10,	r15	
    6606:	b0 12 84 63 	call	#0x6384	
    660a:	0f 93       	tst	r15		
    660c:	02 24       	jz	$+6      	;abs 0x6612
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    660e:	b0 12 68 64 	call	#0x6468	
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    6612:	1e 4b 24 00 	mov	36(r11),r14	;0x0024(r11)
    6616:	3e 53       	add	#-1,	r14	;r3 As==11
    6618:	8b 4e 24 00 	mov	r14,	36(r11)	;0x0024(r11)
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    661c:	1e 4b 24 00 	mov	36(r11),r14	;0x0024(r11)
    6620:	1e 93       	cmp	#1,	r14	;r3 As==01
    6622:	e9 37       	jge	$-44     	;abs 0x65f6
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    6624:	bb 43 24 00 	mov	#-1,	36(r11)	;r3 As==11, 0x0024(r11)
	}
	taskEXIT_CRITICAL();
    6628:	1f 42 02 1c 	mov	&0x1c02,r15	
    662c:	0f 93       	tst	r15		
    662e:	0a 24       	jz	$+22     	;abs 0x6644
    6630:	1f 42 02 1c 	mov	&0x1c02,r15	
    6634:	3f 53       	add	#-1,	r15	;r3 As==11
    6636:	82 4f 02 1c 	mov	r15,	&0x1c02	
    663a:	1f 42 02 1c 	mov	&0x1c02,r15	
    663e:	0f 93       	tst	r15		
    6640:	01 20       	jnz	$+4      	;abs 0x6644
    6642:	32 d2       	eint			

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    6644:	32 c2       	dint			
    6646:	03 43       	nop			
    6648:	1f 42 02 1c 	mov	&0x1c02,r15	
    664c:	1f 53       	inc	r15		
    664e:	82 4f 02 1c 	mov	r15,	&0x1c02	
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    6652:	1f 4b 22 00 	mov	34(r11),r15	;0x0022(r11)
    6656:	1f 93       	cmp	#1,	r15	;r3 As==01
    6658:	1a 38       	jl	$+54     	;abs 0x668e
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    665a:	8b 93 08 00 	tst	8(r11)		;0x0008(r11)
    665e:	05 20       	jnz	$+12     	;abs 0x666a
    6660:	16 3c       	jmp	$+46     	;abs 0x668e
    6662:	8b 93 08 00 	tst	8(r11)		;0x0008(r11)
    6666:	03 20       	jnz	$+8      	;abs 0x666e
    6668:	12 3c       	jmp	$+38     	;abs 0x668e
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    666a:	0a 4b       	mov	r11,	r10	
    666c:	3a 52       	add	#8,	r10	;r2 As==11
    666e:	0f 4a       	mov	r10,	r15	
    6670:	b0 12 84 63 	call	#0x6384	
    6674:	0f 93       	tst	r15		
    6676:	02 24       	jz	$+6      	;abs 0x667c
				{
					vTaskMissedYield();
    6678:	b0 12 68 64 	call	#0x6468	
				}

				--( pxQueue->xRxLock );
    667c:	1e 4b 22 00 	mov	34(r11),r14	;0x0022(r11)
    6680:	3e 53       	add	#-1,	r14	;r3 As==11
    6682:	8b 4e 22 00 	mov	r14,	34(r11)	;0x0022(r11)
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    6686:	1e 4b 22 00 	mov	34(r11),r14	;0x0022(r11)
    668a:	1e 93       	cmp	#1,	r14	;r3 As==01
    668c:	ea 37       	jge	$-42     	;abs 0x6662
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    668e:	bb 43 22 00 	mov	#-1,	34(r11)	;r3 As==11, 0x0022(r11)
	}
	taskEXIT_CRITICAL();
    6692:	1f 42 02 1c 	mov	&0x1c02,r15	
    6696:	0f 93       	tst	r15		
    6698:	0a 24       	jz	$+22     	;abs 0x66ae
    669a:	1f 42 02 1c 	mov	&0x1c02,r15	
    669e:	3f 53       	add	#-1,	r15	;r3 As==11
    66a0:	82 4f 02 1c 	mov	r15,	&0x1c02	
    66a4:	1f 42 02 1c 	mov	&0x1c02,r15	
    66a8:	0f 93       	tst	r15		
    66aa:	01 20       	jnz	$+4      	;abs 0x66ae
    66ac:	32 d2       	eint			
}
    66ae:	1a 17       	popm	#2,	r11	
    66b0:	30 41       	ret			

000066b2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
    66b2:	1b 15       	pushm	#2,	r11	
    66b4:	0b 4f       	mov	r15,	r11	
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    66b6:	32 c2       	dint			
    66b8:	03 43       	nop			
    66ba:	1f 42 02 1c 	mov	&0x1c02,r15	
    66be:	1f 53       	inc	r15		
    66c0:	82 4f 02 1c 	mov	r15,	&0x1c02	
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    66c4:	2f 4b       	mov	@r11,	r15	
    66c6:	1c 4b 1e 00 	mov	30(r11),r12	;0x001e(r11)
    66ca:	1d 4b 20 00 	mov	32(r11),r13	;0x0020(r11)
    66ce:	02 12       	push	r2		
    66d0:	32 c2       	dint			
    66d2:	03 43       	nop			
    66d4:	82 4d c2 04 	mov	r13,	&0x04c2	
    66d8:	82 4c c8 04 	mov	r12,	&0x04c8	
    66dc:	1a 42 ca 04 	mov	&0x04ca,r10	
    66e0:	32 41       	pop	r2		
    66e2:	0a 5f       	add	r15,	r10	
    66e4:	8b 4a 02 00 	mov	r10,	2(r11)	;0x0002(r11)
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    66e8:	8b 43 1c 00 	mov	#0,	28(r11)	;r3 As==00, 0x001c(r11)
		pxQueue->pcWriteTo = pxQueue->pcHead;
    66ec:	8b 4f 04 00 	mov	r15,	4(r11)	;0x0004(r11)
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    66f0:	3c 53       	add	#-1,	r12	;r3 As==11
    66f2:	02 12       	push	r2		
    66f4:	32 c2       	dint			
    66f6:	03 43       	nop			
    66f8:	82 4c c2 04 	mov	r12,	&0x04c2	
    66fc:	82 4d c8 04 	mov	r13,	&0x04c8	
    6700:	1d 42 ca 04 	mov	&0x04ca,r13	
    6704:	32 41       	pop	r2		
    6706:	0f 5d       	add	r13,	r15	
    6708:	8b 4f 06 00 	mov	r15,	6(r11)	;0x0006(r11)
		pxQueue->xRxLock = queueUNLOCKED;
    670c:	bb 43 22 00 	mov	#-1,	34(r11)	;r3 As==11, 0x0022(r11)
		pxQueue->xTxLock = queueUNLOCKED;
    6710:	bb 43 24 00 	mov	#-1,	36(r11)	;r3 As==11, 0x0024(r11)

		if( xNewQueue == pdFALSE )
    6714:	0e 93       	tst	r14		
    6716:	0c 20       	jnz	$+26     	;abs 0x6730
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    6718:	8b 93 08 00 	tst	8(r11)		;0x0008(r11)
    671c:	12 24       	jz	$+38     	;abs 0x6742
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    671e:	0f 4b       	mov	r11,	r15	
    6720:	3f 52       	add	#8,	r15	;r2 As==11
    6722:	b0 12 84 63 	call	#0x6384	
    6726:	1f 93       	cmp	#1,	r15	;r3 As==01
    6728:	0c 20       	jnz	$+26     	;abs 0x6742
				{
					portYIELD_WITHIN_API();
    672a:	b0 12 92 6d 	call	#0x6d92	
    672e:	09 3c       	jmp	$+20     	;abs 0x6742
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    6730:	0f 4b       	mov	r11,	r15	
    6732:	3f 52       	add	#8,	r15	;r2 As==11
    6734:	b0 12 6e 64 	call	#0x646e	
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    6738:	0f 4b       	mov	r11,	r15	
    673a:	3f 50 12 00 	add	#18,	r15	;#0x0012
    673e:	b0 12 6e 64 	call	#0x646e	
		}
	}
	taskEXIT_CRITICAL();
    6742:	1f 42 02 1c 	mov	&0x1c02,r15	
    6746:	0f 93       	tst	r15		
    6748:	0a 24       	jz	$+22     	;abs 0x675e
    674a:	1f 42 02 1c 	mov	&0x1c02,r15	
    674e:	3f 53       	add	#-1,	r15	;r3 As==11
    6750:	82 4f 02 1c 	mov	r15,	&0x1c02	
    6754:	1f 42 02 1c 	mov	&0x1c02,r15	
    6758:	0f 93       	tst	r15		
    675a:	01 20       	jnz	$+4      	;abs 0x675e
    675c:	32 d2       	eint			

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    675e:	1f 43       	mov	#1,	r15	;r3 As==01
    6760:	1a 17       	popm	#2,	r11	
    6762:	30 41       	ret			

00006764 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    6764:	2b 15       	pushm	#3,	r11	
    6766:	0a 4f       	mov	r15,	r10	
    6768:	09 4e       	mov	r14,	r9	
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    676a:	0f 93       	tst	r15		
    676c:	27 24       	jz	$+80     	;abs 0x67bc
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    676e:	3f 40 26 00 	mov	#38,	r15	;#0x0026
    6772:	b0 12 70 6c 	call	#0x6c70	
    6776:	0b 4f       	mov	r15,	r11	
		if( pxNewQueue != NULL )
    6778:	0f 93       	tst	r15		
    677a:	22 24       	jz	$+70     	;abs 0x67c0
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    677c:	02 12       	push	r2		
    677e:	32 c2       	dint			
    6780:	03 43       	nop			
    6782:	82 49 c2 04 	mov	r9,	&0x04c2	
    6786:	82 4a c8 04 	mov	r10,	&0x04c8	
    678a:	1f 42 ca 04 	mov	&0x04ca,r15	
    678e:	32 41       	pop	r2		

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    6790:	1f 53       	inc	r15		
    6792:	b0 12 70 6c 	call	#0x6c70	
    6796:	8b 4f 00 00 	mov	r15,	0(r11)	;0x0000(r11)
			if( pxNewQueue->pcHead != NULL )
    679a:	0f 93       	tst	r15		
    679c:	0a 24       	jz	$+22     	;abs 0x67b2
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    679e:	8b 4a 1e 00 	mov	r10,	30(r11)	;0x001e(r11)
				pxNewQueue->uxItemSize = uxItemSize;
    67a2:	8b 49 20 00 	mov	r9,	32(r11)	;0x0020(r11)
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    67a6:	1e 43       	mov	#1,	r14	;r3 As==01
    67a8:	0f 4b       	mov	r11,	r15	
    67aa:	b0 12 b2 66 	call	#0x66b2	
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    67ae:	0f 4b       	mov	r11,	r15	
    67b0:	08 3c       	jmp	$+18     	;abs 0x67c2
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    67b2:	0f 4b       	mov	r11,	r15	
    67b4:	b0 12 c0 6c 	call	#0x6cc0	

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    67b8:	0f 43       	clr	r15		
    67ba:	03 3c       	jmp	$+8      	;abs 0x67c2
    67bc:	0f 43       	clr	r15		
    67be:	01 3c       	jmp	$+4      	;abs 0x67c2
    67c0:	0f 43       	clr	r15		
	}

	configASSERT( xReturn );

	return xReturn;
}
    67c2:	29 17       	popm	#3,	r11	
    67c4:	30 41       	ret			

000067c6 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    67c6:	7b 15       	pushm	#8,	r11	
    67c8:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    67cc:	0b 4f       	mov	r15,	r11	
    67ce:	04 4e       	mov	r14,	r4	
    67d0:	81 4d 04 00 	mov	r13,	4(r1)	;0x0004(r1)
    67d4:	06 4c       	mov	r12,	r6	
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    67d6:	07 43       	clr	r7		
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    67d8:	05 4f       	mov	r15,	r5	
    67da:	35 52       	add	#8,	r5	;r2 As==11
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    67dc:	32 c2       	dint			
    67de:	03 43       	nop			
    67e0:	1a 42 02 1c 	mov	&0x1c02,r10	
    67e4:	1a 53       	inc	r10		
    67e6:	82 4a 02 1c 	mov	r10,	&0x1c02	
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    67ea:	1a 4b 1c 00 	mov	28(r11),r10	;0x001c(r11)
    67ee:	1a 9b 1e 00 	cmp	30(r11),r10	;0x001e(r11)
    67f2:	02 28       	jnc	$+6      	;abs 0x67f8
    67f4:	26 93       	cmp	#2,	r6	;r3 As==10
    67f6:	21 20       	jnz	$+68     	;abs 0x683a
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    67f8:	0d 46       	mov	r6,	r13	
    67fa:	0e 44       	mov	r4,	r14	
    67fc:	0f 4b       	mov	r11,	r15	
    67fe:	b0 12 54 65 	call	#0x6554	
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    6802:	8b 93 12 00 	tst	18(r11)	;0x0012(r11)
    6806:	09 24       	jz	$+20     	;abs 0x681a
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    6808:	0f 4b       	mov	r11,	r15	
    680a:	3f 50 12 00 	add	#18,	r15	;#0x0012
    680e:	b0 12 84 63 	call	#0x6384	
    6812:	1f 93       	cmp	#1,	r15	;r3 As==01
    6814:	02 20       	jnz	$+6      	;abs 0x681a
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							portYIELD_WITHIN_API();
    6816:	b0 12 92 6d 	call	#0x6d92	
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    681a:	1f 42 02 1c 	mov	&0x1c02,r15	
    681e:	0f 93       	tst	r15		
    6820:	93 24       	jz	$+296    	;abs 0x6948
    6822:	1f 42 02 1c 	mov	&0x1c02,r15	
    6826:	3f 53       	add	#-1,	r15	;r3 As==11
    6828:	82 4f 02 1c 	mov	r15,	&0x1c02	
    682c:	1f 42 02 1c 	mov	&0x1c02,r15	
    6830:	0f 93       	tst	r15		
    6832:	8c 20       	jnz	$+282    	;abs 0x694c
    6834:	32 d2       	eint			

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    6836:	1f 43       	mov	#1,	r15	;r3 As==01
    6838:	8e 3c       	jmp	$+286    	;abs 0x6956
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    683a:	81 93 04 00 	tst	4(r1)		;0x0004(r1)
    683e:	0f 20       	jnz	$+32     	;abs 0x685e
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    6840:	1f 42 02 1c 	mov	&0x1c02,r15	
    6844:	0f 93       	tst	r15		
    6846:	84 24       	jz	$+266    	;abs 0x6950
    6848:	1f 42 02 1c 	mov	&0x1c02,r15	
    684c:	3f 53       	add	#-1,	r15	;r3 As==11
    684e:	82 4f 02 1c 	mov	r15,	&0x1c02	
    6852:	1f 42 02 1c 	mov	&0x1c02,r15	
    6856:	0f 93       	tst	r15		
    6858:	7d 20       	jnz	$+252    	;abs 0x6954
    685a:	32 d2       	eint			
    685c:	7c 3c       	jmp	$+250    	;abs 0x6956
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    685e:	07 93       	tst	r7		
    6860:	04 20       	jnz	$+10     	;abs 0x686a
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    6862:	0f 41       	mov	r1,	r15	
    6864:	b0 12 f0 63 	call	#0x63f0	
					xEntryTimeSet = pdTRUE;
    6868:	17 43       	mov	#1,	r7	;r3 As==01
				{
					/* Entry time was already set. */					
				}
			}
		}
		taskEXIT_CRITICAL();
    686a:	1a 42 02 1c 	mov	&0x1c02,r10	
    686e:	0a 93       	tst	r10		
    6870:	0a 24       	jz	$+22     	;abs 0x6886
    6872:	1d 42 02 1c 	mov	&0x1c02,r13	
    6876:	3d 53       	add	#-1,	r13	;r3 As==11
    6878:	82 4d 02 1c 	mov	r13,	&0x1c02	
    687c:	1d 42 02 1c 	mov	&0x1c02,r13	
    6880:	0d 93       	tst	r13		
    6882:	01 20       	jnz	$+4      	;abs 0x6886
    6884:	32 d2       	eint			

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    6886:	b0 12 7e 5f 	call	#0x5f7e	
		prvLockQueue( pxQueue );
    688a:	32 c2       	dint			
    688c:	03 43       	nop			
    688e:	1a 42 02 1c 	mov	&0x1c02,r10	
    6892:	1a 53       	inc	r10		
    6894:	82 4a 02 1c 	mov	r10,	&0x1c02	
    6898:	1a 4b 22 00 	mov	34(r11),r10	;0x0022(r11)
    689c:	3a 93       	cmp	#-1,	r10	;r3 As==11
    689e:	02 20       	jnz	$+6      	;abs 0x68a4
    68a0:	8b 43 22 00 	mov	#0,	34(r11)	;r3 As==00, 0x0022(r11)
    68a4:	1a 4b 24 00 	mov	36(r11),r10	;0x0024(r11)
    68a8:	3a 93       	cmp	#-1,	r10	;r3 As==11
    68aa:	02 20       	jnz	$+6      	;abs 0x68b0
    68ac:	8b 43 24 00 	mov	#0,	36(r11)	;r3 As==00, 0x0024(r11)
    68b0:	1a 42 02 1c 	mov	&0x1c02,r10	
    68b4:	0a 93       	tst	r10		
    68b6:	0a 24       	jz	$+22     	;abs 0x68cc
    68b8:	1d 42 02 1c 	mov	&0x1c02,r13	
    68bc:	3d 53       	add	#-1,	r13	;r3 As==11
    68be:	82 4d 02 1c 	mov	r13,	&0x1c02	
    68c2:	1d 42 02 1c 	mov	&0x1c02,r13	
    68c6:	0d 93       	tst	r13		
    68c8:	01 20       	jnz	$+4      	;abs 0x68cc
    68ca:	32 d2       	eint			

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    68cc:	0e 41       	mov	r1,	r14	
    68ce:	2e 52       	add	#4,	r14	;r2 As==10
    68d0:	0f 41       	mov	r1,	r15	
    68d2:	b0 12 02 64 	call	#0x6402	
    68d6:	0f 93       	tst	r15		
    68d8:	30 20       	jnz	$+98     	;abs 0x693a

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    68da:	32 c2       	dint			
    68dc:	03 43       	nop			
    68de:	1a 42 02 1c 	mov	&0x1c02,r10	
    68e2:	1a 53       	inc	r10		
    68e4:	82 4a 02 1c 	mov	r10,	&0x1c02	
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    68e8:	19 4b 1c 00 	mov	28(r11),r9	;0x001c(r11)
    68ec:	1a 4b 1e 00 	mov	30(r11),r10	;0x001e(r11)
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    68f0:	18 42 02 1c 	mov	&0x1c02,r8	
    68f4:	08 93       	tst	r8		
    68f6:	0a 24       	jz	$+22     	;abs 0x690c
    68f8:	18 42 02 1c 	mov	&0x1c02,r8	
    68fc:	38 53       	add	#-1,	r8	;r3 As==11
    68fe:	82 48 02 1c 	mov	r8,	&0x1c02	
    6902:	18 42 02 1c 	mov	&0x1c02,r8	
    6906:	08 93       	tst	r8		
    6908:	01 20       	jnz	$+4      	;abs 0x690c
    690a:	32 d2       	eint			
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    690c:	09 9a       	cmp	r10,	r9	
    690e:	0f 20       	jnz	$+32     	;abs 0x692e
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    6910:	1e 41 04 00 	mov	4(r1),	r14	;0x0004(r1)
    6914:	0f 45       	mov	r5,	r15	
    6916:	b0 12 5a 63 	call	#0x635a	
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    691a:	0f 4b       	mov	r11,	r15	
    691c:	b0 12 d4 65 	call	#0x65d4	
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    6920:	b0 12 d8 60 	call	#0x60d8	
    6924:	0f 93       	tst	r15		
    6926:	5a 23       	jnz	$-330    	;abs 0x67dc
				{
					portYIELD_WITHIN_API();
    6928:	b0 12 92 6d 	call	#0x6d92	
    692c:	57 3f       	jmp	$-336    	;abs 0x67dc
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    692e:	0f 4b       	mov	r11,	r15	
    6930:	b0 12 d4 65 	call	#0x65d4	
				( void ) xTaskResumeAll();
    6934:	b0 12 d8 60 	call	#0x60d8	
    6938:	51 3f       	jmp	$-348    	;abs 0x67dc
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    693a:	0f 4b       	mov	r11,	r15	
    693c:	b0 12 d4 65 	call	#0x65d4	
			( void ) xTaskResumeAll();
    6940:	b0 12 d8 60 	call	#0x60d8	

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    6944:	0f 43       	clr	r15		
    6946:	07 3c       	jmp	$+16     	;abs 0x6956

				taskEXIT_CRITICAL();

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    6948:	1f 43       	mov	#1,	r15	;r3 As==01
    694a:	05 3c       	jmp	$+12     	;abs 0x6956
    694c:	1f 43       	mov	#1,	r15	;r3 As==01
    694e:	03 3c       	jmp	$+8      	;abs 0x6956
					taskEXIT_CRITICAL();

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    6950:	0f 43       	clr	r15		
    6952:	01 3c       	jmp	$+4      	;abs 0x6956
    6954:	0f 43       	clr	r15		
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    6956:	31 50 06 00 	add	#6,	r1	;#0x0006
    695a:	74 17       	popm	#8,	r11	
    695c:	30 41       	ret			

0000695e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    695e:	1b 15       	pushm	#2,	r11	
    6960:	0b 4f       	mov	r15,	r11	
    6962:	0a 4d       	mov	r13,	r10	
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    6964:	1f 4f 1c 00 	mov	28(r15),r15	;0x001c(r15)
    6968:	1f 9b 1e 00 	cmp	30(r11),r15	;0x001e(r11)
    696c:	02 28       	jnc	$+6      	;abs 0x6972
    696e:	2c 93       	cmp	#2,	r12	;r3 As==10
    6970:	1f 20       	jnz	$+64     	;abs 0x69b0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    6972:	0d 4c       	mov	r12,	r13	
    6974:	0f 4b       	mov	r11,	r15	
    6976:	b0 12 54 65 	call	#0x6554	

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    697a:	1f 4b 24 00 	mov	36(r11),r15	;0x0024(r11)
    697e:	3f 93       	cmp	#-1,	r15	;r3 As==11
    6980:	10 20       	jnz	$+34     	;abs 0x69a2
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    6982:	8b 93 12 00 	tst	18(r11)	;0x0012(r11)
    6986:	16 24       	jz	$+46     	;abs 0x69b4
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    6988:	0f 4b       	mov	r11,	r15	
    698a:	3f 50 12 00 	add	#18,	r15	;#0x0012
    698e:	b0 12 84 63 	call	#0x6384	
    6992:	0f 93       	tst	r15		
    6994:	11 24       	jz	$+36     	;abs 0x69b8
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    6996:	0a 93       	tst	r10		
    6998:	11 24       	jz	$+36     	;abs 0x69bc
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    699a:	9a 43 00 00 	mov	#1,	0(r10)	;r3 As==01, 0x0000(r10)
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    699e:	1f 43       	mov	#1,	r15	;r3 As==01
    69a0:	0e 3c       	jmp	$+30     	;abs 0x69be
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    69a2:	1f 4b 24 00 	mov	36(r11),r15	;0x0024(r11)
    69a6:	1f 53       	inc	r15		
    69a8:	8b 4f 24 00 	mov	r15,	36(r11)	;0x0024(r11)
			}

			xReturn = pdPASS;
    69ac:	1f 43       	mov	#1,	r15	;r3 As==01
    69ae:	07 3c       	jmp	$+16     	;abs 0x69be
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    69b0:	0f 43       	clr	r15		
    69b2:	05 3c       	jmp	$+12     	;abs 0x69be
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    69b4:	1f 43       	mov	#1,	r15	;r3 As==01
    69b6:	03 3c       	jmp	$+8      	;abs 0x69be
    69b8:	1f 43       	mov	#1,	r15	;r3 As==01
    69ba:	01 3c       	jmp	$+4      	;abs 0x69be
    69bc:	1f 43       	mov	#1,	r15	;r3 As==01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    69be:	1a 17       	popm	#2,	r11	
    69c0:	30 41       	ret			

000069c2 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, const void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    69c2:	5b 15       	pushm	#6,	r11	
    69c4:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    69c8:	0b 4f       	mov	r15,	r11	
    69ca:	06 4e       	mov	r14,	r6	
    69cc:	81 4d 04 00 	mov	r13,	4(r1)	;0x0004(r1)
    69d0:	07 4c       	mov	r12,	r7	
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    69d2:	09 43       	clr	r9		
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    69d4:	08 4f       	mov	r15,	r8	
    69d6:	38 50 12 00 	add	#18,	r8	;#0x0012
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    69da:	32 c2       	dint			
    69dc:	03 43       	nop			
    69de:	1d 42 02 1c 	mov	&0x1c02,r13	
    69e2:	1d 53       	inc	r13		
    69e4:	82 4d 02 1c 	mov	r13,	&0x1c02	
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    69e8:	1d 4b 1c 00 	mov	28(r11),r13	;0x001c(r11)
    69ec:	0d 93       	tst	r13		
    69ee:	37 24       	jz	$+112    	;abs 0x6a5e
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    69f0:	1a 4b 06 00 	mov	6(r11),	r10	;0x0006(r11)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    69f4:	0e 46       	mov	r6,	r14	
    69f6:	0f 4b       	mov	r11,	r15	
    69f8:	b0 12 24 65 	call	#0x6524	

				if( xJustPeeking == pdFALSE )
    69fc:	07 93       	tst	r7		
    69fe:	11 20       	jnz	$+36     	;abs 0x6a22
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    6a00:	1f 4b 1c 00 	mov	28(r11),r15	;0x001c(r11)
    6a04:	3f 53       	add	#-1,	r15	;r3 As==11
    6a06:	8b 4f 1c 00 	mov	r15,	28(r11)	;0x001c(r11)
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    6a0a:	8b 93 08 00 	tst	8(r11)		;0x0008(r11)
    6a0e:	17 24       	jz	$+48     	;abs 0x6a3e
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    6a10:	0f 4b       	mov	r11,	r15	
    6a12:	3f 52       	add	#8,	r15	;r2 As==11
    6a14:	b0 12 84 63 	call	#0x6384	
    6a18:	1f 93       	cmp	#1,	r15	;r3 As==01
    6a1a:	11 20       	jnz	$+36     	;abs 0x6a3e
						{
							portYIELD_WITHIN_API();
    6a1c:	b0 12 92 6d 	call	#0x6d92	
    6a20:	0e 3c       	jmp	$+30     	;abs 0x6a3e
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    6a22:	8b 4a 06 00 	mov	r10,	6(r11)	;0x0006(r11)

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    6a26:	8b 93 12 00 	tst	18(r11)	;0x0012(r11)
    6a2a:	09 24       	jz	$+20     	;abs 0x6a3e
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    6a2c:	0f 4b       	mov	r11,	r15	
    6a2e:	3f 50 12 00 	add	#18,	r15	;#0x0012
    6a32:	b0 12 84 63 	call	#0x6384	
    6a36:	0f 93       	tst	r15		
    6a38:	02 24       	jz	$+6      	;abs 0x6a3e
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    6a3a:	b0 12 92 6d 	call	#0x6d92	
						}
					}
				}

				taskEXIT_CRITICAL();
    6a3e:	1f 42 02 1c 	mov	&0x1c02,r15	
    6a42:	0f 93       	tst	r15		
    6a44:	91 24       	jz	$+292    	;abs 0x6b68
    6a46:	1f 42 02 1c 	mov	&0x1c02,r15	
    6a4a:	3f 53       	add	#-1,	r15	;r3 As==11
    6a4c:	82 4f 02 1c 	mov	r15,	&0x1c02	
    6a50:	1f 42 02 1c 	mov	&0x1c02,r15	
    6a54:	0f 93       	tst	r15		
    6a56:	8a 20       	jnz	$+278    	;abs 0x6b6c
    6a58:	32 d2       	eint			
				return pdPASS;
    6a5a:	1f 43       	mov	#1,	r15	;r3 As==01
    6a5c:	8c 3c       	jmp	$+282    	;abs 0x6b76
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    6a5e:	81 93 04 00 	tst	4(r1)		;0x0004(r1)
    6a62:	0f 20       	jnz	$+32     	;abs 0x6a82
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    6a64:	1f 42 02 1c 	mov	&0x1c02,r15	
    6a68:	0f 93       	tst	r15		
    6a6a:	82 24       	jz	$+262    	;abs 0x6b70
    6a6c:	1f 42 02 1c 	mov	&0x1c02,r15	
    6a70:	3f 53       	add	#-1,	r15	;r3 As==11
    6a72:	82 4f 02 1c 	mov	r15,	&0x1c02	
    6a76:	1f 42 02 1c 	mov	&0x1c02,r15	
    6a7a:	0f 93       	tst	r15		
    6a7c:	7b 20       	jnz	$+248    	;abs 0x6b74
    6a7e:	32 d2       	eint			
    6a80:	7a 3c       	jmp	$+246    	;abs 0x6b76
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    6a82:	09 93       	tst	r9		
    6a84:	04 20       	jnz	$+10     	;abs 0x6a8e
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    6a86:	0f 41       	mov	r1,	r15	
    6a88:	b0 12 f0 63 	call	#0x63f0	
					xEntryTimeSet = pdTRUE;
    6a8c:	19 43       	mov	#1,	r9	;r3 As==01
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
    6a8e:	1d 42 02 1c 	mov	&0x1c02,r13	
    6a92:	0d 93       	tst	r13		
    6a94:	0a 24       	jz	$+22     	;abs 0x6aaa
    6a96:	1d 42 02 1c 	mov	&0x1c02,r13	
    6a9a:	3d 53       	add	#-1,	r13	;r3 As==11
    6a9c:	82 4d 02 1c 	mov	r13,	&0x1c02	
    6aa0:	1d 42 02 1c 	mov	&0x1c02,r13	
    6aa4:	0d 93       	tst	r13		
    6aa6:	01 20       	jnz	$+4      	;abs 0x6aaa
    6aa8:	32 d2       	eint			

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    6aaa:	b0 12 7e 5f 	call	#0x5f7e	
		prvLockQueue( pxQueue );
    6aae:	32 c2       	dint			
    6ab0:	03 43       	nop			
    6ab2:	1d 42 02 1c 	mov	&0x1c02,r13	
    6ab6:	1d 53       	inc	r13		
    6ab8:	82 4d 02 1c 	mov	r13,	&0x1c02	
    6abc:	1d 4b 22 00 	mov	34(r11),r13	;0x0022(r11)
    6ac0:	3d 93       	cmp	#-1,	r13	;r3 As==11
    6ac2:	02 20       	jnz	$+6      	;abs 0x6ac8
    6ac4:	8b 43 22 00 	mov	#0,	34(r11)	;r3 As==00, 0x0022(r11)
    6ac8:	1d 4b 24 00 	mov	36(r11),r13	;0x0024(r11)
    6acc:	3d 93       	cmp	#-1,	r13	;r3 As==11
    6ace:	02 20       	jnz	$+6      	;abs 0x6ad4
    6ad0:	8b 43 24 00 	mov	#0,	36(r11)	;r3 As==00, 0x0024(r11)
    6ad4:	1d 42 02 1c 	mov	&0x1c02,r13	
    6ad8:	0d 93       	tst	r13		
    6ada:	0a 24       	jz	$+22     	;abs 0x6af0
    6adc:	1d 42 02 1c 	mov	&0x1c02,r13	
    6ae0:	3d 53       	add	#-1,	r13	;r3 As==11
    6ae2:	82 4d 02 1c 	mov	r13,	&0x1c02	
    6ae6:	1d 42 02 1c 	mov	&0x1c02,r13	
    6aea:	0d 93       	tst	r13		
    6aec:	01 20       	jnz	$+4      	;abs 0x6af0
    6aee:	32 d2       	eint			

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    6af0:	0e 41       	mov	r1,	r14	
    6af2:	2e 52       	add	#4,	r14	;r2 As==10
    6af4:	0f 41       	mov	r1,	r15	
    6af6:	b0 12 02 64 	call	#0x6402	
    6afa:	0f 93       	tst	r15		
    6afc:	2e 20       	jnz	$+94     	;abs 0x6b5a

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    6afe:	32 c2       	dint			
    6b00:	03 43       	nop			
    6b02:	1d 42 02 1c 	mov	&0x1c02,r13	
    6b06:	1d 53       	inc	r13		
    6b08:	82 4d 02 1c 	mov	r13,	&0x1c02	
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
    6b0c:	1d 4b 1c 00 	mov	28(r11),r13	;0x001c(r11)
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    6b10:	1a 42 02 1c 	mov	&0x1c02,r10	
    6b14:	0a 93       	tst	r10		
    6b16:	0a 24       	jz	$+22     	;abs 0x6b2c
    6b18:	1a 42 02 1c 	mov	&0x1c02,r10	
    6b1c:	3a 53       	add	#-1,	r10	;r3 As==11
    6b1e:	82 4a 02 1c 	mov	r10,	&0x1c02	
    6b22:	1a 42 02 1c 	mov	&0x1c02,r10	
    6b26:	0a 93       	tst	r10		
    6b28:	01 20       	jnz	$+4      	;abs 0x6b2c
    6b2a:	32 d2       	eint			
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    6b2c:	0d 93       	tst	r13		
    6b2e:	0f 20       	jnz	$+32     	;abs 0x6b4e
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    6b30:	1e 41 04 00 	mov	4(r1),	r14	;0x0004(r1)
    6b34:	0f 48       	mov	r8,	r15	
    6b36:	b0 12 5a 63 	call	#0x635a	
				prvUnlockQueue( pxQueue );
    6b3a:	0f 4b       	mov	r11,	r15	
    6b3c:	b0 12 d4 65 	call	#0x65d4	
				if( xTaskResumeAll() == pdFALSE )
    6b40:	b0 12 d8 60 	call	#0x60d8	
    6b44:	0f 93       	tst	r15		
    6b46:	49 23       	jnz	$-364    	;abs 0x69da
				{
					portYIELD_WITHIN_API();
    6b48:	b0 12 92 6d 	call	#0x6d92	
    6b4c:	46 3f       	jmp	$-370    	;abs 0x69da
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    6b4e:	0f 4b       	mov	r11,	r15	
    6b50:	b0 12 d4 65 	call	#0x65d4	
				( void ) xTaskResumeAll();
    6b54:	b0 12 d8 60 	call	#0x60d8	
    6b58:	40 3f       	jmp	$-382    	;abs 0x69da
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    6b5a:	0f 4b       	mov	r11,	r15	
    6b5c:	b0 12 d4 65 	call	#0x65d4	
			( void ) xTaskResumeAll();
    6b60:	b0 12 d8 60 	call	#0x60d8	
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    6b64:	0f 43       	clr	r15		
    6b66:	07 3c       	jmp	$+16     	;abs 0x6b76
						}
					}
				}

				taskEXIT_CRITICAL();
				return pdPASS;
    6b68:	1f 43       	mov	#1,	r15	;r3 As==01
    6b6a:	05 3c       	jmp	$+12     	;abs 0x6b76
    6b6c:	1f 43       	mov	#1,	r15	;r3 As==01
    6b6e:	03 3c       	jmp	$+8      	;abs 0x6b76
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    6b70:	0f 43       	clr	r15		
    6b72:	01 3c       	jmp	$+4      	;abs 0x6b76
    6b74:	0f 43       	clr	r15		
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    6b76:	31 50 06 00 	add	#6,	r1	;#0x0006
    6b7a:	56 17       	popm	#6,	r11	
    6b7c:	30 41       	ret			

00006b7e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, const void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    6b7e:	1b 15       	pushm	#2,	r11	
    6b80:	0b 4f       	mov	r15,	r11	
    6b82:	0a 4d       	mov	r13,	r10	
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    6b84:	1f 4f 1c 00 	mov	28(r15),r15	;0x001c(r15)
    6b88:	0f 93       	tst	r15		
    6b8a:	22 24       	jz	$+70     	;abs 0x6bd0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    6b8c:	0f 4b       	mov	r11,	r15	
    6b8e:	b0 12 24 65 	call	#0x6524	
			--( pxQueue->uxMessagesWaiting );
    6b92:	1f 4b 1c 00 	mov	28(r11),r15	;0x001c(r11)
    6b96:	3f 53       	add	#-1,	r15	;r3 As==11
    6b98:	8b 4f 1c 00 	mov	r15,	28(r11)	;0x001c(r11)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    6b9c:	1f 4b 22 00 	mov	34(r11),r15	;0x0022(r11)
    6ba0:	3f 93       	cmp	#-1,	r15	;r3 As==11
    6ba2:	0f 20       	jnz	$+32     	;abs 0x6bc2
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    6ba4:	8b 93 08 00 	tst	8(r11)		;0x0008(r11)
    6ba8:	15 24       	jz	$+44     	;abs 0x6bd4
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    6baa:	0f 4b       	mov	r11,	r15	
    6bac:	3f 52       	add	#8,	r15	;r2 As==11
    6bae:	b0 12 84 63 	call	#0x6384	
    6bb2:	0f 93       	tst	r15		
    6bb4:	11 24       	jz	$+36     	;abs 0x6bd8
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    6bb6:	0a 93       	tst	r10		
    6bb8:	11 24       	jz	$+36     	;abs 0x6bdc
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    6bba:	9a 43 00 00 	mov	#1,	0(r10)	;r3 As==01, 0x0000(r10)
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    6bbe:	1f 43       	mov	#1,	r15	;r3 As==01
    6bc0:	0e 3c       	jmp	$+30     	;abs 0x6bde
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    6bc2:	1f 4b 22 00 	mov	34(r11),r15	;0x0022(r11)
    6bc6:	1f 53       	inc	r15		
    6bc8:	8b 4f 22 00 	mov	r15,	34(r11)	;0x0022(r11)
			}

			xReturn = pdPASS;
    6bcc:	1f 43       	mov	#1,	r15	;r3 As==01
    6bce:	07 3c       	jmp	$+16     	;abs 0x6bde
		}
		else
		{
			xReturn = pdFAIL;
    6bd0:	0f 43       	clr	r15		
    6bd2:	05 3c       	jmp	$+12     	;abs 0x6bde
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    6bd4:	1f 43       	mov	#1,	r15	;r3 As==01
    6bd6:	03 3c       	jmp	$+8      	;abs 0x6bde
    6bd8:	1f 43       	mov	#1,	r15	;r3 As==01
    6bda:	01 3c       	jmp	$+4      	;abs 0x6bde
    6bdc:	1f 43       	mov	#1,	r15	;r3 As==01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    6bde:	1a 17       	popm	#2,	r11	
    6be0:	30 41       	ret			

00006be2 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue, const void * const pvBuffer )
{
    6be2:	1b 15       	pushm	#2,	r11	
    6be4:	0b 4f       	mov	r15,	r11	
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    6be6:	1f 4f 1c 00 	mov	28(r15),r15	;0x001c(r15)
    6bea:	0f 93       	tst	r15		
    6bec:	09 24       	jz	$+20     	;abs 0x6c00
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    6bee:	1a 4b 06 00 	mov	6(r11),	r10	;0x0006(r11)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    6bf2:	0f 4b       	mov	r11,	r15	
    6bf4:	b0 12 24 65 	call	#0x6524	
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    6bf8:	8b 4a 06 00 	mov	r10,	6(r11)	;0x0006(r11)

			xReturn = pdPASS;
    6bfc:	1f 43       	mov	#1,	r15	;r3 As==01
    6bfe:	01 3c       	jmp	$+4      	;abs 0x6c02
		}
		else
		{
			xReturn = pdFAIL;
    6c00:	0f 43       	clr	r15		
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    6c02:	1a 17       	popm	#2,	r11	
    6c04:	30 41       	ret			

00006c06 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    6c06:	32 c2       	dint			
    6c08:	03 43       	nop			
    6c0a:	1e 42 02 1c 	mov	&0x1c02,r14	
    6c0e:	1e 53       	inc	r14		
    6c10:	82 4e 02 1c 	mov	r14,	&0x1c02	
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    6c14:	1f 4f 1c 00 	mov	28(r15),r15	;0x001c(r15)
	taskEXIT_CRITICAL();
    6c18:	1e 42 02 1c 	mov	&0x1c02,r14	
    6c1c:	0e 93       	tst	r14		
    6c1e:	0a 24       	jz	$+22     	;abs 0x6c34
    6c20:	1e 42 02 1c 	mov	&0x1c02,r14	
    6c24:	3e 53       	add	#-1,	r14	;r3 As==11
    6c26:	82 4e 02 1c 	mov	r14,	&0x1c02	
    6c2a:	1e 42 02 1c 	mov	&0x1c02,r14	
    6c2e:	0e 93       	tst	r14		
    6c30:	01 20       	jnz	$+4      	;abs 0x6c34
    6c32:	32 d2       	eint			

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    6c34:	30 41       	ret			

00006c36 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    6c36:	1f 4f 1c 00 	mov	28(r15),r15	;0x001c(r15)

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    6c3a:	30 41       	ret			

00006c3c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
    6c3c:	0b 12       	push	r11		
    6c3e:	0b 4f       	mov	r15,	r11	
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
    6c40:	2f 4f       	mov	@r15,	r15	
    6c42:	b0 12 c0 6c 	call	#0x6cc0	
	vPortFree( pxQueue );
    6c46:	0f 4b       	mov	r11,	r15	
    6c48:	b0 12 c0 6c 	call	#0x6cc0	
}
    6c4c:	3b 41       	pop	r11		
    6c4e:	30 41       	ret			

00006c50 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
    6c50:	1e 4f 1c 00 	mov	28(r15),r14	;0x001c(r15)
	{
		xReturn = pdTRUE;
    6c54:	1f 43       	mov	#1,	r15	;r3 As==01
    6c56:	0e 93       	tst	r14		
    6c58:	01 24       	jz	$+4      	;abs 0x6c5c
    6c5a:	0f 43       	clr	r15		
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    6c5c:	30 41       	ret			

00006c5e <xQueueIsQueueFullFromISR>:
signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
    6c5e:	1d 4f 1c 00 	mov	28(r15),r13	;0x001c(r15)
	{
		xReturn = pdTRUE;
    6c62:	1e 43       	mov	#1,	r14	;r3 As==01
    6c64:	1d 9f 1e 00 	cmp	30(r15),r13	;0x001e(r15)
    6c68:	01 24       	jz	$+4      	;abs 0x6c6c
    6c6a:	0e 43       	clr	r14		
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    6c6c:	0f 4e       	mov	r14,	r15	
    6c6e:	30 41       	ret			

00006c70 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    6c70:	1b 15       	pushm	#2,	r11	
    6c72:	0b 4f       	mov	r15,	r11	
void *pvReturn = NULL;
static unsigned char *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
    6c74:	1f f3       	and	#1,	r15	;r3 As==01
    6c76:	03 24       	jz	$+8      	;abs 0x6c7e
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    6c78:	3b f0 fe ff 	and	#-2,	r11	;#0xfffe
    6c7c:	2b 53       	incd	r11		
		}
	#endif

	vTaskSuspendAll();
    6c7e:	b0 12 7e 5f 	call	#0x5f7e	
	{
		if( pucAlignedHeap == NULL )
    6c82:	82 93 72 1c 	tst	&0x1c72	
    6c86:	06 20       	jnz	$+14     	;abs 0x6c94
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    6c88:	3f 40 76 1c 	mov	#7286,	r15	;#0x1c76
    6c8c:	3f f0 fe ff 	and	#-2,	r15	;#0xfffe
    6c90:	82 4f 72 1c 	mov	r15,	&0x1c72	
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    6c94:	1f 42 7c 23 	mov	&0x237c,r15	
    6c98:	0b 5f       	add	r15,	r11	
    6c9a:	3b 90 06 07 	cmp	#1798,	r11	;#0x0706
    6c9e:	08 2c       	jc	$+18     	;abs 0x6cb0
    6ca0:	0f 9b       	cmp	r11,	r15	
    6ca2:	08 2c       	jc	$+18     	;abs 0x6cb4
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    6ca4:	1a 42 72 1c 	mov	&0x1c72,r10	
    6ca8:	0a 5f       	add	r15,	r10	
			xNextFreeByte += xWantedSize;
    6caa:	82 4b 7c 23 	mov	r11,	&0x237c	
    6cae:	03 3c       	jmp	$+8      	;abs 0x6cb6

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    6cb0:	0a 43       	clr	r10		
    6cb2:	01 3c       	jmp	$+4      	;abs 0x6cb6
    6cb4:	0a 43       	clr	r10		
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
    6cb6:	b0 12 d8 60 	call	#0x60d8	
		}
	}
	#endif

	return pvReturn;
}
    6cba:	0f 4a       	mov	r10,	r15	
    6cbc:	1a 17       	popm	#2,	r11	
    6cbe:	30 41       	ret			

00006cc0 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    6cc0:	30 41       	ret			

00006cc2 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    6cc2:	82 43 7c 23 	mov	#0,	&0x237c	;r3 As==00
}
    6cc6:	30 41       	ret			

00006cc8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    6cc8:	3f 40 06 07 	mov	#1798,	r15	;#0x0706
    6ccc:	1f 82 7c 23 	sub	&0x237c,r15	
    6cd0:	30 41       	ret			

00006cd2 <pxPortInitialiseStack>:

	/* The msp430 automatically pushes the PC then SR onto the stack before 
	executing an ISR.  We want the stack to look just as if this has happened
	so place a pointer to the start of the task on the stack first - followed
	by the flags we want the task to use when it starts up. */
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;
    6cd2:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    6cd6:	bf 42 fe ff 	mov	#8,	-2(r15)	;r2 As==11, 0xfffe(r15)
	pxTopOfStack--;

	/* Next the general purpose registers. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x4444;
    6cda:	bf 40 44 44 	mov	#17476,	-4(r15)	;#0x4444, 0xfffc(r15)
    6cde:	fc ff 
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x5555;
    6ce0:	bf 40 55 55 	mov	#21845,	-6(r15)	;#0x5555, 0xfffa(r15)
    6ce4:	fa ff 
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x6666;
    6ce6:	bf 40 66 66 	mov	#26214,	-8(r15)	;#0x6666, 0xfff8(r15)
    6cea:	f8 ff 
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x7777;
    6cec:	bf 40 77 77 	mov	#30583,	-10(r15);#0x7777, 0xfff6(r15)
    6cf0:	f6 ff 
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x8888;
    6cf2:	bf 40 88 88 	mov	#-30584,-12(r15);#0x8888, 0xfff4(r15)
    6cf6:	f4 ff 
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x9999;
    6cf8:	bf 40 99 99 	mov	#-26215,-14(r15);#0x9999, 0xfff2(r15)
    6cfc:	f2 ff 
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0xaaaa;
    6cfe:	bf 40 aa aa 	mov	#-21846,-16(r15);#0xaaaa, 0xfff0(r15)
    6d02:	f0 ff 
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0xbbbb;
    6d04:	bf 40 bb bb 	mov	#-17477,-18(r15);#0xbbbb, 0xffee(r15)
    6d08:	ee ff 
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0xcccc;
    6d0a:	bf 40 cc cc 	mov	#-13108,-20(r15);#0xcccc, 0xffec(r15)
    6d0e:	ec ff 
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0xdddd;
    6d10:	bf 40 dd dd 	mov	#-8739,	-22(r15);#0xdddd, 0xffea(r15)
    6d14:	ea ff 
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0xeeee;
    6d16:	bf 40 ee ee 	mov	#-4370,	-24(r15);#0xeeee, 0xffe8(r15)
    6d1a:	e8 ff 
	pxTopOfStack--;

	/* When the task starts is will expect to find the function parameter in
	R15. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;
    6d1c:	8f 4d e6 ff 	mov	r13,	-26(r15);0xffe6(r15)
	/* The code generated by the mspgcc compiler does not maintain separate
	stack and frame pointers. The portENTER_CRITICAL macro cannot therefore
	use the stack as per other ports.  Instead a variable is used to keep
	track of the critical section nesting.  This variable has to be stored
	as part of the task context and is initially set to zero. */
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_SECTION_NESTING;	
    6d20:	8f 43 e4 ff 	mov	#0,	-28(r15);r3 As==00, 0xffe4(r15)

	/* Return a pointer to the top of the stack we have generated so this can
	be stored in the task control block for the task. */
	return pxTopOfStack;
}
    6d24:	3f 50 e4 ff 	add	#-28,	r15	;#0xffe4
    6d28:	30 41       	ret			

00006d2a <xPortStartScheduler>:
 * but could alternatively use the watchdog timer or timer 1. 
 */
static void prvSetupTimerInterrupt( void )
{
	/* Ensure the timer is stopped. */
	TA0CTL = 0;
    6d2a:	82 43 40 03 	mov	#0,	&0x0340	;r3 As==00

	/* Run the timer of the ACLK. */
	TA0CTL = TASSEL_1;
    6d2e:	b2 40 00 01 	mov	#256,	&0x0340	;#0x0100
    6d32:	40 03 

	/* Clear everything to start with. */
	TA0CTL |= TACLR;
    6d34:	1f 42 40 03 	mov	&0x0340,r15	
    6d38:	2f d2       	bis	#4,	r15	;r2 As==10
    6d3a:	82 4f 40 03 	mov	r15,	&0x0340	

	/* Set the compare match value according to the tick rate we want. */
	TA0CCR0 = portACLK_FREQUENCY_HZ / configTICK_RATE_HZ;
    6d3e:	b2 40 20 00 	mov	#32,	&0x0352	;#0x0020
    6d42:	52 03 

	/* Enable the interrupts. */
	TA0CCTL0 = CCIE;
    6d44:	b2 40 10 00 	mov	#16,	&0x0342	;#0x0010
    6d48:	42 03 

	/* Start up clean. */
	TA0CTL |= TACLR;
    6d4a:	1f 42 40 03 	mov	&0x0340,r15	
    6d4e:	2f d2       	bis	#4,	r15	;r2 As==10
    6d50:	82 4f 40 03 	mov	r15,	&0x0340	

	/* Up mode. */
	TA0CTL |= MC_1;
    6d54:	1f 42 40 03 	mov	&0x0340,r15	
    6d58:	3f d0 10 00 	bis	#16,	r15	;#0x0010
    6d5c:	82 4f 40 03 	mov	r15,	&0x0340	
	/* Setup the hardware to generate the tick.  Interrupts are disabled when
	this function is called. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    6d60:	1c 40 a6 ae 	mov	-20826(r0),r12	;PC rel. 0x1c08
    6d64:	21 4c       	mov	@r12,	r1	
    6d66:	3f 41       	pop	r15		
    6d68:	80 4f 98 ae 	mov	r15,	-20840(r0);PC rel. 0x1c02
    6d6c:	3f 41       	pop	r15		
    6d6e:	3e 41       	pop	r14		
    6d70:	3d 41       	pop	r13		
    6d72:	3c 41       	pop	r12		
    6d74:	3b 41       	pop	r11		
    6d76:	3a 41       	pop	r10		
    6d78:	39 41       	pop	r9		
    6d7a:	38 41       	pop	r8		
    6d7c:	37 41       	pop	r7		
    6d7e:	36 41       	pop	r6		
    6d80:	35 41       	pop	r5		
    6d82:	34 41       	pop	r4		
    6d84:	b1 c0 f0 00 	bic	#240,	0(r1)	;#0x00f0, 0x0000(r1)
    6d88:	00 00 
    6d8a:	00 13       	reti			

	/* Should not get here as the tasks are now running! */
	return pdTRUE;
}
    6d8c:	1f 43       	mov	#1,	r15	;r3 As==01
    6d8e:	30 41       	ret			

00006d90 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the MSP430 port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    6d90:	30 41       	ret			

00006d92 <vPortYield>:
{
	/* We want the stack of the task being saved to look exactly as if the task
	was saved during a pre-emptive RTOS tick ISR.  Before calling an ISR the 
	msp430 places the status register onto the stack.  As this is a function 
	call and not an ISR we have to do this manually. */
	asm volatile ( "push	r2" );
    6d92:	02 12       	push	r2		
	_DINT();
    6d94:	32 c2       	dint			
    6d96:	03 43       	nop			

	/* Save the context of the current task. */
	portSAVE_CONTEXT();
    6d98:	04 12       	push	r4		
    6d9a:	05 12       	push	r5		
    6d9c:	06 12       	push	r6		
    6d9e:	07 12       	push	r7		
    6da0:	08 12       	push	r8		
    6da2:	09 12       	push	r9		
    6da4:	0a 12       	push	r10		
    6da6:	0b 12       	push	r11		
    6da8:	0c 12       	push	r12		
    6daa:	0d 12       	push	r13		
    6dac:	0e 12       	push	r14		
    6dae:	0f 12       	push	r15		
    6db0:	1e 40 50 ae 	mov	-20912(r0),r14	;PC rel. 0x1c02
    6db4:	0e 12       	push	r14		
    6db6:	1c 40 50 ae 	mov	-20912(r0),r12	;PC rel. 0x1c08
    6dba:	8c 41 00 00 	mov	r1,	0(r12)	;0x0000(r12)

	/* Switch to the highest priority task that is ready to run. */
	vTaskSwitchContext();
    6dbe:	b0 12 e4 62 	call	#0x62e4	

	/* Restore the context of the new task. */
	portRESTORE_CONTEXT();
    6dc2:	1c 40 44 ae 	mov	-20924(r0),r12	;PC rel. 0x1c08
    6dc6:	21 4c       	mov	@r12,	r1	
    6dc8:	3f 41       	pop	r15		
    6dca:	80 4f 36 ae 	mov	r15,	-20938(r0);PC rel. 0x1c02
    6dce:	3f 41       	pop	r15		
    6dd0:	3e 41       	pop	r14		
    6dd2:	3d 41       	pop	r13		
    6dd4:	3c 41       	pop	r12		
    6dd6:	3b 41       	pop	r11		
    6dd8:	3a 41       	pop	r10		
    6dda:	39 41       	pop	r9		
    6ddc:	38 41       	pop	r8		
    6dde:	37 41       	pop	r7		
    6de0:	36 41       	pop	r6		
    6de2:	35 41       	pop	r5		
    6de4:	34 41       	pop	r4		
    6de6:	b1 c0 f0 00 	bic	#240,	0(r1)	;#0x00f0, 0x0000(r1)
    6dea:	00 00 
    6dec:	00 13       	reti			

00006dee <prvTickISR>:
	 */
	interrupt (TIMERA0_VECTOR) prvTickISR( void ) __attribute__ ( ( naked ) );
	interrupt (TIMERA0_VECTOR) prvTickISR( void )
	{
		/* Save the context of the interrupted task. */
		portSAVE_CONTEXT();
    6dee:	04 12       	push	r4		
    6df0:	05 12       	push	r5		
    6df2:	06 12       	push	r6		
    6df4:	07 12       	push	r7		
    6df6:	08 12       	push	r8		
    6df8:	09 12       	push	r9		
    6dfa:	0a 12       	push	r10		
    6dfc:	0b 12       	push	r11		
    6dfe:	0c 12       	push	r12		
    6e00:	0d 12       	push	r13		
    6e02:	0e 12       	push	r14		
    6e04:	0f 12       	push	r15		
    6e06:	1e 40 fa ad 	mov	-20998(r0),r14	;PC rel. 0x1c02
    6e0a:	0e 12       	push	r14		
    6e0c:	1c 40 fa ad 	mov	-20998(r0),r12	;PC rel. 0x1c08
    6e10:	8c 41 00 00 	mov	r1,	0(r12)	;0x0000(r12)

		/* Increment the tick count then switch to the highest priority task
		that is ready to run. */
		if( xTaskIncrementTick() != pdFALSE )
    6e14:	b0 12 c6 5f 	call	#0x5fc6	
    6e18:	0f 93       	tst	r15		
    6e1a:	02 24       	jz	$+6      	;abs 0x6e20
		{
			vTaskSwitchContext();
    6e1c:	b0 12 e4 62 	call	#0x62e4	
		}

		/* Restore the context of the new task. */
		portRESTORE_CONTEXT();
    6e20:	1c 40 e6 ad 	mov	-21018(r0),r12	;PC rel. 0x1c08
    6e24:	21 4c       	mov	@r12,	r1	
    6e26:	3f 41       	pop	r15		
    6e28:	80 4f d8 ad 	mov	r15,	-21032(r0);PC rel. 0x1c02
    6e2c:	3f 41       	pop	r15		
    6e2e:	3e 41       	pop	r14		
    6e30:	3d 41       	pop	r13		
    6e32:	3c 41       	pop	r12		
    6e34:	3b 41       	pop	r11		
    6e36:	3a 41       	pop	r10		
    6e38:	39 41       	pop	r9		
    6e3a:	38 41       	pop	r8		
    6e3c:	37 41       	pop	r7		
    6e3e:	36 41       	pop	r6		
    6e40:	35 41       	pop	r5		
    6e42:	34 41       	pop	r4		
    6e44:	b1 c0 f0 00 	bic	#240,	0(r1)	;#0x00f0, 0x0000(r1)
    6e48:	00 00 
    6e4a:	00 13       	reti			

00006e4c <_Z6task_2Pv>:
	}
}

void task_2(void *p)
{
	P10DIR = P10DIR|0x40;
    6e4c:	5f 42 85 02 	mov.b	&0x0285,r15	
    6e50:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    6e54:	c2 4f 85 02 	mov.b	r15,	&0x0285	
	while(1)
	{
		P10OUT = (P10OUT|0x40);	//Set LED1 ON, LED2 OFF
    6e58:	5f 42 83 02 	mov.b	&0x0283,r15	
    6e5c:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    6e60:	c2 4f 83 02 	mov.b	r15,	&0x0283	
		vTaskDelay(LED_DELAY2/2);
    6e64:	3f 40 e8 03 	mov	#1000,	r15	;#0x03e8
    6e68:	b0 12 54 62 	call	#0x6254	
		P10OUT = (P10OUT&(~0x40));	//Set LED1 ON, LED2 OFF
    6e6c:	5f 42 83 02 	mov.b	&0x0283,r15	
    6e70:	7f f0 bf ff 	and.b	#-65,	r15	;#0xffbf
    6e74:	c2 4f 83 02 	mov.b	r15,	&0x0283	
		vTaskDelay(LED_DELAY2/2);
    6e78:	3f 40 e8 03 	mov	#1000,	r15	;#0x03e8
    6e7c:	b0 12 54 62 	call	#0x6254	
    6e80:	eb 3f       	jmp	$-40     	;abs 0x6e58

00006e82 <_Z6task_1Pv>:
	UCSCTL4 = ((UCSCTL4 & ~0x100) & ~0x200) & ~0x400;     //ACLK=XT1  (SELA = 0b000)
	uart_A3_initialize();
	eint();
}
void task_1(void *p)
{
    6e82:	0b 12       	push	r11		
	P10DIR = P10DIR|0x80;
    6e84:	5f 42 85 02 	mov.b	&0x0285,r15	
    6e88:	7f d0 80 ff 	bis.b	#-128,	r15	;#0xff80
    6e8c:	c2 4f 85 02 	mov.b	r15,	&0x0285	
	{
		P10OUT = P10OUT | 0x80 ;	//Set LED1 ON, LED2 OFF
		vTaskDelay(LED_DELAY1/2);
		P10OUT = (P10OUT&(~0x80));	//Set LED1 ON, LED2 OFF
		vTaskDelay(LED_DELAY1/2);
		uart_A3.putchar(char(97+(uint8_t)(rand()%3)));
    6e90:	3b 40 7e 23 	mov	#9086,	r11	;#0x237e
void task_1(void *p)
{
	P10DIR = P10DIR|0x80;
	while(1)
	{
		P10OUT = P10OUT | 0x80 ;	//Set LED1 ON, LED2 OFF
    6e94:	5e 42 83 02 	mov.b	&0x0283,r14	
    6e98:	7e d0 80 ff 	bis.b	#-128,	r14	;#0xff80
    6e9c:	c2 4e 83 02 	mov.b	r14,	&0x0283	
		vTaskDelay(LED_DELAY1/2);
    6ea0:	3f 40 f4 01 	mov	#500,	r15	;#0x01f4
    6ea4:	b0 12 54 62 	call	#0x6254	
		P10OUT = (P10OUT&(~0x80));	//Set LED1 ON, LED2 OFF
    6ea8:	5e 42 83 02 	mov.b	&0x0283,r14	
    6eac:	7e f0 7f 00 	and.b	#127,	r14	;#0x007f
    6eb0:	c2 4e 83 02 	mov.b	r14,	&0x0283	
		vTaskDelay(LED_DELAY1/2);
    6eb4:	3f 40 f4 01 	mov	#500,	r15	;#0x01f4
    6eb8:	b0 12 54 62 	call	#0x6254	
		uart_A3.putchar(char(97+(uint8_t)(rand()%3)));
    6ebc:	b0 12 f8 75 	call	#0x75f8	
    6ec0:	02 12       	push	r2		
    6ec2:	32 c2       	dint			
    6ec4:	03 43       	nop			
    6ec6:	82 4f c2 04 	mov	r15,	&0x04c2	
    6eca:	b2 40 56 55 	mov	#21846,	&0x04c8	;#0x5556
    6ece:	c8 04 
    6ed0:	1e 42 ca 04 	mov	&0x04ca,r14	
    6ed4:	1e 42 cc 04 	mov	&0x04cc,r14	
    6ed8:	32 41       	pop	r2		
    6eda:	0d 4f       	mov	r15,	r13	
    6edc:	8d 10       	swpb	r13		
    6ede:	8d 11       	sxt	r13		
    6ee0:	8d 10       	swpb	r13		
    6ee2:	8d 11       	sxt	r13		
    6ee4:	0e 8d       	sub	r13,	r14	
    6ee6:	0d 4e       	mov	r14,	r13	
    6ee8:	5d 02       	rlam	#1,	r13	
    6eea:	0e 5d       	add	r13,	r14	
    6eec:	0f 8e       	sub	r14,	r15	
    6eee:	0e 4f       	mov	r15,	r14	
    6ef0:	7e 50 61 00 	add.b	#97,	r14	;#0x0061
    6ef4:	0f 4b       	mov	r11,	r15	
    6ef6:	b0 12 00 70 	call	#0x7000	
    6efa:	cc 3f       	jmp	$-102    	;abs 0x6e94

00006efc <_Z18hardwareInitializev>:

extern __UART__ uart_A3;

void hardwareInitialize()
{
	WDTCTL = WDTPW+WDTHOLD;
    6efc:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    6f00:	5c 01 
	int timeout = 5000;
	P11DIR = P11DIR | 0x02 | 0x04;            //set P11.1 & P11.2 as output
    6f02:	5f 42 a4 02 	mov.b	&0x02a4,r15	
    6f06:	7f d0 06 00 	bis.b	#6,	r15	;#0x0006
    6f0a:	c2 4f a4 02 	mov.b	r15,	&0x02a4	
	P11SEL = P11SEL | 0x02 | 0x04;            //set P11.1 & P11.2 as MCLK/SMCLK function
    6f0e:	5f 42 aa 02 	mov.b	&0x02aa,r15	
    6f12:	7f d0 06 00 	bis.b	#6,	r15	;#0x0006
    6f16:	c2 4f aa 02 	mov.b	r15,	&0x02aa	
	P5SEL = P5SEL | 0x04 | 0x08;              //set P5.2 & P5.3 as XT2IN/XT2OUT
    6f1a:	5f 42 4a 02 	mov.b	&0x024a,r15	
    6f1e:	7f d0 0c 00 	bis.b	#12,	r15	;#0x000c
    6f22:	c2 4f 4a 02 	mov.b	r15,	&0x024a	
	
	UCSCTL6 = UCSCTL6 & (~XT2OFF);            //set XT2OFF=0 (bit8 = 0) --> enable XT2
    6f26:	1f 42 6c 01 	mov	&0x016c,r15	
    6f2a:	3f f0 ff fe 	and	#-257,	r15	;#0xfeff
    6f2e:	82 4f 6c 01 	mov	r15,	&0x016c	
	UCSCTL3 = UCSCTL3 | 0x20;                 //set SELREF = 010 --> FLL clock source = REFOCLK
    6f32:	1f 42 66 01 	mov	&0x0166,r15	
    6f36:	3f d0 20 00 	bis	#32,	r15	;#0x0020
    6f3a:	82 4f 66 01 	mov	r15,	&0x0166	
	UCSCTL4 = UCSCTL4 | 0x200;                //set SELA = 010 --> ACLK=REFO
    6f3e:	1f 42 68 01 	mov	&0x0168,r15	
    6f42:	3f d0 00 02 	bis	#512,	r15	;#0x0200
    6f46:	82 4f 68 01 	mov	r15,	&0x0168	
    6f4a:	3f 40 88 13 	mov	#5000,	r15	;#0x1388
	
	do
	{
	  if (!(UCSCTL7 & 0x08)) break;
    6f4e:	1e 42 6e 01 	mov	&0x016e,r14	
    6f52:	3e f2       	and	#8,	r14	;r2 As==11
    6f54:	12 24       	jz	$+38     	;abs 0x6f7a
	  UCSCTL7 = UCSCTL7 & ~(0x0F);            // Clear XT2,XT1,DCO fault flags
    6f56:	1e 42 6e 01 	mov	&0x016e,r14	
    6f5a:	3e f0 f0 ff 	and	#-16,	r14	;#0xfff0
    6f5e:	82 4e 6e 01 	mov	r14,	&0x016e	
	  SFRIFG1 = SFRIFG1 & ~(0x02);            // Clear fault flags (SFRIFG1.OFIFG = 0)
    6f62:	1e 42 02 01 	mov	&0x0102,r14	
    6f66:	3e f0 fd ff 	and	#-3,	r14	;#0xfffd
    6f6a:	82 4e 02 01 	mov	r14,	&0x0102	
	
	UCSCTL6 = UCSCTL6 & (~XT2OFF);            //set XT2OFF=0 (bit8 = 0) --> enable XT2
	UCSCTL3 = UCSCTL3 | 0x20;                 //set SELREF = 010 --> FLL clock source = REFOCLK
	UCSCTL4 = UCSCTL4 | 0x200;                //set SELA = 010 --> ACLK=REFO
	
	do
    6f6e:	1e 42 02 01 	mov	&0x0102,r14	
    6f72:	2e f3       	and	#2,	r14	;r3 As==10
    6f74:	02 24       	jz	$+6      	;abs 0x6f7a
    6f76:	3f 53       	add	#-1,	r15	;r3 As==11
    6f78:	ea 23       	jnz	$-42     	;abs 0x6f4e
	  SFRIFG1 = SFRIFG1 & ~(0x02);            // Clear fault flags (SFRIFG1.OFIFG = 0)
	  timeout--;
	}
	while ((SFRIFG1 & 0x02) && timeout);      // Test oscillator fault flag
	
	UCSCTL5 = UCSCTL5 | 0x0005;               //MCLK/SMCLK divisor = 32
    6f7a:	1f 42 6a 01 	mov	&0x016a,r15	
    6f7e:	3f d0 05 00 	bis	#5,	r15	;#0x0005
    6f82:	82 4f 6a 01 	mov	r15,	&0x016a	
	
	UCSCTL4 = UCSCTL4 | 0x55;                 //SMCLK=MCLK=XT2
    6f86:	1f 42 68 01 	mov	&0x0168,r15	
    6f8a:	3f d0 55 00 	bis	#85,	r15	;#0x0055
    6f8e:	82 4f 68 01 	mov	r15,	&0x0168	
	UCSCTL4 = ((UCSCTL4 & ~0x100) & ~0x200) & ~0x400;     //ACLK=XT1  (SELA = 0b000)
    6f92:	1f 42 68 01 	mov	&0x0168,r15	
    6f96:	3f f0 ff f8 	and	#-1793,	r15	;#0xf8ff
    6f9a:	82 4f 68 01 	mov	r15,	&0x0168	
	uart_A3_initialize();
    6f9e:	b0 12 66 74 	call	#0x7466	
	eint();
    6fa2:	32 d2       	eint			
}
    6fa4:	30 41       	ret			

00006fa6 <_ZN8__UART__C1Ev>:
* NAME               : __UART__::__UART__()
* DESCRIPTION        : __UART__ constructor
*/
__UART__::__UART__()
{
	rx_length =  tx_length = rx_start = tx_start = 0;
    6fa6:	8f 43 04 01 	mov	#0,	260(r15);r3 As==00, 0x0104(r15)
    6faa:	8f 43 06 01 	mov	#0,	262(r15);r3 As==00, 0x0106(r15)
    6fae:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    6fb2:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
}
    6fb6:	30 41       	ret			

00006fb8 <_ZN8__UART__7getcharERh>:
/*
* NAME               : uint8_t __UART__::getchar(uint8_t &c)
* DESCRIPTION        : Return a character from the receive buffer
*/
uint8_t __UART__::getchar(uint8_t &c)
{
    6fb8:	1b 15       	pushm	#2,	r11	
    6fba:	0b 4f       	mov	r15,	r11	
    6fbc:	0a 4e       	mov	r14,	r10	
	if(rx_length > 0)
    6fbe:	8f 93 00 00 	tst	0(r15)		;0x0000(r15)
    6fc2:	1b 24       	jz	$+56     	;abs 0x6ffa
	{
		disable_uart_interrupts();
    6fc4:	9f 12 0c 01 	call	268(r15)	;0x010c(r15)
		c = rxBuffer[rx_start];
    6fc8:	0f 4b       	mov	r11,	r15	
    6fca:	1f 5b 06 01 	add	262(r11),r15	;0x0106(r11)
    6fce:	da 4f 84 00 	mov.b	132(r15),0(r10)	;0x0084(r15), 0x0000(r10)
    6fd2:	00 00 
		rx_start++;
    6fd4:	1e 4b 06 01 	mov	262(r11),r14	;0x0106(r11)
    6fd8:	0f 4e       	mov	r14,	r15	
    6fda:	1f 53       	inc	r15		
    6fdc:	8b 4f 06 01 	mov	r15,	262(r11);0x0106(r11)
		rx_length--;
    6fe0:	bb 53 00 00 	add	#-1,	0(r11)	;r3 As==11, 0x0000(r11)
		if(rx_start >= UART_BUFFER_LENGTH)
    6fe4:	3f 90 80 00 	cmp	#128,	r15	;#0x0080
    6fe8:	04 28       	jnc	$+10     	;abs 0x6ff2
		{
			rx_start = rx_start - UART_BUFFER_LENGTH;
    6fea:	3e 50 81 ff 	add	#-127,	r14	;#0xff81
    6fee:	8b 4e 06 01 	mov	r14,	262(r11);0x0106(r11)
		}
		enable_uart_interrupts();
    6ff2:	9b 12 0a 01 	call	266(r11)	;0x010a(r11)
		return 1;
    6ff6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    6ff8:	01 3c       	jmp	$+4      	;abs 0x6ffc
	}
	else
	{
		return 0;
    6ffa:	4f 43       	clr.b	r15		
	}
}
    6ffc:	1a 17       	popm	#2,	r11	
    6ffe:	30 41       	ret			

00007000 <_ZN8__UART__7putcharEh>:
/*
* NAME               : uint8_t __UART__::putchar(uint8_t c)
* DESCRIPTION        : Input a character to be transmitted by queueing into the tx buffer 
*/
uint8_t __UART__::putchar(uint8_t c)
{
    7000:	1b 15       	pushm	#2,	r11	
    7002:	0b 4f       	mov	r15,	r11	
    7004:	4a 4e       	mov.b	r14,	r10	
	if(tx_length < UART_BUFFER_LENGTH)
    7006:	bf 90 80 00 	cmp	#128,	2(r15)	;#0x0080, 0x0002(r15)
    700a:	02 00 
    700c:	15 2c       	jc	$+44     	;abs 0x7038
	{
		disable_uart_interrupts();
    700e:	9f 12 0c 01 	call	268(r15)	;0x010c(r15)
		txBuffer[(tx_start+tx_length)%UART_BUFFER_LENGTH] = c;
    7012:	1f 4b 02 00 	mov	2(r11),	r15	;0x0002(r11)
    7016:	0e 4f       	mov	r15,	r14	
    7018:	1e 5b 04 01 	add	260(r11),r14	;0x0104(r11)
    701c:	3e f0 7f 00 	and	#127,	r14	;#0x007f
    7020:	0e 5b       	add	r11,	r14	
    7022:	ce 4a 04 00 	mov.b	r10,	4(r14)	;0x0004(r14)
		tx_length++;
    7026:	1f 53       	inc	r15		
    7028:	8b 4f 02 00 	mov	r15,	2(r11)	;0x0002(r11)
		enable_tx();
    702c:	9b 12 0e 01 	call	270(r11)	;0x010e(r11)
		enable_uart_interrupts();
    7030:	9b 12 0a 01 	call	266(r11)	;0x010a(r11)
		return 1;
    7034:	5f 43       	mov.b	#1,	r15	;r3 As==01
    7036:	01 3c       	jmp	$+4      	;abs 0x703a
	}
	else
	{
		return 0;
    7038:	4f 43       	clr.b	r15		
	}
}
    703a:	1a 17       	popm	#2,	r11	
    703c:	30 41       	ret			

0000703e <_ZN8__UART__4getsEPhj>:
* NAME               : uint8_t __UART__::gets(char *buffer, uint16_t length)
* DESCRIPTION        : Return a given length of characters from the received buffer into 
		       the memory location passed and return the number of bytes copied.
*/
uint8_t __UART__::gets(uint8_t *buffer,uint16_t length)
{
    703e:	4b 15       	pushm	#5,	r11	
    7040:	0b 4f       	mov	r15,	r11	
    7042:	07 4e       	mov	r14,	r7	
    7044:	08 4d       	mov	r13,	r8	
	//disable all interrupts from uart here
	disable_uart_interrupts();
    7046:	9f 12 0c 01 	call	268(r15)	;0x010c(r15)
	if(rx_length >= length)
    704a:	2f 4b       	mov	@r11,	r15	
    704c:	0f 98       	cmp	r8,	r15	
    704e:	03 2c       	jc	$+8      	;abs 0x7056
		return length;
	}
	else
	{
		uint16_t &i = length;
		for(i = 0;i<rx_length;i++)
    7050:	0f 93       	tst	r15		
    7052:	20 20       	jnz	$+66     	;abs 0x7094
    7054:	39 3c       	jmp	$+116    	;abs 0x70c8
{
	//disable all interrupts from uart here
	disable_uart_interrupts();
	if(rx_length >= length)
	{
		for(uint16_t i = 0; i< length; i++)
    7056:	08 93       	tst	r8		
    7058:	19 24       	jz	$+52     	;abs 0x708c
    705a:	0c 43       	clr	r12		
		{
			buffer[i] = rxBuffer[rx_start];
    705c:	09 4b       	mov	r11,	r9	
    705e:	19 5b 06 01 	add	262(r11),r9	;0x0106(r11)
/*
* NAME               : uint8_t __UART__::gets(char *buffer, uint16_t length)
* DESCRIPTION        : Return a given length of characters from the received buffer into 
		       the memory location passed and return the number of bytes copied.
*/
uint8_t __UART__::gets(uint8_t *buffer,uint16_t length)
    7062:	0a 47       	mov	r7,	r10	
    7064:	0a 5c       	add	r12,	r10	
	disable_uart_interrupts();
	if(rx_length >= length)
	{
		for(uint16_t i = 0; i< length; i++)
		{
			buffer[i] = rxBuffer[rx_start];
    7066:	da 49 84 00 	mov.b	132(r9),0(r10)	;0x0084(r9), 0x0000(r10)
    706a:	00 00 
			rx_start++;
    706c:	1f 4b 06 01 	mov	262(r11),r15	;0x0106(r11)
    7070:	0a 4f       	mov	r15,	r10	
    7072:	1a 53       	inc	r10		
    7074:	8b 4a 06 01 	mov	r10,	262(r11);0x0106(r11)
			if(rx_start >= UART_BUFFER_LENGTH)
    7078:	3a 90 80 00 	cmp	#128,	r10	;#0x0080
    707c:	04 28       	jnc	$+10     	;abs 0x7086
				rx_start -= UART_BUFFER_LENGTH;
    707e:	3f 50 81 ff 	add	#-127,	r15	;#0xff81
    7082:	8b 4f 06 01 	mov	r15,	262(r11);0x0106(r11)
{
	//disable all interrupts from uart here
	disable_uart_interrupts();
	if(rx_length >= length)
	{
		for(uint16_t i = 0; i< length; i++)
    7086:	1c 53       	inc	r12		
    7088:	0c 98       	cmp	r8,	r12	
    708a:	e8 23       	jnz	$-46     	;abs 0x705c
			buffer[i] = rxBuffer[rx_start];
			rx_start++;
			if(rx_start >= UART_BUFFER_LENGTH)
				rx_start -= UART_BUFFER_LENGTH;
		}
		rx_length -= length;
    708c:	8b 88 00 00 	sub	r8,	0(r11)	;0x0000(r11)
		return length;
    7090:	4f 48       	mov.b	r8,	r15	
    7092:	1d 3c       	jmp	$+60     	;abs 0x70ce
	}
	else
	{
		uint16_t &i = length;
		for(i = 0;i<rx_length;i++)
    7094:	0c 43       	clr	r12		
		{
			buffer[i] = rxBuffer[(rx_start)];
    7096:	0d 4b       	mov	r11,	r13	
    7098:	1d 5b 06 01 	add	262(r11),r13	;0x0106(r11)
/*
* NAME               : uint8_t __UART__::gets(char *buffer, uint16_t length)
* DESCRIPTION        : Return a given length of characters from the received buffer into 
		       the memory location passed and return the number of bytes copied.
*/
uint8_t __UART__::gets(uint8_t *buffer,uint16_t length)
    709c:	0f 47       	mov	r7,	r15	
    709e:	0f 5c       	add	r12,	r15	
	else
	{
		uint16_t &i = length;
		for(i = 0;i<rx_length;i++)
		{
			buffer[i] = rxBuffer[(rx_start)];
    70a0:	df 4d 84 00 	mov.b	132(r13),0(r15)	;0x0084(r13), 0x0000(r15)
    70a4:	00 00 
			rx_start++;
    70a6:	1d 4b 06 01 	mov	262(r11),r13	;0x0106(r11)
    70aa:	0f 4d       	mov	r13,	r15	
    70ac:	1f 53       	inc	r15		
    70ae:	8b 4f 06 01 	mov	r15,	262(r11);0x0106(r11)
			if(rx_start>=UART_BUFFER_LENGTH)
    70b2:	3f 90 80 00 	cmp	#128,	r15	;#0x0080
    70b6:	04 28       	jnc	$+10     	;abs 0x70c0
			{
				rx_start-=UART_BUFFER_LENGTH;
    70b8:	3d 50 81 ff 	add	#-127,	r13	;#0xff81
    70bc:	8b 4d 06 01 	mov	r13,	262(r11);0x0106(r11)
		return length;
	}
	else
	{
		uint16_t &i = length;
		for(i = 0;i<rx_length;i++)
    70c0:	1c 53       	inc	r12		
    70c2:	2f 4b       	mov	@r11,	r15	
    70c4:	0c 9f       	cmp	r15,	r12	
    70c6:	e7 2b       	jnc	$-48     	;abs 0x7096
			{
				rx_start-=UART_BUFFER_LENGTH;
			}
		}
		length = rx_length;
		rx_length = 0;
    70c8:	8b 43 00 00 	mov	#0,	0(r11)	;r3 As==00, 0x0000(r11)
		return length;
    70cc:	4f 4f       	mov.b	r15,	r15	
	}
	//enable all interrupts from uart here
	enable_uart_interrupts();
}
    70ce:	47 17       	popm	#5,	r11	
    70d0:	30 41       	ret			

000070d2 <_ZN8__UART__4putsEPKcj>:
* NAME               : uint8_t __UART__::puts(char *buffer, uint16_length)
* DESCRIPTION        : Insert the characters from the given buffer into the tx buffer. 
		       Count of characters is given in length.
*/
uint8_t __UART__::puts(char const *buffer, uint16_t length)
{
    70d2:	3b 15       	pushm	#4,	r11	
    70d4:	0b 4f       	mov	r15,	r11	
    70d6:	08 4e       	mov	r14,	r8	
    70d8:	09 4d       	mov	r13,	r9	
	if((UART_BUFFER_LENGTH - tx_length) > length)
    70da:	3f 40 80 00 	mov	#128,	r15	;#0x0080
    70de:	1f 8b 02 00 	sub	2(r11),	r15	;0x0002(r11)
    70e2:	0d 9f       	cmp	r15,	r13	
    70e4:	1d 2c       	jc	$+60     	;abs 0x7120
	{
		disable_uart_interrupts();
    70e6:	9b 12 0c 01 	call	268(r11)	;0x010c(r11)
		for(uint16_t i = 0; i< length ; i++)
    70ea:	09 93       	tst	r9		
    70ec:	11 24       	jz	$+36     	;abs 0x7110
		{
			txBuffer[(tx_start+tx_length+i)%UART_BUFFER_LENGTH] = buffer[i];
    70ee:	1e 4b 02 00 	mov	2(r11),	r14	;0x0002(r11)
    70f2:	1e 5b 04 01 	add	260(r11),r14	;0x0104(r11)
uint8_t __UART__::puts(char const *buffer, uint16_t length)
{
	if((UART_BUFFER_LENGTH - tx_length) > length)
	{
		disable_uart_interrupts();
		for(uint16_t i = 0; i< length ; i++)
    70f6:	0c 43       	clr	r12		
		{
			txBuffer[(tx_start+tx_length+i)%UART_BUFFER_LENGTH] = buffer[i];
    70f8:	0f 4c       	mov	r12,	r15	
    70fa:	0f 5e       	add	r14,	r15	
    70fc:	3f f0 7f 00 	and	#127,	r15	;#0x007f
    7100:	0f 5b       	add	r11,	r15	
/*
* NAME               : uint8_t __UART__::puts(char *buffer, uint16_length)
* DESCRIPTION        : Insert the characters from the given buffer into the tx buffer. 
		       Count of characters is given in length.
*/
uint8_t __UART__::puts(char const *buffer, uint16_t length)
    7102:	0a 48       	mov	r8,	r10	
    7104:	0a 5c       	add	r12,	r10	
	if((UART_BUFFER_LENGTH - tx_length) > length)
	{
		disable_uart_interrupts();
		for(uint16_t i = 0; i< length ; i++)
		{
			txBuffer[(tx_start+tx_length+i)%UART_BUFFER_LENGTH] = buffer[i];
    7106:	ef 4a 04 00 	mov.b	@r10,	4(r15)	;0x0004(r15)
uint8_t __UART__::puts(char const *buffer, uint16_t length)
{
	if((UART_BUFFER_LENGTH - tx_length) > length)
	{
		disable_uart_interrupts();
		for(uint16_t i = 0; i< length ; i++)
    710a:	1c 53       	inc	r12		
    710c:	0c 99       	cmp	r9,	r12	
    710e:	f4 23       	jnz	$-22     	;abs 0x70f8
		{
			txBuffer[(tx_start+tx_length+i)%UART_BUFFER_LENGTH] = buffer[i];
		}
		tx_length += length;
    7110:	8b 59 02 00 	add	r9,	2(r11)	;0x0002(r11)
		enable_tx();
    7114:	9b 12 0e 01 	call	270(r11)	;0x010e(r11)
		enable_uart_interrupts();
    7118:	9b 12 0a 01 	call	266(r11)	;0x010a(r11)
		return 1;
    711c:	5f 43       	mov.b	#1,	r15	;r3 As==01
    711e:	01 3c       	jmp	$+4      	;abs 0x7122
	}
	else
	{
		return  0;
    7120:	4f 43       	clr.b	r15		
	}
}
    7122:	38 17       	popm	#4,	r11	
    7124:	30 41       	ret			

00007126 <_ZN8__UART__4peekERh>:
/*
* NAME               : uint8_t __UART__::peek(char &c)
* DESCRIPTION        : Get the immediate next character from rx buffer without removing it.
*/
uint8_t __UART__::peek(uint8_t &c)
{
    7126:	1b 15       	pushm	#2,	r11	
    7128:	0b 4f       	mov	r15,	r11	
    712a:	0a 4e       	mov	r14,	r10	
	if(rx_length)
    712c:	8f 93 00 00 	tst	0(r15)		;0x0000(r15)
    7130:	0f 24       	jz	$+32     	;abs 0x7150
	{
		disable_uart_interrupts();
    7132:	9f 12 0c 01 	call	268(r15)	;0x010c(r15)
		c  = rxBuffer[(rx_start+rx_length)%UART_BUFFER_LENGTH];
    7136:	2f 4b       	mov	@r11,	r15	
    7138:	1f 5b 06 01 	add	262(r11),r15	;0x0106(r11)
    713c:	3f f0 7f 00 	and	#127,	r15	;#0x007f
    7140:	0f 5b       	add	r11,	r15	
    7142:	da 4f 84 00 	mov.b	132(r15),0(r10)	;0x0084(r15), 0x0000(r10)
    7146:	00 00 
		enable_uart_interrupts();
    7148:	9b 12 0a 01 	call	266(r11)	;0x010a(r11)
		return 1;
    714c:	5f 43       	mov.b	#1,	r15	;r3 As==01
    714e:	01 3c       	jmp	$+4      	;abs 0x7152
	}
	else
	{
		return 0;
    7150:	4f 43       	clr.b	r15		
	}
}
    7152:	1a 17       	popm	#2,	r11	
    7154:	30 41       	ret			

00007156 <_ZN8__UART__11get_rxCountEv>:
* DESCRIPTION        : Return the number of received bytes/chars available in the received buffer.
*/
uint16_t __UART__::get_rxCount()
{
	return rx_length;
}
    7156:	2f 4f       	mov	@r15,	r15	
    7158:	30 41       	ret			

0000715a <_ZN8__UART__11get_txCountEv>:
* DESCRIPTION        : Return the number of bytes/chars space available in the transmit buffer.
*/
uint16_t __UART__::get_txCount()
{
	return (UART_BUFFER_LENGTH - tx_length);
}
    715a:	3e 40 80 00 	mov	#128,	r14	;#0x0080
    715e:	1e 8f 02 00 	sub	2(r15),	r14	;0x0002(r15)
    7162:	0f 4e       	mov	r14,	r15	
    7164:	30 41       	ret			

00007166 <_ZN8__UART__15__on_rx_receiveEh>:
* NAME               : uint8_t __UART__::__on_rx_interrupt
* DESCRIPTION        : Function to insert byte/char into rxBuffer after receiving one char.
*/
void __UART__::__on_rx_receive(uint8_t c)
{
	if(rx_length<UART_BUFFER_LENGTH)
    7166:	2d 4f       	mov	@r15,	r13	
    7168:	3d 90 80 00 	cmp	#128,	r13	;#0x0080
    716c:	0c 2c       	jc	$+26     	;abs 0x7186
	{
		rxBuffer[(rx_start+rx_length)%UART_BUFFER_LENGTH] = c;
    716e:	0c 4d       	mov	r13,	r12	
    7170:	1c 5f 06 01 	add	262(r15),r12	;0x0106(r15)
    7174:	3c f0 7f 00 	and	#127,	r12	;#0x007f
    7178:	0c 5f       	add	r15,	r12	
    717a:	cc 4e 84 00 	mov.b	r14,	132(r12);0x0084(r12)
		rx_length++;
    717e:	1d 53       	inc	r13		
    7180:	8f 4d 00 00 	mov	r13,	0(r15)	;0x0000(r15)
    7184:	30 41       	ret			
	}
	else
	{
		rxBuffer[(rx_start+rx_length)%UART_BUFFER_LENGTH] = c;
    7186:	1c 4f 06 01 	mov	262(r15),r12	;0x0106(r15)
    718a:	0d 5c       	add	r12,	r13	
    718c:	3d f0 7f 00 	and	#127,	r13	;#0x007f
    7190:	0d 5f       	add	r15,	r13	
    7192:	cd 4e 84 00 	mov.b	r14,	132(r13);0x0084(r13)
		rx_start++;
    7196:	0e 4c       	mov	r12,	r14	
    7198:	1e 53       	inc	r14		
    719a:	8f 4e 06 01 	mov	r14,	262(r15);0x0106(r15)
		if(rx_start >= UART_BUFFER_LENGTH)
    719e:	3e 90 80 00 	cmp	#128,	r14	;#0x0080
    71a2:	04 28       	jnc	$+10     	;abs 0x71ac
			rx_start -= UART_BUFFER_LENGTH;
    71a4:	3c 50 81 ff 	add	#-127,	r12	;#0xff81
    71a8:	8f 4c 06 01 	mov	r12,	262(r15);0x0106(r15)
    71ac:	30 41       	ret			

000071ae <_ZN8__UART__15__on_tx_receiveEPh>:
* DESCRIPTION        : Function to return a character to be transmitted from txBuffer
*/

uint8_t __UART__::__on_tx_receive(uint8_t *c)
{
	if(tx_length)
    71ae:	8f 93 02 00 	tst	2(r15)		;0x0002(r15)
    71b2:	17 24       	jz	$+48     	;abs 0x71e2
	{
		*c = txBuffer[tx_start];
    71b4:	0d 4f       	mov	r15,	r13	
    71b6:	1d 5f 04 01 	add	260(r15),r13	;0x0104(r15)
    71ba:	de 4d 04 00 	mov.b	4(r13),	0(r14)	;0x0004(r13), 0x0000(r14)
    71be:	00 00 
		tx_length--;
    71c0:	bf 53 02 00 	add	#-1,	2(r15)	;r3 As==11, 0x0002(r15)
		tx_start++;
    71c4:	1d 4f 04 01 	mov	260(r15),r13	;0x0104(r15)
    71c8:	0e 4d       	mov	r13,	r14	
    71ca:	1e 53       	inc	r14		
    71cc:	8f 4e 04 01 	mov	r14,	260(r15);0x0104(r15)
		if(tx_start >= UART_BUFFER_LENGTH)
    71d0:	3e 90 80 00 	cmp	#128,	r14	;#0x0080
    71d4:	0a 28       	jnc	$+22     	;abs 0x71ea
			tx_start -= UART_BUFFER_LENGTH;
    71d6:	3d 50 81 ff 	add	#-127,	r13	;#0xff81
    71da:	8f 4d 04 01 	mov	r13,	260(r15);0x0104(r15)
		return 1;
    71de:	5f 43       	mov.b	#1,	r15	;r3 As==01
    71e0:	30 41       	ret			
	}
	else
	{
		disable_tx();
    71e2:	9f 12 10 01 	call	272(r15)	;0x0110(r15)
		return 0;
    71e6:	4f 43       	clr.b	r15		
    71e8:	30 41       	ret			
		*c = txBuffer[tx_start];
		tx_length--;
		tx_start++;
		if(tx_start >= UART_BUFFER_LENGTH)
			tx_start -= UART_BUFFER_LENGTH;
		return 1;
    71ea:	5f 43       	mov.b	#1,	r15	;r3 As==01
	else
	{
		disable_tx();
		return 0;
	}
}
    71ec:	30 41       	ret			

000071ee <_Z33uart_A3_enable_uart_A3_interruptsv>:
	}
}

void uart_A3_enable_uart_A3_interrupts()
{
	UCA3IE |= UCTXIE + UCRXIE;
    71ee:	5f 42 9c 06 	mov.b	&0x069c,r15	
    71f2:	7f d0 03 00 	bis.b	#3,	r15	;#0x0003
    71f6:	c2 4f 9c 06 	mov.b	r15,	&0x069c	
}
    71fa:	30 41       	ret			

000071fc <_Z34uart_A3_disable_uart_A3_interruptsv>:


void uart_A3_disable_uart_A3_interrupts()
{
	UCA3IE &= ~(UCTXIE+UCRXIE);
    71fc:	5f 42 9c 06 	mov.b	&0x069c,r15	
    7200:	7f f0 fc ff 	and.b	#-4,	r15	;#0xfffc
    7204:	c2 4f 9c 06 	mov.b	r15,	&0x069c	
}
    7208:	30 41       	ret			

0000720a <_Z17uart_A3_configurej6PARITY>:

void uart_A3_configure(uint16_t baud = 9600, PARITY par = EVEN_PARITY)
{
    720a:	5b 15       	pushm	#6,	r11	
    float n, x;
    P10DIR = P10DIR | 1<<4;           //set P10.4=1 (Transmitter) as output
    720c:	5e 42 85 02 	mov.b	&0x0285,r14	
    7210:	7e d0 10 00 	bis.b	#16,	r14	;#0x0010
    7214:	c2 4e 85 02 	mov.b	r14,	&0x0285	
    P10DIR = P10DIR & ~(1<<5);        //set P10.5=0 (Receiver) as input
    7218:	5e 42 85 02 	mov.b	&0x0285,r14	
    721c:	7e f0 df ff 	and.b	#-33,	r14	;#0xffdf
    7220:	c2 4e 85 02 	mov.b	r14,	&0x0285	
    P10SEL = P10SEL | 1<<4 | 1<<5;    //set P10.4=1 & P10.5=1 as TX/RX
    7224:	5e 42 8b 02 	mov.b	&0x028b,r14	
    7228:	7e d0 30 00 	bis.b	#48,	r14	;#0x0030
    722c:	c2 4e 8b 02 	mov.b	r14,	&0x028b	

    UCA3CTL1 = UCA3CTL1 | 0x01;     //UCSWRST = 1 (bit0 = 1)   //page 417
    7230:	5e 42 80 06 	mov.b	&0x0680,r14	
    7234:	5e d3       	bis.b	#1,	r14	;r3 As==01
    7236:	c2 4e 80 06 	mov.b	r14,	&0x0680	
    UCA3CTL1 = (UCA3CTL1 | 1<<7) & ~(1<<6);       //select SMCLK as BaudRate source clock (bit6 = 1; bit7 = 1)
    723a:	5e 42 80 06 	mov.b	&0x0680,r14	
    723e:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    7242:	7e d0 80 ff 	bis.b	#-128,	r14	;#0xff80
    7246:	c2 4e 80 06 	mov.b	r14,	&0x0680	

    //calculate registers for the BaudRate +

    UCA3MCTL = UCA3MCTL | 0x01;       //UCOS16 = 1
    724a:	5e 42 88 06 	mov.b	&0x0688,r14	
    724e:	5e d3       	bis.b	#1,	r14	;r3 As==01
    7250:	c2 4e 88 06 	mov.b	r14,	&0x0688	
    //calculate UCBR
    n = configCPU_CLOCK_HZ  /baud;
    7254:	0c 4f       	mov	r15,	r12	
    7256:	0d 43       	clr	r13		
    7258:	3e 40 80 a8 	mov	#-22400,r14	;#0xa880
    725c:	3f 40 12 01 	mov	#274,	r15	;#0x0112
    7260:	b0 12 52 76 	call	#0x7652	
    7264:	b0 12 f2 7c 	call	#0x7cf2	
    7268:	0a 4e       	mov	r14,	r10	
    726a:	0b 4f       	mov	r15,	r11	
    UCA3BR0 = (int)(n/16) % 256;
    726c:	0c 43       	clr	r12		
    726e:	3d 40 80 3d 	mov	#15744,	r13	;#0x3d80
    7272:	b0 12 a2 79 	call	#0x79a2	
    7276:	08 4e       	mov	r14,	r8	
    7278:	09 4f       	mov	r15,	r9	
    727a:	b0 12 62 7c 	call	#0x7c62	
    727e:	07 4e       	mov	r14,	r7	
    7280:	0f 4e       	mov	r14,	r15	
    7282:	3f f0 ff 80 	and	#-32513,r15	;#0x80ff
    7286:	04 34       	jge	$+10     	;abs 0x7290
    7288:	3f 53       	add	#-1,	r15	;r3 As==11
    728a:	3f d0 00 ff 	bis	#-256,	r15	;#0xff00
    728e:	1f 53       	inc	r15		
    7290:	c2 4f 86 06 	mov.b	r15,	&0x0686	
    UCA3BR1 = (int)(n/16) / 256;
    7294:	0f 47       	mov	r7,	r15	
    7296:	07 93       	tst	r7		
    7298:	02 34       	jge	$+6      	;abs 0x729e
    729a:	3f 50 ff 00 	add	#255,	r15	;#0x00ff
    729e:	8f 10       	swpb	r15		
    72a0:	8f 11       	sxt	r15		
    72a2:	c2 4f 87 06 	mov.b	r15,	&0x0687	

    //caluclate UCBRS
    x = (int)((n-(int)(n))*8+0.5);
    UCA3MCTL = UCA3MCTL | (int)(x)<<1;
    72a6:	56 42 88 06 	mov.b	&0x0688,r6	
    n = configCPU_CLOCK_HZ  /baud;
    UCA3BR0 = (int)(n/16) % 256;
    UCA3BR1 = (int)(n/16) / 256;

    //caluclate UCBRS
    x = (int)((n-(int)(n))*8+0.5);
    72aa:	0e 4a       	mov	r10,	r14	
    72ac:	0f 4b       	mov	r11,	r15	
    72ae:	b0 12 62 7c 	call	#0x7c62	
    72b2:	0f 4e       	mov	r14,	r15	
    72b4:	8f 10       	swpb	r15		
    72b6:	8f 11       	sxt	r15		
    72b8:	8f 10       	swpb	r15		
    72ba:	8f 11       	sxt	r15		
    72bc:	b0 12 c0 7b 	call	#0x7bc0	
    72c0:	0c 4e       	mov	r14,	r12	
    72c2:	0d 4f       	mov	r15,	r13	
    72c4:	0e 4a       	mov	r10,	r14	
    72c6:	0f 4b       	mov	r11,	r15	
    72c8:	b0 12 52 79 	call	#0x7952	
    72cc:	0c 43       	clr	r12		
    72ce:	3d 40 00 41 	mov	#16640,	r13	;#0x4100
    72d2:	b0 12 a2 79 	call	#0x79a2	
    72d6:	0c 43       	clr	r12		
    72d8:	3d 40 00 3f 	mov	#16128,	r13	;#0x3f00
    72dc:	b0 12 06 79 	call	#0x7906	
    72e0:	b0 12 62 7c 	call	#0x7c62	
    72e4:	0f 4e       	mov	r14,	r15	
    72e6:	8f 10       	swpb	r15		
    72e8:	8f 11       	sxt	r15		
    72ea:	8f 10       	swpb	r15		
    72ec:	8f 11       	sxt	r15		
    72ee:	b0 12 c0 7b 	call	#0x7bc0	
    UCA3MCTL = UCA3MCTL | (int)(x)<<1;
    72f2:	b0 12 62 7c 	call	#0x7c62	
    72f6:	5e 02       	rlam	#1,	r14	
    72f8:	4e d6       	bis.b	r6,	r14	
    72fa:	c2 4e 88 06 	mov.b	r14,	&0x0688	

    //caluclate UCBRF
    x = (int)(((n/16 - (int)(n/16))*16) + 0.5);
    UCA3MCTL = UCA3MCTL | (int)(x)<<4;
    72fe:	5a 42 88 06 	mov.b	&0x0688,r10	
    //caluclate UCBRS
    x = (int)((n-(int)(n))*8+0.5);
    UCA3MCTL = UCA3MCTL | (int)(x)<<1;

    //caluclate UCBRF
    x = (int)(((n/16 - (int)(n/16))*16) + 0.5);
    7302:	0f 47       	mov	r7,	r15	
    7304:	8f 10       	swpb	r15		
    7306:	8f 11       	sxt	r15		
    7308:	8f 10       	swpb	r15		
    730a:	8f 11       	sxt	r15		
    730c:	0e 47       	mov	r7,	r14	
    730e:	b0 12 c0 7b 	call	#0x7bc0	
    7312:	0c 4e       	mov	r14,	r12	
    7314:	0d 4f       	mov	r15,	r13	
    7316:	0e 48       	mov	r8,	r14	
    7318:	0f 49       	mov	r9,	r15	
    731a:	b0 12 52 79 	call	#0x7952	
    731e:	0c 43       	clr	r12		
    7320:	3d 40 80 41 	mov	#16768,	r13	;#0x4180
    7324:	b0 12 a2 79 	call	#0x79a2	
    7328:	0c 43       	clr	r12		
    732a:	3d 40 00 3f 	mov	#16128,	r13	;#0x3f00
    732e:	b0 12 06 79 	call	#0x7906	
    7332:	b0 12 62 7c 	call	#0x7c62	
    7336:	0f 4e       	mov	r14,	r15	
    7338:	8f 10       	swpb	r15		
    733a:	8f 11       	sxt	r15		
    733c:	8f 10       	swpb	r15		
    733e:	8f 11       	sxt	r15		
    7340:	b0 12 c0 7b 	call	#0x7bc0	
    UCA3MCTL = UCA3MCTL | (int)(x)<<4;
    7344:	b0 12 62 7c 	call	#0x7c62	
    7348:	5e 0e       	rlam	#4,	r14	
    734a:	4e da       	bis.b	r10,	r14	
    734c:	c2 4e 88 06 	mov.b	r14,	&0x0688	

    //calculate registers for the BaudRate -

    UCA3CTL0 = 0x00;                  //Set Format Frame: 8 bit data; no parity; 1 stop bit
    7350:	c2 43 81 06 	mov.b	#0,	&0x0681	;r3 As==00

    UCA3CTL1 = UCA3CTL1 & ~(0x01);    //UCSWRST = 0 (bit0 = 0) //page 417
    7354:	5f 42 80 06 	mov.b	&0x0680,r15	
    7358:	7f f0 fe ff 	and.b	#-2,	r15	;#0xfffe
    735c:	c2 4f 80 06 	mov.b	r15,	&0x0680	

}
    7360:	56 17       	popm	#6,	r11	
    7362:	30 41       	ret			

00007364 <_Z25uart_A3_enable_uart_A3_txv>:
    UCA3CTL1 = UCA3CTL1 & ~(0x01);    //UCSWRST = 0 (bit0 = 0) //page 417
}

void uart_A3_enable_uart_A3_tx()
{
	uart_A3_enable_uart_A3_interrupts();
    7364:	b0 12 ee 71 	call	#0x71ee	
	UCA3IE |= UCTXIE;
    7368:	5f 42 9c 06 	mov.b	&0x069c,r15	
    736c:	6f d3       	bis.b	#2,	r15	;r3 As==10
    736e:	c2 4f 9c 06 	mov.b	r15,	&0x069c	
	UCA3IFG |= UCTXIFG;
    7372:	5f 42 9d 06 	mov.b	&0x069d,r15	
    7376:	6f d3       	bis.b	#2,	r15	;r3 As==10
    7378:	c2 4f 9d 06 	mov.b	r15,	&0x069d	
}
    737c:	30 41       	ret			

0000737e <_Z26uart_A3_disable_uart_A3_txv>:

void uart_A3_disable_uart_A3_tx()
{
	UCA3IE &= ~UCTXIE;
    737e:	5f 42 9c 06 	mov.b	&0x069c,r15	
    7382:	7f f0 fd ff 	and.b	#-3,	r15	;#0xfffd
    7386:	c2 4f 9c 06 	mov.b	r15,	&0x069c	
	UCA3IFG &= ~UCTXIFG;
    738a:	5f 42 9d 06 	mov.b	&0x069d,r15	
    738e:	7f f0 fd ff 	and.b	#-3,	r15	;#0xfffd
    7392:	c2 4f 9d 06 	mov.b	r15,	&0x069d	
}
    7396:	30 41       	ret			

00007398 <_Z24uart_A3_interrupt_vectorv>:

#define DEFAULT_BAUDRATE 9600

#pragma vector=USCI_A3_VECTOR
__interrupt void uart_A3_interrupt_vector(void)
{
    7398:	3f 15       	pushm	#4,	r15	
    739a:	21 83       	decd	r1		
	uint8_t c;
	uint8_t *c_p;
	c_p = &c;
	switch((UCA3IV))
    739c:	1f 42 9e 06 	mov	&0x069e,r15	
    73a0:	2f 93       	cmp	#2,	r15	;r3 As==10
    73a2:	03 24       	jz	$+8      	;abs 0x73aa
    73a4:	2f 92       	cmp	#4,	r15	;r2 As==10
    73a6:	20 20       	jnz	$+66     	;abs 0x73e8
    73a8:	09 3c       	jmp	$+20     	;abs 0x73bc
		case 0: break;
			// Vector 0 - no interrupt
	
		case 2:
			// Vector 2 - RXIFG
			c = UCA3RXBUF;
    73aa:	5e 42 8c 06 	mov.b	&0x068c,r14	
    73ae:	c1 4e 00 00 	mov.b	r14,	0(r1)	;0x0000(r1)
			uart_A3.__on_rx_receive(c);
    73b2:	3f 40 7e 23 	mov	#9086,	r15	;#0x237e
    73b6:	b0 12 66 71 	call	#0x7166	
			break;
    73ba:	16 3c       	jmp	$+46     	;abs 0x73e8
		
		case 4:
			if( uart_A3.__on_tx_receive(&c))
    73bc:	0e 41       	mov	r1,	r14	
    73be:	3f 40 7e 23 	mov	#9086,	r15	;#0x237e
    73c2:	b0 12 ae 71 	call	#0x71ae	
    73c6:	4f 93       	tst.b	r15		
    73c8:	03 24       	jz	$+8      	;abs 0x73d0
			{
				// Bytes available to transmit
				UCA3TXBUF = c;
    73ca:	e2 41 8e 06 	mov.b	@r1,	&0x068e	
    73ce:	0c 3c       	jmp	$+26     	;abs 0x73e8
			}
			else
			{
				// No bytes available to transmit
				UCA3IE &= ~(UCTXIE);
    73d0:	5f 42 9c 06 	mov.b	&0x069c,r15	
    73d4:	7f f0 fd ff 	and.b	#-3,	r15	;#0xfffd
    73d8:	c2 4f 9c 06 	mov.b	r15,	&0x069c	
				UCA3IFG &= ~(UCTXIFG);
    73dc:	5f 42 9d 06 	mov.b	&0x069d,r15	
    73e0:	7f f0 fd ff 	and.b	#-3,	r15	;#0xfffd
    73e4:	c2 4f 9d 06 	mov.b	r15,	&0x069d	
		
		default:
			break;
		// Vector 4 - TXIFG
	}
}
    73e8:	21 53       	incd	r1		
    73ea:	3c 17       	popm	#4,	r15	
    73ec:	00 13       	reti			

000073ee <_Z20uart_A3_uninitializev>:
}

void uart_A3_uninitialize()
{
    float n, x;
    P10DIR = P10DIR | 1<<4;           //set P10.4=1 (Transmitter) as output
    73ee:	5f 42 85 02 	mov.b	&0x0285,r15	
    73f2:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    73f6:	c2 4f 85 02 	mov.b	r15,	&0x0285	
    P10DIR = P10DIR & ~(1<<5);        //set P10.5=0 (Receiver) as input
    73fa:	5f 42 85 02 	mov.b	&0x0285,r15	
    73fe:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    7402:	c2 4f 85 02 	mov.b	r15,	&0x0285	
    P10SEL = P10SEL | 1<<4 | 1<<5;    //set P10.4=1 & P10.5=1 as TX/RX
    7406:	5f 42 8b 02 	mov.b	&0x028b,r15	
    740a:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    740e:	c2 4f 8b 02 	mov.b	r15,	&0x028b	


    UCA3CTL1 = UCA3CTL1 | 0x01;     //UCSWRST = 1 (bit0 = 1)   //page 417
    7412:	5f 42 80 06 	mov.b	&0x0680,r15	
    7416:	5f d3       	bis.b	#1,	r15	;r3 As==01
    7418:	c2 4f 80 06 	mov.b	r15,	&0x0680	

    UCA3CTL1 = (UCA3CTL1 | 1<<7) & ~(1<<6);       //select SMCLK as BaudRate source clock (bit6 = 1; bit7 = 1)
    741c:	5f 42 80 06 	mov.b	&0x0680,r15	
    7420:	7f f0 3f 00 	and.b	#63,	r15	;#0x003f
    7424:	7f d0 80 ff 	bis.b	#-128,	r15	;#0xff80
    7428:	c2 4f 80 06 	mov.b	r15,	&0x0680	

    //calculate registers for the BaudRate +

    UCA3MCTL = UCA3MCTL | 0x01;       //UCOS16 = 1
    742c:	5f 42 88 06 	mov.b	&0x0688,r15	
    7430:	5f d3       	bis.b	#1,	r15	;r3 As==01
    7432:	c2 4f 88 06 	mov.b	r15,	&0x0688	
    //calculate UCBR
    n = configCPU_CLOCK_HZ  /DEFAULT_BAUDRATE;
    UCA3BR0 = (int)(n/16) % 256;
    7436:	f2 40 75 00 	mov.b	#117,	&0x0686	;#0x0075
    743a:	86 06 
    UCA3BR1 = (int)(n/16) / 256;
    743c:	c2 43 87 06 	mov.b	#0,	&0x0687	;r3 As==00

    //caluclate UCBRS
    x = (int)((n-(int)(n))*8+0.5);
    UCA3MCTL = UCA3MCTL | (int)(x)<<1;
    7440:	5f 42 88 06 	mov.b	&0x0688,r15	
    7444:	c2 4f 88 06 	mov.b	r15,	&0x0688	

    //caluclate UCBRF
    x = (int)(((n/16 - (int)(n/16))*16) + 0.5);
    UCA3MCTL = UCA3MCTL | (int)(x)<<4;
    7448:	5f 42 88 06 	mov.b	&0x0688,r15	
    744c:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    7450:	c2 4f 88 06 	mov.b	r15,	&0x0688	

    //calculate registers for the BaudRate -

    UCA3CTL0 = 0x00;                  //Set Format Frame: 8 bit data; no parity; 1 stop bit
    7454:	c2 43 81 06 	mov.b	#0,	&0x0681	;r3 As==00

    UCA3CTL1 = UCA3CTL1 & ~(0x01);    //UCSWRST = 0 (bit0 = 0) //page 417
    7458:	5f 42 80 06 	mov.b	&0x0680,r15	
    745c:	7f f0 fe ff 	and.b	#-2,	r15	;#0xfffe
    7460:	c2 4f 80 06 	mov.b	r15,	&0x0680	
}
    7464:	30 41       	ret			

00007466 <_Z18uart_A3_initializev>:
}


void uart_A3_initialize()
{
	uart_A3.enable_uart_interrupts = uart_A3_enable_uart_A3_interrupts;
    7466:	3f 40 88 24 	mov	#9352,	r15	;#0x2488
    746a:	bf 40 ee 71 	mov	#29166,	0(r15)	;#0x71ee, 0x0000(r15)
    746e:	00 00 
	uart_A3.disable_uart_interrupts = uart_A3_disable_uart_A3_interrupts;
    7470:	bf 40 fc 71 	mov	#29180,	2(r15)	;#0x71fc, 0x0002(r15)
    7474:	02 00 
	uart_A3.configure = uart_A3_configure;
    7476:	bf 40 0a 72 	mov	#29194,	-2(r15)	;#0x720a, 0xfffe(r15)
    747a:	fe ff 
	uart_A3.enable_tx = uart_A3_enable_uart_A3_tx;
    747c:	bf 40 64 73 	mov	#29540,	4(r15)	;#0x7364, 0x0004(r15)
    7480:	04 00 
	uart_A3.disable_tx = uart_A3_disable_uart_A3_tx;
    7482:	bf 40 7e 73 	mov	#29566,	6(r15)	;#0x737e, 0x0006(r15)
    7486:	06 00 
}
    7488:	30 41       	ret			

0000748a <_GLOBAL__sub_I_uart_A3>:

#include "uart_A3.hpp"

__UART__ uart_A3;
    748a:	3f 40 7e 23 	mov	#9086,	r15	;#0x237e
    748e:	b0 12 a6 6f 	call	#0x6fa6	
	uart_A3.enable_uart_interrupts = uart_A3_enable_uart_A3_interrupts;
	uart_A3.disable_uart_interrupts = uart_A3_disable_uart_A3_interrupts;
	uart_A3.configure = uart_A3_configure;
	uart_A3.enable_tx = uart_A3_enable_uart_A3_tx;
	uart_A3.disable_tx = uart_A3_disable_uart_A3_tx;
}
    7492:	30 41       	ret			

00007494 <memcpy>:
    7494:	4b 15       	pushm	#5,	r11	
    7496:	0d 93       	tst	r13		
    7498:	6d 24       	jz	$+220    	;abs 0x7574
    749a:	0f 9e       	cmp	r14,	r15	
    749c:	6b 24       	jz	$+216    	;abs 0x7574
    749e:	33 2c       	jc	$+104    	;abs 0x7506
    74a0:	0c 4e       	mov	r14,	r12	
    74a2:	0c df       	bis	r15,	r12	
    74a4:	1c f3       	and	#1,	r12	;r3 As==01
    74a6:	1b 24       	jz	$+56     	;abs 0x74de
    74a8:	0c 4e       	mov	r14,	r12	
    74aa:	0c ef       	xor	r15,	r12	
    74ac:	1c f3       	and	#1,	r12	;r3 As==01
    74ae:	07 20       	jnz	$+16     	;abs 0x74be
    74b0:	2d 93       	cmp	#2,	r13	;r3 As==10
    74b2:	07 28       	jnc	$+16     	;abs 0x74c2
    74b4:	0b 4e       	mov	r14,	r11	
    74b6:	1b f3       	and	#1,	r11	;r3 As==01
    74b8:	2c 43       	mov	#2,	r12	;r3 As==10
    74ba:	0c 8b       	sub	r11,	r12	
    74bc:	03 3c       	jmp	$+8      	;abs 0x74c4
    74be:	0c 4d       	mov	r13,	r12	
    74c0:	01 3c       	jmp	$+4      	;abs 0x74c4
    74c2:	1c 43       	mov	#1,	r12	;r3 As==01
    74c4:	0d 8c       	sub	r12,	r13	
    74c6:	0a 4c       	mov	r12,	r10	
    74c8:	09 4e       	mov	r14,	r9	
    74ca:	0b 4f       	mov	r15,	r11	
    74cc:	fb 49 00 00 	mov.b	@r9+,	0(r11)	;0x0000(r11)
    74d0:	1b 53       	inc	r11		
    74d2:	3a 53       	add	#-1,	r10	;r3 As==11
    74d4:	fb 23       	jnz	$-8      	;abs 0x74cc
    74d6:	0b 4f       	mov	r15,	r11	
    74d8:	0b 5c       	add	r12,	r11	
    74da:	0e 5c       	add	r12,	r14	
    74dc:	01 3c       	jmp	$+4      	;abs 0x74e0
    74de:	0b 4f       	mov	r15,	r11	
    74e0:	0c 4d       	mov	r13,	r12	
    74e2:	5c 03       	rrum	#1,	r12	
    74e4:	0b 24       	jz	$+24     	;abs 0x74fc
    74e6:	09 4c       	mov	r12,	r9	
    74e8:	08 4e       	mov	r14,	r8	
    74ea:	0a 4b       	mov	r11,	r10	
    74ec:	ba 48 00 00 	mov	@r8+,	0(r10)	;0x0000(r10)
    74f0:	2a 53       	incd	r10		
    74f2:	39 53       	add	#-1,	r9	;r3 As==11
    74f4:	fb 23       	jnz	$-8      	;abs 0x74ec
    74f6:	5c 02       	rlam	#1,	r12	
    74f8:	0e 5c       	add	r12,	r14	
    74fa:	0b 5c       	add	r12,	r11	
    74fc:	1d f3       	and	#1,	r13	;r3 As==01
    74fe:	3a 24       	jz	$+118    	;abs 0x7574
    7500:	eb 4e 00 00 	mov.b	@r14,	0(r11)	;0x0000(r11)
    7504:	37 3c       	jmp	$+112    	;abs 0x7574
    7506:	0e 5d       	add	r13,	r14	
    7508:	0c 4f       	mov	r15,	r12	
    750a:	0c 5d       	add	r13,	r12	
    750c:	0b 4c       	mov	r12,	r11	
    750e:	0b de       	bis	r14,	r11	
    7510:	1b f3       	and	#1,	r11	;r3 As==01
    7512:	1b 24       	jz	$+56     	;abs 0x754a
    7514:	0b 4c       	mov	r12,	r11	
    7516:	0b ee       	xor	r14,	r11	
    7518:	1b f3       	and	#1,	r11	;r3 As==01
    751a:	06 20       	jnz	$+14     	;abs 0x7528
    751c:	3d 90 03 00 	cmp	#3,	r13	;#0x0003
    7520:	03 28       	jnc	$+8      	;abs 0x7528
    7522:	0b 4e       	mov	r14,	r11	
    7524:	1b f3       	and	#1,	r11	;r3 As==01
    7526:	01 3c       	jmp	$+4      	;abs 0x752a
    7528:	0b 4d       	mov	r13,	r11	
    752a:	0d 8b       	sub	r11,	r13	
    752c:	09 4e       	mov	r14,	r9	
    752e:	0a 4c       	mov	r12,	r10	
    7530:	08 4b       	mov	r11,	r8	
    7532:	08 8c       	sub	r12,	r8	
    7534:	3a 53       	add	#-1,	r10	;r3 As==11
    7536:	39 53       	add	#-1,	r9	;r3 As==11
    7538:	ea 49 00 00 	mov.b	@r9,	0(r10)	;0x0000(r10)
    753c:	07 4a       	mov	r10,	r7	
    753e:	07 58       	add	r8,	r7	
    7540:	f9 23       	jnz	$-12     	;abs 0x7534
    7542:	3b e3       	inv	r11		
    7544:	1b 53       	inc	r11		
    7546:	0c 5b       	add	r11,	r12	
    7548:	0e 5b       	add	r11,	r14	
    754a:	0a 4d       	mov	r13,	r10	
    754c:	5a 03       	rrum	#1,	r10	
    754e:	0d 24       	jz	$+28     	;abs 0x756a
    7550:	0b 4a       	mov	r10,	r11	
    7552:	08 4e       	mov	r14,	r8	
    7554:	09 4c       	mov	r12,	r9	
    7556:	28 83       	decd	r8		
    7558:	29 83       	decd	r9		
    755a:	a9 48 00 00 	mov	@r8,	0(r9)	;0x0000(r9)
    755e:	3b 53       	add	#-1,	r11	;r3 As==11
    7560:	fa 23       	jnz	$-10     	;abs 0x7556
    7562:	0b 8a       	sub	r10,	r11	
    7564:	5b 02       	rlam	#1,	r11	
    7566:	0e 5b       	add	r11,	r14	
    7568:	0c 5b       	add	r11,	r12	
    756a:	1d f3       	and	#1,	r13	;r3 As==01
    756c:	03 24       	jz	$+8      	;abs 0x7574
    756e:	dc 4e ff ff 	mov.b	-1(r14),-1(r12)	;0xffff(r14), 0xffff(r12)
    7572:	ff ff 
    7574:	47 17       	popm	#5,	r11	
    7576:	30 41       	ret			

00007578 <memset>:
    7578:	3b 15       	pushm	#4,	r11	
    757a:	3d 90 06 00 	cmp	#6,	r13	;#0x0006
    757e:	09 2c       	jc	$+20     	;abs 0x7592
    7580:	0c 4f       	mov	r15,	r12	
    7582:	04 3c       	jmp	$+10     	;abs 0x758c
    7584:	cc 4e 00 00 	mov.b	r14,	0(r12)	;0x0000(r12)
    7588:	1c 53       	inc	r12		
    758a:	3d 53       	add	#-1,	r13	;r3 As==11
    758c:	0d 93       	tst	r13		
    758e:	fa 23       	jnz	$-10     	;abs 0x7584
    7590:	1f 3c       	jmp	$+64     	;abs 0x75d0
    7592:	4e 4e       	mov.b	r14,	r14	
    7594:	4b 4e       	mov.b	r14,	r11	
    7596:	0b 93       	tst	r11		
    7598:	03 24       	jz	$+8      	;abs 0x75a0
    759a:	0c 4b       	mov	r11,	r12	
    759c:	8c 10       	swpb	r12		
    759e:	0b dc       	bis	r12,	r11	
    75a0:	1f b3       	bit	#1,	r15	;r3 As==01
    75a2:	06 24       	jz	$+14     	;abs 0x75b0
    75a4:	3d 53       	add	#-1,	r13	;r3 As==11
    75a6:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    75aa:	09 4f       	mov	r15,	r9	
    75ac:	19 53       	inc	r9		
    75ae:	01 3c       	jmp	$+4      	;abs 0x75b2
    75b0:	09 4f       	mov	r15,	r9	
    75b2:	0c 4d       	mov	r13,	r12	
    75b4:	5c 03       	rrum	#1,	r12	
    75b6:	0a 49       	mov	r9,	r10	
    75b8:	08 4c       	mov	r12,	r8	
    75ba:	8a 4b 00 00 	mov	r11,	0(r10)	;0x0000(r10)
    75be:	2a 53       	incd	r10		
    75c0:	38 53       	add	#-1,	r8	;r3 As==11
    75c2:	fb 23       	jnz	$-8      	;abs 0x75ba
    75c4:	5c 02       	rlam	#1,	r12	
    75c6:	0c 59       	add	r9,	r12	
    75c8:	1d f3       	and	#1,	r13	;r3 As==01
    75ca:	02 24       	jz	$+6      	;abs 0x75d0
    75cc:	cc 4e 00 00 	mov.b	r14,	0(r12)	;0x0000(r12)
    75d0:	38 17       	popm	#4,	r11	
    75d2:	30 41       	ret			

000075d4 <rand_r>:
    75d4:	0b 12       	push	r11		
    75d6:	0b 4f       	mov	r15,	r11	
    75d8:	3c 40 6d 4e 	mov	#20077,	r12	;#0x4e6d
    75dc:	3d 40 c6 41 	mov	#16838,	r13	;#0x41c6
    75e0:	2e 4f       	mov	@r15,	r14	
    75e2:	0f 43       	clr	r15		
    75e4:	b0 12 28 76 	call	#0x7628	
    75e8:	3e 50 39 30 	add	#12345,	r14	;#0x3039
    75ec:	0f 63       	adc	r15		
    75ee:	8b 4e 00 00 	mov	r14,	0(r11)	;0x0000(r11)
    75f2:	0f 4e       	mov	r14,	r15	
    75f4:	3b 41       	pop	r11		
    75f6:	30 41       	ret			

000075f8 <rand>:
    75f8:	3c 40 6d 4e 	mov	#20077,	r12	;#0x4e6d
    75fc:	3d 40 c6 41 	mov	#16838,	r13	;#0x41c6
    7600:	1e 42 04 1c 	mov	&0x1c04,r14	
    7604:	1f 42 06 1c 	mov	&0x1c06,r15	
    7608:	b0 12 28 76 	call	#0x7628	
    760c:	3e 50 39 30 	add	#12345,	r14	;#0x3039
    7610:	0f 63       	adc	r15		
    7612:	82 4e 04 1c 	mov	r14,	&0x1c04	
    7616:	82 4f 06 1c 	mov	r15,	&0x1c06	
    761a:	0f 4e       	mov	r14,	r15	
    761c:	30 41       	ret			

0000761e <srand>:
    761e:	82 4f 04 1c 	mov	r15,	&0x1c04	
    7622:	82 43 06 1c 	mov	#0,	&0x1c06	;r3 As==00
    7626:	30 41       	ret			

00007628 <__mulsi3>:
    7628:	0b 12       	push	r11		
    762a:	0a 12       	push	r10		
    762c:	0b 43       	clr	r11		
    762e:	0a 43       	clr	r10		
    7630:	07 3c       	jmp	$+16     	;abs 0x7640
    7632:	5d 03       	rrum	#1,	r13	
    7634:	0c 10       	rrc	r12		
    7636:	02 28       	jnc	$+6      	;abs 0x763c
    7638:	0a 5e       	add	r14,	r10	
    763a:	0b 6f       	addc	r15,	r11	
    763c:	0e 5e       	rla	r14		
    763e:	0f 6f       	rlc	r15		
    7640:	0c 93       	tst	r12		
    7642:	f7 23       	jnz	$-16     	;abs 0x7632
    7644:	0d 93       	tst	r13		
    7646:	f5 23       	jnz	$-20     	;abs 0x7632
    7648:	0e 4a       	mov	r10,	r14	
    764a:	0f 4b       	mov	r11,	r15	
    764c:	3a 41       	pop	r10		
    764e:	3b 41       	pop	r11		
    7650:	30 41       	ret			

00007652 <__udivsi3>:
    7652:	2b 15       	pushm	#3,	r11	
    7654:	79 40 20 00 	mov.b	#32,	r9	;#0x0020
    7658:	0a 4c       	mov	r12,	r10	
    765a:	0b 4d       	mov	r13,	r11	
    765c:	0c 43       	clr	r12		
    765e:	0d 43       	clr	r13		
    7660:	0e 5e       	rla	r14		
    7662:	0f 6f       	rlc	r15		
    7664:	0c 6c       	rlc	r12		
    7666:	0d 6d       	rlc	r13		
    7668:	0d 9b       	cmp	r11,	r13	
    766a:	06 28       	jnc	$+14     	;abs 0x7678
    766c:	02 20       	jnz	$+6      	;abs 0x7672
    766e:	0c 9a       	cmp	r10,	r12	
    7670:	03 28       	jnc	$+8      	;abs 0x7678
    7672:	0c 8a       	sub	r10,	r12	
    7674:	0d 7b       	subc	r11,	r13	
    7676:	1e d3       	bis	#1,	r14	;r3 As==01
    7678:	19 83       	dec	r9		
    767a:	f2 23       	jnz	$-26     	;abs 0x7660
    767c:	29 17       	popm	#3,	r11	
    767e:	30 41       	ret			

00007680 <__umodsi3>:
    7680:	b0 12 52 76 	call	#0x7652	
    7684:	0e 4c       	mov	r12,	r14	
    7686:	0f 4d       	mov	r13,	r15	
    7688:	30 41       	ret			

0000768a <_fpadd_parts>:
    768a:	7b 15       	pushm	#8,	r11	
    768c:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    7690:	08 4d       	mov	r13,	r8	
    7692:	6b 4f       	mov.b	@r15,	r11	
    7694:	6b 93       	cmp.b	#2,	r11	;r3 As==10
    7696:	67 28       	jnc	$+208    	;abs 0x7766
    7698:	6c 4e       	mov.b	@r14,	r12	
    769a:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    769c:	e2 28       	jnc	$+454    	;abs 0x7862
    769e:	6b 92       	cmp.b	#4,	r11	;r2 As==10
    76a0:	02 20       	jnz	$+6      	;abs 0x76a6
    76a2:	30 40 f4 78 	br	#0x78f4	
    76a6:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    76a8:	dc 24       	jz	$+442    	;abs 0x7862
    76aa:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    76ac:	b4 24       	jz	$+362    	;abs 0x7816
    76ae:	6b 93       	cmp.b	#2,	r11	;r3 As==10
    76b0:	d8 24       	jz	$+434    	;abs 0x7862
    76b2:	91 4f 02 00 	mov	2(r15),	0(r1)	;0x0002(r15), 0x0000(r1)
    76b6:	00 00 
    76b8:	1b 4e 02 00 	mov	2(r14),	r11	;0x0002(r14)
    76bc:	14 4f 04 00 	mov	4(r15),	r4	;0x0004(r15)
    76c0:	15 4f 06 00 	mov	6(r15),	r5	;0x0006(r15)
    76c4:	16 4e 04 00 	mov	4(r14),	r6	;0x0004(r14)
    76c8:	17 4e 06 00 	mov	6(r14),	r7	;0x0006(r14)
    76cc:	2c 41       	mov	@r1,	r12	
    76ce:	0c 8b       	sub	r11,	r12	
    76d0:	09 4c       	mov	r12,	r9	
    76d2:	0c 93       	tst	r12		
    76d4:	b8 38       	jl	$+370    	;abs 0x7846
    76d6:	39 90 20 00 	cmp	#32,	r9	;#0x0020
    76da:	49 34       	jge	$+148    	;abs 0x776e
    76dc:	1c 93       	cmp	#1,	r12	;r3 As==01
    76de:	d3 38       	jl	$+424    	;abs 0x7886
    76e0:	81 46 02 00 	mov	r6,	2(r1)	;0x0002(r1)
    76e4:	81 47 04 00 	mov	r7,	4(r1)	;0x0004(r1)
    76e8:	4c 49       	mov.b	r9,	r12	
    76ea:	7c f0 1f 00 	and.b	#31,	r12	;#0x001f
    76ee:	0b 24       	jz	$+24     	;abs 0x7706
    76f0:	0a 46       	mov	r6,	r10	
    76f2:	0b 47       	mov	r7,	r11	
    76f4:	12 c3       	clrc			
    76f6:	0b 10       	rrc	r11		
    76f8:	0a 10       	rrc	r10		
    76fa:	7c 53       	add.b	#-1,	r12	;r3 As==11
    76fc:	fb 23       	jnz	$-8      	;abs 0x76f4
    76fe:	81 4a 02 00 	mov	r10,	2(r1)	;0x0002(r1)
    7702:	81 4b 04 00 	mov	r11,	4(r1)	;0x0004(r1)
    7706:	1c 43       	mov	#1,	r12	;r3 As==01
    7708:	0d 43       	clr	r13		
    770a:	79 f0 1f 00 	and.b	#31,	r9	;#0x001f
    770e:	04 24       	jz	$+10     	;abs 0x7718
    7710:	0c 5c       	rla	r12		
    7712:	0d 6d       	rlc	r13		
    7714:	79 53       	add.b	#-1,	r9	;r3 As==11
    7716:	fc 23       	jnz	$-6      	;abs 0x7710
    7718:	3c 53       	add	#-1,	r12	;r3 As==11
    771a:	3d 63       	addc	#-1,	r13	;r3 As==11
    771c:	0c f6       	and	r6,	r12	
    771e:	0d f7       	and	r7,	r13	
    7720:	1a 43       	mov	#1,	r10	;r3 As==01
    7722:	0b 43       	clr	r11		
    7724:	0c 93       	tst	r12		
    7726:	02 20       	jnz	$+6      	;abs 0x772c
    7728:	0d 93       	tst	r13		
    772a:	e1 24       	jz	$+452    	;abs 0x78ee
    772c:	16 41 02 00 	mov	2(r1),	r6	;0x0002(r1)
    7730:	17 41 04 00 	mov	4(r1),	r7	;0x0004(r1)
    7734:	06 da       	bis	r10,	r6	
    7736:	07 db       	bis	r11,	r7	
    7738:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    773c:	5f 9e 01 00 	cmp.b	1(r14),	r15	;0x0001(r14)
    7740:	21 20       	jnz	$+68     	;abs 0x7784
    7742:	c8 4f 01 00 	mov.b	r15,	1(r8)	;0x0001(r8)
    7746:	a8 41 02 00 	mov	@r1,	2(r8)	;0x0002(r8)
    774a:	0e 46       	mov	r6,	r14	
    774c:	0f 47       	mov	r7,	r15	
    774e:	0e 54       	add	r4,	r14	
    7750:	0f 65       	addc	r5,	r15	
    7752:	88 4e 04 00 	mov	r14,	4(r8)	;0x0004(r8)
    7756:	88 4f 06 00 	mov	r15,	6(r8)	;0x0006(r8)
    775a:	f8 40 03 00 	mov.b	#3,	0(r8)	;#0x0003, 0x0000(r8)
    775e:	00 00 
    7760:	0f 93       	tst	r15		
    7762:	46 38       	jl	$+142    	;abs 0x77f0
    7764:	0f 48       	mov	r8,	r15	
    7766:	31 50 06 00 	add	#6,	r1	;#0x0006
    776a:	74 17       	popm	#8,	r11	
    776c:	30 41       	ret			
    776e:	2b 91       	cmp	@r1,	r11	
    7770:	67 38       	jl	$+208    	;abs 0x7840
    7772:	81 4b 00 00 	mov	r11,	0(r1)	;0x0000(r1)
    7776:	04 43       	clr	r4		
    7778:	05 43       	clr	r5		
    777a:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    777e:	5f 9e 01 00 	cmp.b	1(r14),	r15	;0x0001(r14)
    7782:	df 27       	jz	$-64     	;abs 0x7742
    7784:	4f 93       	tst.b	r15		
    7786:	68 24       	jz	$+210    	;abs 0x7858
    7788:	0e 46       	mov	r6,	r14	
    778a:	0f 47       	mov	r7,	r15	
    778c:	0e 84       	sub	r4,	r14	
    778e:	0f 75       	subc	r5,	r15	
    7790:	0f 93       	tst	r15		
    7792:	6c 38       	jl	$+218    	;abs 0x786c
    7794:	c8 43 01 00 	mov.b	#0,	1(r8)	;r3 As==00, 0x0001(r8)
    7798:	a8 41 02 00 	mov	@r1,	2(r8)	;0x0002(r8)
    779c:	88 4e 04 00 	mov	r14,	4(r8)	;0x0004(r8)
    77a0:	88 4f 06 00 	mov	r15,	6(r8)	;0x0006(r8)
    77a4:	0c 4e       	mov	r14,	r12	
    77a6:	0d 4f       	mov	r15,	r13	
    77a8:	3c 53       	add	#-1,	r12	;r3 As==11
    77aa:	3d 63       	addc	#-1,	r13	;r3 As==11
    77ac:	3d 90 ff 3f 	cmp	#16383,	r13	;#0x3fff
    77b0:	05 28       	jnc	$+12     	;abs 0x77bc
    77b2:	3d 90 00 40 	cmp	#16384,	r13	;#0x4000
    77b6:	17 2c       	jc	$+48     	;abs 0x77e6
    77b8:	3c 93       	cmp	#-1,	r12	;r3 As==11
    77ba:	15 2c       	jc	$+44     	;abs 0x77e6
    77bc:	1b 48 02 00 	mov	2(r8),	r11	;0x0002(r8)
    77c0:	3b 53       	add	#-1,	r11	;r3 As==11
    77c2:	0e 5e       	rla	r14		
    77c4:	0f 6f       	rlc	r15		
    77c6:	0a 4b       	mov	r11,	r10	
    77c8:	3b 53       	add	#-1,	r11	;r3 As==11
    77ca:	0c 4e       	mov	r14,	r12	
    77cc:	0d 4f       	mov	r15,	r13	
    77ce:	3c 53       	add	#-1,	r12	;r3 As==11
    77d0:	3d 63       	addc	#-1,	r13	;r3 As==11
    77d2:	3d 90 ff 3f 	cmp	#16383,	r13	;#0x3fff
    77d6:	f5 2b       	jnc	$-20     	;abs 0x77c2
    77d8:	3c 24       	jz	$+122    	;abs 0x7852
    77da:	88 4e 04 00 	mov	r14,	4(r8)	;0x0004(r8)
    77de:	88 4f 06 00 	mov	r15,	6(r8)	;0x0006(r8)
    77e2:	88 4a 02 00 	mov	r10,	2(r8)	;0x0002(r8)
    77e6:	f8 40 03 00 	mov.b	#3,	0(r8)	;#0x0003, 0x0000(r8)
    77ea:	00 00 
    77ec:	0f 93       	tst	r15		
    77ee:	ba 37       	jge	$-138    	;abs 0x7764
    77f0:	0c 4e       	mov	r14,	r12	
    77f2:	0d 4f       	mov	r15,	r13	
    77f4:	1c f3       	and	#1,	r12	;r3 As==01
    77f6:	0d f3       	and	#0,	r13	;r3 As==00
    77f8:	12 c3       	clrc			
    77fa:	0f 10       	rrc	r15		
    77fc:	0e 10       	rrc	r14		
    77fe:	0a 4c       	mov	r12,	r10	
    7800:	0b 4d       	mov	r13,	r11	
    7802:	0a de       	bis	r14,	r10	
    7804:	0b df       	bis	r15,	r11	
    7806:	88 4a 04 00 	mov	r10,	4(r8)	;0x0004(r8)
    780a:	88 4b 06 00 	mov	r11,	6(r8)	;0x0006(r8)
    780e:	98 53 02 00 	inc	2(r8)		;0x0002(r8)
    7812:	0f 48       	mov	r8,	r15	
    7814:	a8 3f       	jmp	$-174    	;abs 0x7766
    7816:	6b 93       	cmp.b	#2,	r11	;r3 As==10
    7818:	a6 23       	jnz	$-178    	;abs 0x7766
    781a:	ad 4f 00 00 	mov	@r15,	0(r13)	;0x0000(r13)
    781e:	9d 4f 02 00 	mov	2(r15),	2(r13)	;0x0002(r15), 0x0002(r13)
    7822:	02 00 
    7824:	9d 4f 04 00 	mov	4(r15),	4(r13)	;0x0004(r15), 0x0004(r13)
    7828:	04 00 
    782a:	9d 4f 06 00 	mov	6(r15),	6(r13)	;0x0006(r15), 0x0006(r13)
    782e:	06 00 
    7830:	5e 4e 01 00 	mov.b	1(r14),	r14	;0x0001(r14)
    7834:	5e ff 01 00 	and.b	1(r15),	r14	;0x0001(r15)
    7838:	cd 4e 01 00 	mov.b	r14,	1(r13)	;0x0001(r13)
    783c:	0f 4d       	mov	r13,	r15	
    783e:	93 3f       	jmp	$-216    	;abs 0x7766
    7840:	06 43       	clr	r6		
    7842:	07 43       	clr	r7		
    7844:	9a 3f       	jmp	$-202    	;abs 0x777a
    7846:	39 e3       	inv	r9		
    7848:	19 53       	inc	r9		
    784a:	39 90 20 00 	cmp	#32,	r9	;#0x0020
    784e:	8f 37       	jge	$-224    	;abs 0x776e
    7850:	45 3f       	jmp	$-372    	;abs 0x76dc
    7852:	3c 93       	cmp	#-1,	r12	;r3 As==11
    7854:	b6 2b       	jnc	$-146    	;abs 0x77c2
    7856:	c1 3f       	jmp	$-124    	;abs 0x77da
    7858:	0e 44       	mov	r4,	r14	
    785a:	0f 45       	mov	r5,	r15	
    785c:	0e 86       	sub	r6,	r14	
    785e:	0f 77       	subc	r7,	r15	
    7860:	97 3f       	jmp	$-208    	;abs 0x7790
    7862:	0f 4e       	mov	r14,	r15	
    7864:	31 50 06 00 	add	#6,	r1	;#0x0006
    7868:	74 17       	popm	#8,	r11	
    786a:	30 41       	ret			
    786c:	d8 43 01 00 	mov.b	#1,	1(r8)	;r3 As==01, 0x0001(r8)
    7870:	a8 41 02 00 	mov	@r1,	2(r8)	;0x0002(r8)
    7874:	3e e3       	inv	r14		
    7876:	3f e3       	inv	r15		
    7878:	1e 53       	inc	r14		
    787a:	0f 63       	adc	r15		
    787c:	88 4e 04 00 	mov	r14,	4(r8)	;0x0004(r8)
    7880:	88 4f 06 00 	mov	r15,	6(r8)	;0x0006(r8)
    7884:	8f 3f       	jmp	$-224    	;abs 0x77a4
    7886:	0c 93       	tst	r12		
    7888:	78 27       	jz	$-270    	;abs 0x777a
    788a:	81 59 00 00 	add	r9,	0(r1)	;0x0000(r1)
    788e:	81 44 02 00 	mov	r4,	2(r1)	;0x0002(r1)
    7892:	81 45 04 00 	mov	r5,	4(r1)	;0x0004(r1)
    7896:	4d 49       	mov.b	r9,	r13	
    7898:	7d f0 1f 00 	and.b	#31,	r13	;#0x001f
    789c:	0c 24       	jz	$+26     	;abs 0x78b6
    789e:	4b 4d       	mov.b	r13,	r11	
    78a0:	0c 44       	mov	r4,	r12	
    78a2:	0d 45       	mov	r5,	r13	
    78a4:	12 c3       	clrc			
    78a6:	0d 10       	rrc	r13		
    78a8:	0c 10       	rrc	r12		
    78aa:	7b 53       	add.b	#-1,	r11	;r3 As==11
    78ac:	fb 23       	jnz	$-8      	;abs 0x78a4
    78ae:	81 4c 02 00 	mov	r12,	2(r1)	;0x0002(r1)
    78b2:	81 4d 04 00 	mov	r13,	4(r1)	;0x0004(r1)
    78b6:	1c 43       	mov	#1,	r12	;r3 As==01
    78b8:	0d 43       	clr	r13		
    78ba:	79 f0 1f 00 	and.b	#31,	r9	;#0x001f
    78be:	04 24       	jz	$+10     	;abs 0x78c8
    78c0:	0c 5c       	rla	r12		
    78c2:	0d 6d       	rlc	r13		
    78c4:	79 53       	add.b	#-1,	r9	;r3 As==11
    78c6:	fc 23       	jnz	$-6      	;abs 0x78c0
    78c8:	3c 53       	add	#-1,	r12	;r3 As==11
    78ca:	3d 63       	addc	#-1,	r13	;r3 As==11
    78cc:	0c f4       	and	r4,	r12	
    78ce:	0d f5       	and	r5,	r13	
    78d0:	1a 43       	mov	#1,	r10	;r3 As==01
    78d2:	0b 43       	clr	r11		
    78d4:	0c 93       	tst	r12		
    78d6:	04 20       	jnz	$+10     	;abs 0x78e0
    78d8:	0d 93       	tst	r13		
    78da:	02 20       	jnz	$+6      	;abs 0x78e0
    78dc:	0a 43       	clr	r10		
    78de:	0b 43       	clr	r11		
    78e0:	14 41 02 00 	mov	2(r1),	r4	;0x0002(r1)
    78e4:	15 41 04 00 	mov	4(r1),	r5	;0x0004(r1)
    78e8:	04 da       	bis	r10,	r4	
    78ea:	05 db       	bis	r11,	r5	
    78ec:	46 3f       	jmp	$-370    	;abs 0x777a
    78ee:	0a 43       	clr	r10		
    78f0:	0b 43       	clr	r11		
    78f2:	1c 3f       	jmp	$-454    	;abs 0x772c
    78f4:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    78f6:	37 23       	jnz	$-400    	;abs 0x7766
    78f8:	df 9e 01 00 	cmp.b	1(r14),	1(r15)	;0x0001(r14), 0x0001(r15)
    78fc:	01 00 
    78fe:	33 27       	jz	$-408    	;abs 0x7766
    7900:	3f 40 24 81 	mov	#-32476,r15	;#0x8124
    7904:	30 3f       	jmp	$-414    	;abs 0x7766

00007906 <__addsf3>:
    7906:	31 50 e0 ff 	add	#-32,	r1	;#0xffe0
    790a:	81 4e 04 00 	mov	r14,	4(r1)	;0x0004(r1)
    790e:	81 4f 06 00 	mov	r15,	6(r1)	;0x0006(r1)
    7912:	81 4c 00 00 	mov	r12,	0(r1)	;0x0000(r1)
    7916:	81 4d 02 00 	mov	r13,	2(r1)	;0x0002(r1)
    791a:	0e 41       	mov	r1,	r14	
    791c:	3e 50 18 00 	add	#24,	r14	;#0x0018
    7920:	0f 41       	mov	r1,	r15	
    7922:	2f 52       	add	#4,	r15	;r2 As==10
    7924:	b0 12 02 80 	call	#0x8002	
    7928:	0e 41       	mov	r1,	r14	
    792a:	3e 50 10 00 	add	#16,	r14	;#0x0010
    792e:	0f 41       	mov	r1,	r15	
    7930:	b0 12 02 80 	call	#0x8002	
    7934:	0d 41       	mov	r1,	r13	
    7936:	3d 52       	add	#8,	r13	;r2 As==11
    7938:	0e 41       	mov	r1,	r14	
    793a:	3e 50 10 00 	add	#16,	r14	;#0x0010
    793e:	0f 41       	mov	r1,	r15	
    7940:	3f 50 18 00 	add	#24,	r15	;#0x0018
    7944:	b0 12 8a 76 	call	#0x768a	
    7948:	b0 12 3c 7e 	call	#0x7e3c	
    794c:	31 50 20 00 	add	#32,	r1	;#0x0020
    7950:	30 41       	ret			

00007952 <__subsf3>:
    7952:	31 50 e0 ff 	add	#-32,	r1	;#0xffe0
    7956:	81 4e 04 00 	mov	r14,	4(r1)	;0x0004(r1)
    795a:	81 4f 06 00 	mov	r15,	6(r1)	;0x0006(r1)
    795e:	81 4c 00 00 	mov	r12,	0(r1)	;0x0000(r1)
    7962:	81 4d 02 00 	mov	r13,	2(r1)	;0x0002(r1)
    7966:	0e 41       	mov	r1,	r14	
    7968:	3e 50 18 00 	add	#24,	r14	;#0x0018
    796c:	0f 41       	mov	r1,	r15	
    796e:	2f 52       	add	#4,	r15	;r2 As==10
    7970:	b0 12 02 80 	call	#0x8002	
    7974:	0e 41       	mov	r1,	r14	
    7976:	3e 50 10 00 	add	#16,	r14	;#0x0010
    797a:	0f 41       	mov	r1,	r15	
    797c:	b0 12 02 80 	call	#0x8002	
    7980:	d1 e3 11 00 	xor.b	#1,	17(r1)	;r3 As==01, 0x0011(r1)
    7984:	0d 41       	mov	r1,	r13	
    7986:	3d 52       	add	#8,	r13	;r2 As==11
    7988:	0e 41       	mov	r1,	r14	
    798a:	3e 50 10 00 	add	#16,	r14	;#0x0010
    798e:	0f 41       	mov	r1,	r15	
    7990:	3f 50 18 00 	add	#24,	r15	;#0x0018
    7994:	b0 12 8a 76 	call	#0x768a	
    7998:	b0 12 3c 7e 	call	#0x7e3c	
    799c:	31 50 20 00 	add	#32,	r1	;#0x0020
    79a0:	30 41       	ret			

000079a2 <__mulsf3>:
    79a2:	7b 15       	pushm	#8,	r11	
    79a4:	31 50 dc ff 	add	#-36,	r1	;#0xffdc
    79a8:	81 4e 04 00 	mov	r14,	4(r1)	;0x0004(r1)
    79ac:	81 4f 06 00 	mov	r15,	6(r1)	;0x0006(r1)
    79b0:	81 4c 00 00 	mov	r12,	0(r1)	;0x0000(r1)
    79b4:	81 4d 02 00 	mov	r13,	2(r1)	;0x0002(r1)
    79b8:	0e 41       	mov	r1,	r14	
    79ba:	3e 50 18 00 	add	#24,	r14	;#0x0018
    79be:	0f 41       	mov	r1,	r15	
    79c0:	2f 52       	add	#4,	r15	;r2 As==10
    79c2:	b0 12 02 80 	call	#0x8002	
    79c6:	0e 41       	mov	r1,	r14	
    79c8:	3e 50 10 00 	add	#16,	r14	;#0x0010
    79cc:	0f 41       	mov	r1,	r15	
    79ce:	b0 12 02 80 	call	#0x8002	
    79d2:	5f 41 18 00 	mov.b	24(r1),	r15	;0x0018(r1)
    79d6:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    79d8:	b0 28       	jnc	$+354    	;abs 0x7b3a
    79da:	5e 41 10 00 	mov.b	16(r1),	r14	;0x0010(r1)
    79de:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    79e0:	d8 28       	jnc	$+434    	;abs 0x7b92
    79e2:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    79e4:	a8 24       	jz	$+338    	;abs 0x7b36
    79e6:	6e 92       	cmp.b	#4,	r14	;r2 As==10
    79e8:	e6 24       	jz	$+462    	;abs 0x7bb6
    79ea:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    79ec:	a6 24       	jz	$+334    	;abs 0x7b3a
    79ee:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    79f0:	d0 24       	jz	$+418    	;abs 0x7b92
    79f2:	14 41 1c 00 	mov	28(r1),	r4	;0x001c(r1)
    79f6:	15 41 1e 00 	mov	30(r1),	r5	;0x001e(r1)
    79fa:	18 41 14 00 	mov	20(r1),	r8	;0x0014(r1)
    79fe:	19 41 16 00 	mov	22(r1),	r9	;0x0016(r1)
    7a02:	3c 40 20 00 	mov	#32,	r12	;#0x0020
    7a06:	0e 43       	clr	r14		
    7a08:	0f 43       	clr	r15		
    7a0a:	06 43       	clr	r6		
    7a0c:	07 43       	clr	r7		
    7a0e:	81 43 20 00 	mov	#0,	32(r1)	;r3 As==00, 0x0020(r1)
    7a12:	81 43 22 00 	mov	#0,	34(r1)	;r3 As==00, 0x0022(r1)
    7a16:	0a 43       	clr	r10		
    7a18:	0b 43       	clr	r11		
    7a1a:	81 4c 20 00 	mov	r12,	32(r1)	;0x0020(r1)
    7a1e:	08 3c       	jmp	$+18     	;abs 0x7a30
    7a20:	08 58       	rla	r8		
    7a22:	09 69       	rlc	r9		
    7a24:	12 c3       	clrc			
    7a26:	05 10       	rrc	r5		
    7a28:	04 10       	rrc	r4		
    7a2a:	b1 53 20 00 	add	#-1,	32(r1)	;r3 As==11, 0x0020(r1)
    7a2e:	19 24       	jz	$+52     	;abs 0x7a62
    7a30:	14 b3       	bit	#1,	r4	;r3 As==01
    7a32:	0d 24       	jz	$+28     	;abs 0x7a4e
    7a34:	0a 58       	add	r8,	r10	
    7a36:	0b 69       	addc	r9,	r11	
    7a38:	0e 56       	add	r6,	r14	
    7a3a:	0f 67       	addc	r7,	r15	
    7a3c:	1c 43       	mov	#1,	r12	;r3 As==01
    7a3e:	0d 43       	clr	r13		
    7a40:	0b 99       	cmp	r9,	r11	
    7a42:	03 28       	jnc	$+8      	;abs 0x7a4a
    7a44:	0b 24       	jz	$+24     	;abs 0x7a5c
    7a46:	0c 43       	clr	r12		
    7a48:	0d 43       	clr	r13		
    7a4a:	0e 5c       	add	r12,	r14	
    7a4c:	0f 6d       	addc	r13,	r15	
    7a4e:	06 56       	rla	r6		
    7a50:	07 67       	rlc	r7		
    7a52:	09 93       	tst	r9		
    7a54:	e5 37       	jge	$-52     	;abs 0x7a20
    7a56:	16 d3       	bis	#1,	r6	;r3 As==01
    7a58:	07 d3       	bis	#0,	r7	;r3 As==00
    7a5a:	e2 3f       	jmp	$-58     	;abs 0x7a20
    7a5c:	0a 98       	cmp	r8,	r10	
    7a5e:	f5 2b       	jnc	$-20     	;abs 0x7a4a
    7a60:	f2 3f       	jmp	$-26     	;abs 0x7a46
    7a62:	81 4a 20 00 	mov	r10,	32(r1)	;0x0020(r1)
    7a66:	81 4b 22 00 	mov	r11,	34(r1)	;0x0022(r1)
    7a6a:	0c 4f       	mov	r15,	r12	
    7a6c:	1a 41 1a 00 	mov	26(r1),	r10	;0x001a(r1)
    7a70:	1a 51 12 00 	add	18(r1),	r10	;0x0012(r1)
    7a74:	06 4a       	mov	r10,	r6	
    7a76:	26 53       	incd	r6		
    7a78:	81 46 0a 00 	mov	r6,	10(r1)	;0x000a(r1)
    7a7c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7a7e:	d1 91 11 00 	cmp.b	17(r1),	25(r1)	;0x0011(r1), 0x0019(r1)
    7a82:	19 00 
    7a84:	82 24       	jz	$+262    	;abs 0x7b8a
    7a86:	c1 4d 09 00 	mov.b	r13,	9(r1)	;0x0009(r1)
    7a8a:	0c 93       	tst	r12		
    7a8c:	35 38       	jl	$+108    	;abs 0x7af8
    7a8e:	3f 90 00 40 	cmp	#16384,	r15	;#0x4000
    7a92:	18 2c       	jc	$+50     	;abs 0x7ac4
    7a94:	1d 41 0a 00 	mov	10(r1),	r13	;0x000a(r1)
    7a98:	3d 53       	add	#-1,	r13	;r3 As==11
    7a9a:	1a 41 20 00 	mov	32(r1),	r10	;0x0020(r1)
    7a9e:	1b 41 22 00 	mov	34(r1),	r11	;0x0022(r1)
    7aa2:	0c 4d       	mov	r13,	r12	
    7aa4:	0e 5e       	rla	r14		
    7aa6:	0f 6f       	rlc	r15		
    7aa8:	0b 93       	tst	r11		
    7aaa:	23 38       	jl	$+72     	;abs 0x7af2
    7aac:	0a 5a       	rla	r10		
    7aae:	0b 6b       	rlc	r11		
    7ab0:	3d 53       	add	#-1,	r13	;r3 As==11
    7ab2:	3f 90 00 40 	cmp	#16384,	r15	;#0x4000
    7ab6:	f5 2b       	jnc	$-20     	;abs 0x7aa2
    7ab8:	81 4a 20 00 	mov	r10,	32(r1)	;0x0020(r1)
    7abc:	81 4b 22 00 	mov	r11,	34(r1)	;0x0022(r1)
    7ac0:	81 4c 0a 00 	mov	r12,	10(r1)	;0x000a(r1)
    7ac4:	0c 4e       	mov	r14,	r12	
    7ac6:	0d 4f       	mov	r15,	r13	
    7ac8:	3c f0 7f 00 	and	#127,	r12	;#0x007f
    7acc:	0d f3       	and	#0,	r13	;r3 As==00
    7ace:	3c 90 40 00 	cmp	#64,	r12	;#0x0040
    7ad2:	43 24       	jz	$+136    	;abs 0x7b5a
    7ad4:	81 4e 0c 00 	mov	r14,	12(r1)	;0x000c(r1)
    7ad8:	81 4f 0e 00 	mov	r15,	14(r1)	;0x000e(r1)
    7adc:	f1 40 03 00 	mov.b	#3,	8(r1)	;#0x0003, 0x0008(r1)
    7ae0:	08 00 
    7ae2:	0f 41       	mov	r1,	r15	
    7ae4:	3f 52       	add	#8,	r15	;r2 As==11
    7ae6:	b0 12 3c 7e 	call	#0x7e3c	
    7aea:	31 50 24 00 	add	#36,	r1	;#0x0024
    7aee:	74 17       	popm	#8,	r11	
    7af0:	30 41       	ret			
    7af2:	1e d3       	bis	#1,	r14	;r3 As==01
    7af4:	0f d3       	bis	#0,	r15	;r3 As==00
    7af6:	da 3f       	jmp	$-74     	;abs 0x7aac
    7af8:	3a 50 03 00 	add	#3,	r10	;#0x0003
    7afc:	08 4a       	mov	r10,	r8	
    7afe:	06 4e       	mov	r14,	r6	
    7b00:	16 f3       	and	#1,	r6	;r3 As==01
    7b02:	10 24       	jz	$+34     	;abs 0x7b24
    7b04:	1c 41 20 00 	mov	32(r1),	r12	;0x0020(r1)
    7b08:	1d 41 22 00 	mov	34(r1),	r13	;0x0022(r1)
    7b0c:	12 c3       	clrc			
    7b0e:	0d 10       	rrc	r13		
    7b10:	0c 10       	rrc	r12		
    7b12:	06 4c       	mov	r12,	r6	
    7b14:	07 4d       	mov	r13,	r7	
    7b16:	06 d3       	bis	#0,	r6	;r3 As==00
    7b18:	37 d0 00 80 	bis	#-32768,r7	;#0x8000
    7b1c:	81 46 20 00 	mov	r6,	32(r1)	;0x0020(r1)
    7b20:	81 47 22 00 	mov	r7,	34(r1)	;0x0022(r1)
    7b24:	12 c3       	clrc			
    7b26:	0f 10       	rrc	r15		
    7b28:	0e 10       	rrc	r14		
    7b2a:	1a 53       	inc	r10		
    7b2c:	0f 93       	tst	r15		
    7b2e:	e6 3b       	jl	$-50     	;abs 0x7afc
    7b30:	81 48 0a 00 	mov	r8,	10(r1)	;0x000a(r1)
    7b34:	ac 3f       	jmp	$-166    	;abs 0x7a8e
    7b36:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    7b38:	40 24       	jz	$+130    	;abs 0x7bba
    7b3a:	5f 43       	mov.b	#1,	r15	;r3 As==01
    7b3c:	d1 91 11 00 	cmp.b	17(r1),	25(r1)	;0x0011(r1), 0x0019(r1)
    7b40:	19 00 
    7b42:	25 24       	jz	$+76     	;abs 0x7b8e
    7b44:	c1 4f 19 00 	mov.b	r15,	25(r1)	;0x0019(r1)
    7b48:	0f 41       	mov	r1,	r15	
    7b4a:	3f 50 18 00 	add	#24,	r15	;#0x0018
    7b4e:	b0 12 3c 7e 	call	#0x7e3c	
    7b52:	31 50 24 00 	add	#36,	r1	;#0x0024
    7b56:	74 17       	popm	#8,	r11	
    7b58:	30 41       	ret			
    7b5a:	0d 93       	tst	r13		
    7b5c:	bb 23       	jnz	$-136    	;abs 0x7ad4
    7b5e:	0c 4e       	mov	r14,	r12	
    7b60:	0d 4f       	mov	r15,	r13	
    7b62:	3c f0 80 00 	and	#128,	r12	;#0x0080
    7b66:	0d f3       	and	#0,	r13	;r3 As==00
    7b68:	0c 93       	tst	r12		
    7b6a:	b4 23       	jnz	$-150    	;abs 0x7ad4
    7b6c:	0d 93       	tst	r13		
    7b6e:	b2 23       	jnz	$-154    	;abs 0x7ad4
    7b70:	81 93 20 00 	tst	32(r1)		;0x0020(r1)
    7b74:	03 20       	jnz	$+8      	;abs 0x7b7c
    7b76:	81 93 22 00 	tst	34(r1)		;0x0022(r1)
    7b7a:	ac 27       	jz	$-166    	;abs 0x7ad4
    7b7c:	3e 50 40 00 	add	#64,	r14	;#0x0040
    7b80:	0f 63       	adc	r15		
    7b82:	3e f0 80 ff 	and	#-128,	r14	;#0xff80
    7b86:	3f f3       	and	#-1,	r15	;r3 As==11
    7b88:	a5 3f       	jmp	$-180    	;abs 0x7ad4
    7b8a:	4d 43       	clr.b	r13		
    7b8c:	7c 3f       	jmp	$-262    	;abs 0x7a86
    7b8e:	4f 43       	clr.b	r15		
    7b90:	d9 3f       	jmp	$-76     	;abs 0x7b44
    7b92:	5f 43       	mov.b	#1,	r15	;r3 As==01
    7b94:	d1 91 11 00 	cmp.b	17(r1),	25(r1)	;0x0011(r1), 0x0019(r1)
    7b98:	19 00 
    7b9a:	0b 24       	jz	$+24     	;abs 0x7bb2
    7b9c:	c1 4f 11 00 	mov.b	r15,	17(r1)	;0x0011(r1)
    7ba0:	0f 41       	mov	r1,	r15	
    7ba2:	3f 50 10 00 	add	#16,	r15	;#0x0010
    7ba6:	b0 12 3c 7e 	call	#0x7e3c	
    7baa:	31 50 24 00 	add	#36,	r1	;#0x0024
    7bae:	74 17       	popm	#8,	r11	
    7bb0:	30 41       	ret			
    7bb2:	4f 43       	clr.b	r15		
    7bb4:	f3 3f       	jmp	$-24     	;abs 0x7b9c
    7bb6:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    7bb8:	ec 23       	jnz	$-38     	;abs 0x7b92
    7bba:	3f 40 24 81 	mov	#-32476,r15	;#0x8124
    7bbe:	93 3f       	jmp	$-216    	;abs 0x7ae6

00007bc0 <__floatsisf>:
    7bc0:	1b 15       	pushm	#2,	r11	
    7bc2:	31 82       	sub	#8,	r1	;r2 As==11
    7bc4:	f1 40 03 00 	mov.b	#3,	0(r1)	;#0x0003, 0x0000(r1)
    7bc8:	00 00 
    7bca:	0d 4f       	mov	r15,	r13	
    7bcc:	0d 5d       	rla	r13		
    7bce:	0d 43       	clr	r13		
    7bd0:	0d 6d       	rlc	r13		
    7bd2:	4c 4d       	mov.b	r13,	r12	
    7bd4:	c1 4d 01 00 	mov.b	r13,	1(r1)	;0x0001(r1)
    7bd8:	0e 93       	tst	r14		
    7bda:	0a 20       	jnz	$+22     	;abs 0x7bf0
    7bdc:	0f 93       	tst	r15		
    7bde:	08 20       	jnz	$+18     	;abs 0x7bf0
    7be0:	e1 43 00 00 	mov.b	#2,	0(r1)	;r3 As==10, 0x0000(r1)
    7be4:	0f 41       	mov	r1,	r15	
    7be6:	b0 12 3c 7e 	call	#0x7e3c	
    7bea:	31 52       	add	#8,	r1	;r2 As==11
    7bec:	1a 17       	popm	#2,	r11	
    7bee:	30 41       	ret			
    7bf0:	b1 40 1e 00 	mov	#30,	2(r1)	;#0x001e, 0x0002(r1)
    7bf4:	02 00 
    7bf6:	4c 93       	tst.b	r12		
    7bf8:	1b 20       	jnz	$+56     	;abs 0x7c30
    7bfa:	0a 4e       	mov	r14,	r10	
    7bfc:	0b 4f       	mov	r15,	r11	
    7bfe:	81 4a 04 00 	mov	r10,	4(r1)	;0x0004(r1)
    7c02:	81 4b 06 00 	mov	r11,	6(r1)	;0x0006(r1)
    7c06:	0e 4a       	mov	r10,	r14	
    7c08:	0f 4b       	mov	r11,	r15	
    7c0a:	b0 12 d2 7d 	call	#0x7dd2	
    7c0e:	3f 53       	add	#-1,	r15	;r3 As==11
    7c10:	1f 93       	cmp	#1,	r15	;r3 As==01
    7c12:	e8 3b       	jl	$-46     	;abs 0x7be4
    7c14:	81 4a 04 00 	mov	r10,	4(r1)	;0x0004(r1)
    7c18:	81 4b 06 00 	mov	r11,	6(r1)	;0x0006(r1)
    7c1c:	4e 4f       	mov.b	r15,	r14	
    7c1e:	7e f0 1f 00 	and.b	#31,	r14	;#0x001f
    7c22:	0f 20       	jnz	$+32     	;abs 0x7c42
    7c24:	3e 40 1e 00 	mov	#30,	r14	;#0x001e
    7c28:	0e 8f       	sub	r15,	r14	
    7c2a:	81 4e 02 00 	mov	r14,	2(r1)	;0x0002(r1)
    7c2e:	da 3f       	jmp	$-74     	;abs 0x7be4
    7c30:	0e 93       	tst	r14		
    7c32:	10 24       	jz	$+34     	;abs 0x7c54
    7c34:	0a 4e       	mov	r14,	r10	
    7c36:	0b 4f       	mov	r15,	r11	
    7c38:	3a e3       	inv	r10		
    7c3a:	3b e3       	inv	r11		
    7c3c:	1a 53       	inc	r10		
    7c3e:	0b 63       	adc	r11		
    7c40:	de 3f       	jmp	$-66     	;abs 0x7bfe
    7c42:	91 51 04 00 	rla	4(r1)		;0x0004(r1)
    7c46:	04 00 
    7c48:	91 61 06 00 	rlc	6(r1)		;0x0006(r1)
    7c4c:	06 00 
    7c4e:	7e 53       	add.b	#-1,	r14	;r3 As==11
    7c50:	f8 23       	jnz	$-14     	;abs 0x7c42
    7c52:	e8 3f       	jmp	$-46     	;abs 0x7c24
    7c54:	3f 90 00 80 	cmp	#-32768,r15	;#0x8000
    7c58:	ed 23       	jnz	$-36     	;abs 0x7c34
    7c5a:	0e 43       	clr	r14		
    7c5c:	3f 40 00 cf 	mov	#-12544,r15	;#0xcf00
    7c60:	c4 3f       	jmp	$-118    	;abs 0x7bea

00007c62 <__fixsfsi>:
    7c62:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    7c66:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    7c6a:	81 4f 02 00 	mov	r15,	2(r1)	;0x0002(r1)
    7c6e:	0e 41       	mov	r1,	r14	
    7c70:	2e 52       	add	#4,	r14	;r2 As==10
    7c72:	0f 41       	mov	r1,	r15	
    7c74:	b0 12 02 80 	call	#0x8002	
    7c78:	5f 41 04 00 	mov.b	4(r1),	r15	;0x0004(r1)
    7c7c:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    7c7e:	28 24       	jz	$+82     	;abs 0x7cd0
    7c80:	27 28       	jnc	$+80     	;abs 0x7cd0
    7c82:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    7c84:	07 24       	jz	$+16     	;abs 0x7c94
    7c86:	1d 41 06 00 	mov	6(r1),	r13	;0x0006(r1)
    7c8a:	0d 93       	tst	r13		
    7c8c:	21 38       	jl	$+68     	;abs 0x7cd0
    7c8e:	3d 90 1f 00 	cmp	#31,	r13	;#0x001f
    7c92:	09 38       	jl	$+20     	;abs 0x7ca6
    7c94:	c1 93 05 00 	tst.b	5(r1)		;0x0005(r1)
    7c98:	26 20       	jnz	$+78     	;abs 0x7ce6
    7c9a:	3e 43       	mov	#-1,	r14	;r3 As==11
    7c9c:	3f 40 ff 7f 	mov	#32767,	r15	;#0x7fff
    7ca0:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7ca4:	30 41       	ret			
    7ca6:	1e 41 08 00 	mov	8(r1),	r14	;0x0008(r1)
    7caa:	1f 41 0a 00 	mov	10(r1),	r15	;0x000a(r1)
    7cae:	3c 40 1e 00 	mov	#30,	r12	;#0x001e
    7cb2:	4c 8d       	sub.b	r13,	r12	
    7cb4:	4d 4c       	mov.b	r12,	r13	
    7cb6:	7d f0 1f 00 	and.b	#31,	r13	;#0x001f
    7cba:	0f 20       	jnz	$+32     	;abs 0x7cda
    7cbc:	c1 93 05 00 	tst.b	5(r1)		;0x0005(r1)
    7cc0:	ef 27       	jz	$-32     	;abs 0x7ca0
    7cc2:	3e e3       	inv	r14		
    7cc4:	3f e3       	inv	r15		
    7cc6:	1e 53       	inc	r14		
    7cc8:	0f 63       	adc	r15		
    7cca:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7cce:	30 41       	ret			
    7cd0:	0e 43       	clr	r14		
    7cd2:	0f 43       	clr	r15		
    7cd4:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7cd8:	30 41       	ret			
    7cda:	12 c3       	clrc			
    7cdc:	0f 10       	rrc	r15		
    7cde:	0e 10       	rrc	r14		
    7ce0:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7ce2:	fb 23       	jnz	$-8      	;abs 0x7cda
    7ce4:	eb 3f       	jmp	$-40     	;abs 0x7cbc
    7ce6:	0e 43       	clr	r14		
    7ce8:	3f 40 00 80 	mov	#-32768,r15	;#0x8000
    7cec:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7cf0:	30 41       	ret			

00007cf2 <__floatunsisf>:
    7cf2:	3b 15       	pushm	#4,	r11	
    7cf4:	31 82       	sub	#8,	r1	;r2 As==11
    7cf6:	0a 4e       	mov	r14,	r10	
    7cf8:	0b 4f       	mov	r15,	r11	
    7cfa:	c1 43 01 00 	mov.b	#0,	1(r1)	;r3 As==00, 0x0001(r1)
    7cfe:	0e 93       	tst	r14		
    7d00:	0a 20       	jnz	$+22     	;abs 0x7d16
    7d02:	0b 93       	tst	r11		
    7d04:	08 20       	jnz	$+18     	;abs 0x7d16
    7d06:	e1 43 00 00 	mov.b	#2,	0(r1)	;r3 As==10, 0x0000(r1)
    7d0a:	0f 41       	mov	r1,	r15	
    7d0c:	b0 12 3c 7e 	call	#0x7e3c	
    7d10:	31 52       	add	#8,	r1	;r2 As==11
    7d12:	38 17       	popm	#4,	r11	
    7d14:	30 41       	ret			
    7d16:	f1 40 03 00 	mov.b	#3,	0(r1)	;#0x0003, 0x0000(r1)
    7d1a:	00 00 
    7d1c:	b1 40 1e 00 	mov	#30,	2(r1)	;#0x001e, 0x0002(r1)
    7d20:	02 00 
    7d22:	81 4a 04 00 	mov	r10,	4(r1)	;0x0004(r1)
    7d26:	81 4b 06 00 	mov	r11,	6(r1)	;0x0006(r1)
    7d2a:	0e 4a       	mov	r10,	r14	
    7d2c:	0f 4b       	mov	r11,	r15	
    7d2e:	b0 12 d2 7d 	call	#0x7dd2	
    7d32:	3f 53       	add	#-1,	r15	;r3 As==11
    7d34:	0f 93       	tst	r15		
    7d36:	1d 38       	jl	$+60     	;abs 0x7d72
    7d38:	e8 27       	jz	$-46     	;abs 0x7d0a
    7d3a:	81 4a 04 00 	mov	r10,	4(r1)	;0x0004(r1)
    7d3e:	81 4b 06 00 	mov	r11,	6(r1)	;0x0006(r1)
    7d42:	4e 4f       	mov.b	r15,	r14	
    7d44:	7e f0 1f 00 	and.b	#31,	r14	;#0x001f
    7d48:	0b 20       	jnz	$+24     	;abs 0x7d60
    7d4a:	3e 40 1e 00 	mov	#30,	r14	;#0x001e
    7d4e:	0e 8f       	sub	r15,	r14	
    7d50:	81 4e 02 00 	mov	r14,	2(r1)	;0x0002(r1)
    7d54:	0f 41       	mov	r1,	r15	
    7d56:	b0 12 3c 7e 	call	#0x7e3c	
    7d5a:	31 52       	add	#8,	r1	;r2 As==11
    7d5c:	38 17       	popm	#4,	r11	
    7d5e:	30 41       	ret			
    7d60:	91 51 04 00 	rla	4(r1)		;0x0004(r1)
    7d64:	04 00 
    7d66:	91 61 06 00 	rlc	6(r1)		;0x0006(r1)
    7d6a:	06 00 
    7d6c:	7e 53       	add.b	#-1,	r14	;r3 As==11
    7d6e:	f8 23       	jnz	$-14     	;abs 0x7d60
    7d70:	ec 3f       	jmp	$-38     	;abs 0x7d4a
    7d72:	0e 4f       	mov	r15,	r14	
    7d74:	3e e3       	inv	r14		
    7d76:	1e 53       	inc	r14		
    7d78:	1c 43       	mov	#1,	r12	;r3 As==01
    7d7a:	0d 43       	clr	r13		
    7d7c:	48 4e       	mov.b	r14,	r8	
    7d7e:	78 f0 1f 00 	and.b	#31,	r8	;#0x001f
    7d82:	04 24       	jz	$+10     	;abs 0x7d8c
    7d84:	0c 5c       	rla	r12		
    7d86:	0d 6d       	rlc	r13		
    7d88:	78 53       	add.b	#-1,	r8	;r3 As==11
    7d8a:	fc 23       	jnz	$-6      	;abs 0x7d84
    7d8c:	3c 53       	add	#-1,	r12	;r3 As==11
    7d8e:	3d 63       	addc	#-1,	r13	;r3 As==11
    7d90:	0c fa       	and	r10,	r12	
    7d92:	0d fb       	and	r11,	r13	
    7d94:	18 43       	mov	#1,	r8	;r3 As==01
    7d96:	09 43       	clr	r9		
    7d98:	0c 93       	tst	r12		
    7d9a:	04 20       	jnz	$+10     	;abs 0x7da4
    7d9c:	0d 93       	tst	r13		
    7d9e:	02 20       	jnz	$+6      	;abs 0x7da4
    7da0:	08 43       	clr	r8		
    7da2:	09 43       	clr	r9		
    7da4:	7e f0 1f 00 	and.b	#31,	r14	;#0x001f
    7da8:	0e 20       	jnz	$+30     	;abs 0x7dc6
    7daa:	0d 48       	mov	r8,	r13	
    7dac:	0e 49       	mov	r9,	r14	
    7dae:	0d da       	bis	r10,	r13	
    7db0:	0e db       	bis	r11,	r14	
    7db2:	81 4d 04 00 	mov	r13,	4(r1)	;0x0004(r1)
    7db6:	81 4e 06 00 	mov	r14,	6(r1)	;0x0006(r1)
    7dba:	3e 40 1e 00 	mov	#30,	r14	;#0x001e
    7dbe:	0e 8f       	sub	r15,	r14	
    7dc0:	81 4e 02 00 	mov	r14,	2(r1)	;0x0002(r1)
    7dc4:	a2 3f       	jmp	$-186    	;abs 0x7d0a
    7dc6:	12 c3       	clrc			
    7dc8:	0b 10       	rrc	r11		
    7dca:	0a 10       	rrc	r10		
    7dcc:	7e 53       	add.b	#-1,	r14	;r3 As==11
    7dce:	fb 23       	jnz	$-8      	;abs 0x7dc6
    7dd0:	ec 3f       	jmp	$-38     	;abs 0x7daa

00007dd2 <__clzsi2>:
    7dd2:	2b 15       	pushm	#3,	r11	
    7dd4:	1f 93       	cmp	#1,	r15	;r3 As==01
    7dd6:	15 2c       	jc	$+44     	;abs 0x7e02
    7dd8:	3e 90 00 01 	cmp	#256,	r14	;#0x0100
    7ddc:	2a 28       	jnc	$+86     	;abs 0x7e32
    7dde:	3a 40 18 00 	mov	#24,	r10	;#0x0018
    7de2:	0b 43       	clr	r11		
    7de4:	39 42       	mov	#8,	r9	;r2 As==11
    7de6:	0c 4e       	mov	r14,	r12	
    7de8:	0d 4f       	mov	r15,	r13	
    7dea:	4f 49       	mov.b	r9,	r15	
    7dec:	4f 93       	tst.b	r15		
    7dee:	15 20       	jnz	$+44     	;abs 0x7e1a
    7df0:	3c 50 2c 81 	add	#-32468,r12	;#0x812c
    7df4:	6e 4c       	mov.b	@r12,	r14	
    7df6:	0f 43       	clr	r15		
    7df8:	0a 8e       	sub	r14,	r10	
    7dfa:	0b 7f       	subc	r15,	r11	
    7dfc:	0f 4a       	mov	r10,	r15	
    7dfe:	29 17       	popm	#3,	r11	
    7e00:	30 41       	ret			
    7e02:	3f 90 00 01 	cmp	#256,	r15	;#0x0100
    7e06:	0f 28       	jnc	$+32     	;abs 0x7e26
    7e08:	3a 42       	mov	#8,	r10	;r2 As==11
    7e0a:	0b 43       	clr	r11		
    7e0c:	39 40 18 00 	mov	#24,	r9	;#0x0018
    7e10:	0c 4e       	mov	r14,	r12	
    7e12:	0d 4f       	mov	r15,	r13	
    7e14:	4f 49       	mov.b	r9,	r15	
    7e16:	4f 93       	tst.b	r15		
    7e18:	eb 27       	jz	$-40     	;abs 0x7df0
    7e1a:	12 c3       	clrc			
    7e1c:	0d 10       	rrc	r13		
    7e1e:	0c 10       	rrc	r12		
    7e20:	7f 53       	add.b	#-1,	r15	;r3 As==11
    7e22:	fb 23       	jnz	$-8      	;abs 0x7e1a
    7e24:	e5 3f       	jmp	$-52     	;abs 0x7df0
    7e26:	3a 40 10 00 	mov	#16,	r10	;#0x0010
    7e2a:	0b 43       	clr	r11		
    7e2c:	39 40 10 00 	mov	#16,	r9	;#0x0010
    7e30:	ef 3f       	jmp	$-32     	;abs 0x7e10
    7e32:	3a 40 20 00 	mov	#32,	r10	;#0x0020
    7e36:	0b 43       	clr	r11		
    7e38:	09 43       	clr	r9		
    7e3a:	ea 3f       	jmp	$-42     	;abs 0x7e10

00007e3c <__pack_f>:
    7e3c:	4b 15       	pushm	#5,	r11	
    7e3e:	0d 4f       	mov	r15,	r13	
    7e40:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    7e44:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    7e48:	5a 4d 01 00 	mov.b	1(r13),	r10	;0x0001(r13)
    7e4c:	6c 4d       	mov.b	@r13,	r12	
    7e4e:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    7e50:	68 28       	jnc	$+210    	;abs 0x7f22
    7e52:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    7e54:	62 24       	jz	$+198    	;abs 0x7f1a
    7e56:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    7e58:	36 24       	jz	$+110    	;abs 0x7ec6
    7e5a:	0e 93       	tst	r14		
    7e5c:	32 24       	jz	$+102    	;abs 0x7ec2
    7e5e:	1b 4d 02 00 	mov	2(r13),	r11	;0x0002(r13)
    7e62:	3b 90 82 ff 	cmp	#-126,	r11	;#0xff82
    7e66:	65 38       	jl	$+204    	;abs 0x7f32
    7e68:	3b 90 80 00 	cmp	#128,	r11	;#0x0080
    7e6c:	56 34       	jge	$+174    	;abs 0x7f1a
    7e6e:	0c 4e       	mov	r14,	r12	
    7e70:	0d 4f       	mov	r15,	r13	
    7e72:	3c f0 7f 00 	and	#127,	r12	;#0x007f
    7e76:	0d f3       	and	#0,	r13	;r3 As==00
    7e78:	3c 90 40 00 	cmp	#64,	r12	;#0x0040
    7e7c:	38 24       	jz	$+114    	;abs 0x7eee
    7e7e:	3e 50 3f 00 	add	#63,	r14	;#0x003f
    7e82:	0f 63       	adc	r15		
    7e84:	0f 93       	tst	r15		
    7e86:	42 38       	jl	$+134    	;abs 0x7f0c
    7e88:	0d 4b       	mov	r11,	r13	
    7e8a:	3d 50 7f 00 	add	#127,	r13	;#0x007f
    7e8e:	12 c3       	clrc			
    7e90:	0f 10       	rrc	r15		
    7e92:	0e 10       	rrc	r14		
    7e94:	12 c3       	clrc			
    7e96:	0f 10       	rrc	r15		
    7e98:	0e 10       	rrc	r14		
    7e9a:	12 c3       	clrc			
    7e9c:	0f 10       	rrc	r15		
    7e9e:	0e 10       	rrc	r14		
    7ea0:	12 c3       	clrc			
    7ea2:	0f 10       	rrc	r15		
    7ea4:	0e 10       	rrc	r14		
    7ea6:	12 c3       	clrc			
    7ea8:	0f 10       	rrc	r15		
    7eaa:	0e 10       	rrc	r14		
    7eac:	12 c3       	clrc			
    7eae:	0f 10       	rrc	r15		
    7eb0:	0e 10       	rrc	r14		
    7eb2:	12 c3       	clrc			
    7eb4:	0f 10       	rrc	r15		
    7eb6:	0e 10       	rrc	r14		
    7eb8:	3e f3       	and	#-1,	r14	;r3 As==11
    7eba:	3f f0 7f 00 	and	#127,	r15	;#0x007f
    7ebe:	4d 4d       	mov.b	r13,	r13	
    7ec0:	05 3c       	jmp	$+12     	;abs 0x7ecc
    7ec2:	0f 93       	tst	r15		
    7ec4:	cc 23       	jnz	$-102    	;abs 0x7e5e
    7ec6:	4d 43       	clr.b	r13		
    7ec8:	0e 43       	clr	r14		
    7eca:	0f 43       	clr	r15		
    7ecc:	4d 4d       	mov.b	r13,	r13	
    7ece:	5d 0e       	rlam	#4,	r13	
    7ed0:	5d 0a       	rlam	#3,	r13	
    7ed2:	0c 4f       	mov	r15,	r12	
    7ed4:	3c f0 7f 00 	and	#127,	r12	;#0x007f
    7ed8:	0c dd       	bis	r13,	r12	
    7eda:	4f 4a       	mov.b	r10,	r15	
    7edc:	0f 11       	rra	r15		
    7ede:	0f 43       	clr	r15		
    7ee0:	0f 10       	rrc	r15		
    7ee2:	0b 4e       	mov	r14,	r11	
    7ee4:	0d 4c       	mov	r12,	r13	
    7ee6:	0d df       	bis	r15,	r13	
    7ee8:	0f 4d       	mov	r13,	r15	
    7eea:	47 17       	popm	#5,	r11	
    7eec:	30 41       	ret			
    7eee:	0d 93       	tst	r13		
    7ef0:	c6 23       	jnz	$-114    	;abs 0x7e7e
    7ef2:	0c 4e       	mov	r14,	r12	
    7ef4:	0d 4f       	mov	r15,	r13	
    7ef6:	3c f0 80 00 	and	#128,	r12	;#0x0080
    7efa:	0d f3       	and	#0,	r13	;r3 As==00
    7efc:	0c 93       	tst	r12		
    7efe:	02 20       	jnz	$+6      	;abs 0x7f04
    7f00:	0d 93       	tst	r13		
    7f02:	c0 27       	jz	$-126    	;abs 0x7e84
    7f04:	3e 50 40 00 	add	#64,	r14	;#0x0040
    7f08:	0f 63       	adc	r15		
    7f0a:	bc 3f       	jmp	$-134    	;abs 0x7e84
    7f0c:	12 c3       	clrc			
    7f0e:	0f 10       	rrc	r15		
    7f10:	0e 10       	rrc	r14		
    7f12:	0d 4b       	mov	r11,	r13	
    7f14:	3d 50 80 00 	add	#128,	r13	;#0x0080
    7f18:	ba 3f       	jmp	$-138    	;abs 0x7e8e
    7f1a:	7d 43       	mov.b	#-1,	r13	;r3 As==11
    7f1c:	0e 43       	clr	r14		
    7f1e:	0f 43       	clr	r15		
    7f20:	d5 3f       	jmp	$-84     	;abs 0x7ecc
    7f22:	0e d3       	bis	#0,	r14	;r3 As==00
    7f24:	3f d0 10 00 	bis	#16,	r15	;#0x0010
    7f28:	3e f3       	and	#-1,	r14	;r3 As==11
    7f2a:	3f f0 7f 00 	and	#127,	r15	;#0x007f
    7f2e:	7d 43       	mov.b	#-1,	r13	;r3 As==11
    7f30:	cd 3f       	jmp	$-100    	;abs 0x7ecc
    7f32:	37 40 82 ff 	mov	#-126,	r7	;#0xff82
    7f36:	07 8b       	sub	r11,	r7	
    7f38:	37 90 1a 00 	cmp	#26,	r7	;#0x001a
    7f3c:	4f 34       	jge	$+160    	;abs 0x7fdc
    7f3e:	0c 4e       	mov	r14,	r12	
    7f40:	0d 4f       	mov	r15,	r13	
    7f42:	4b 47       	mov.b	r7,	r11	
    7f44:	7b f0 1f 00 	and.b	#31,	r11	;#0x001f
    7f48:	05 24       	jz	$+12     	;abs 0x7f54
    7f4a:	12 c3       	clrc			
    7f4c:	0d 10       	rrc	r13		
    7f4e:	0c 10       	rrc	r12		
    7f50:	7b 53       	add.b	#-1,	r11	;r3 As==11
    7f52:	fb 23       	jnz	$-8      	;abs 0x7f4a
    7f54:	18 43       	mov	#1,	r8	;r3 As==01
    7f56:	09 43       	clr	r9		
    7f58:	77 f0 1f 00 	and.b	#31,	r7	;#0x001f
    7f5c:	04 24       	jz	$+10     	;abs 0x7f66
    7f5e:	08 58       	rla	r8		
    7f60:	09 69       	rlc	r9		
    7f62:	77 53       	add.b	#-1,	r7	;r3 As==11
    7f64:	fc 23       	jnz	$-6      	;abs 0x7f5e
    7f66:	38 53       	add	#-1,	r8	;r3 As==11
    7f68:	39 63       	addc	#-1,	r9	;r3 As==11
    7f6a:	08 fe       	and	r14,	r8	
    7f6c:	09 ff       	and	r15,	r9	
    7f6e:	1e 43       	mov	#1,	r14	;r3 As==01
    7f70:	0f 43       	clr	r15		
    7f72:	08 93       	tst	r8		
    7f74:	04 20       	jnz	$+10     	;abs 0x7f7e
    7f76:	09 93       	tst	r9		
    7f78:	02 20       	jnz	$+6      	;abs 0x7f7e
    7f7a:	0e 43       	clr	r14		
    7f7c:	0f 43       	clr	r15		
    7f7e:	08 4e       	mov	r14,	r8	
    7f80:	09 4f       	mov	r15,	r9	
    7f82:	08 dc       	bis	r12,	r8	
    7f84:	09 dd       	bis	r13,	r9	
    7f86:	0e 48       	mov	r8,	r14	
    7f88:	0f 49       	mov	r9,	r15	
    7f8a:	3e f0 7f 00 	and	#127,	r14	;#0x007f
    7f8e:	0f f3       	and	#0,	r15	;r3 As==00
    7f90:	3e 90 40 00 	cmp	#64,	r14	;#0x0040
    7f94:	26 24       	jz	$+78     	;abs 0x7fe2
    7f96:	38 50 3f 00 	add	#63,	r8	;#0x003f
    7f9a:	09 63       	adc	r9		
    7f9c:	0e 48       	mov	r8,	r14	
    7f9e:	0f 49       	mov	r9,	r15	
    7fa0:	12 c3       	clrc			
    7fa2:	0f 10       	rrc	r15		
    7fa4:	0e 10       	rrc	r14		
    7fa6:	12 c3       	clrc			
    7fa8:	0f 10       	rrc	r15		
    7faa:	0e 10       	rrc	r14		
    7fac:	12 c3       	clrc			
    7fae:	0f 10       	rrc	r15		
    7fb0:	0e 10       	rrc	r14		
    7fb2:	12 c3       	clrc			
    7fb4:	0f 10       	rrc	r15		
    7fb6:	0e 10       	rrc	r14		
    7fb8:	12 c3       	clrc			
    7fba:	0f 10       	rrc	r15		
    7fbc:	0e 10       	rrc	r14		
    7fbe:	12 c3       	clrc			
    7fc0:	0f 10       	rrc	r15		
    7fc2:	0e 10       	rrc	r14		
    7fc4:	12 c3       	clrc			
    7fc6:	0f 10       	rrc	r15		
    7fc8:	0e 10       	rrc	r14		
    7fca:	3e f3       	and	#-1,	r14	;r3 As==11
    7fcc:	3f f0 7f 00 	and	#127,	r15	;#0x007f
    7fd0:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7fd2:	39 90 00 40 	cmp	#16384,	r9	;#0x4000
    7fd6:	7a 2f       	jc	$-266    	;abs 0x7ecc
    7fd8:	4d 43       	clr.b	r13		
    7fda:	78 3f       	jmp	$-270    	;abs 0x7ecc
    7fdc:	08 43       	clr	r8		
    7fde:	09 43       	clr	r9		
    7fe0:	da 3f       	jmp	$-74     	;abs 0x7f96
    7fe2:	0f 93       	tst	r15		
    7fe4:	d8 23       	jnz	$-78     	;abs 0x7f96
    7fe6:	0e 48       	mov	r8,	r14	
    7fe8:	0f 49       	mov	r9,	r15	
    7fea:	3e f0 80 00 	and	#128,	r14	;#0x0080
    7fee:	0f f3       	and	#0,	r15	;r3 As==00
    7ff0:	0e 93       	tst	r14		
    7ff2:	04 24       	jz	$+10     	;abs 0x7ffc
    7ff4:	38 50 40 00 	add	#64,	r8	;#0x0040
    7ff8:	09 63       	adc	r9		
    7ffa:	d0 3f       	jmp	$-94     	;abs 0x7f9c
    7ffc:	0f 93       	tst	r15		
    7ffe:	ce 27       	jz	$-98     	;abs 0x7f9c
    8000:	f9 3f       	jmp	$-12     	;abs 0x7ff4

00008002 <__unpack_f>:
    8002:	1b 15       	pushm	#2,	r11	
    8004:	21 82       	sub	#4,	r1	;r2 As==10
    8006:	2c 4f       	mov	@r15,	r12	
    8008:	5d 4f 02 00 	mov.b	2(r15),	r13	;0x0002(r15)
    800c:	3d f0 7f 00 	and	#127,	r13	;#0x007f
    8010:	1b 4f 02 00 	mov	2(r15),	r11	;0x0002(r15)
    8014:	5b 0f       	rrum	#4,	r11	
    8016:	5b 0b       	rrum	#3,	r11	
    8018:	4b 4b       	mov.b	r11,	r11	
    801a:	5f 4f 03 00 	mov.b	3(r15),	r15	;0x0003(r15)
    801e:	3f b0 80 00 	bit	#128,	r15	;#0x0080
    8022:	0f 43       	clr	r15		
    8024:	0f 6f       	rlc	r15		
    8026:	ce 4f 01 00 	mov.b	r15,	1(r14)	;0x0001(r14)
    802a:	0b 93       	tst	r11		
    802c:	2b 20       	jnz	$+88     	;abs 0x8084
    802e:	0c 93       	tst	r12		
    8030:	4d 24       	jz	$+156    	;abs 0x80cc
    8032:	be 40 82 ff 	mov	#-126,	2(r14)	;#0xff82, 0x0002(r14)
    8036:	02 00 
    8038:	0c 5c       	rla	r12		
    803a:	0d 6d       	rlc	r13		
    803c:	0c 5c       	rla	r12		
    803e:	0d 6d       	rlc	r13		
    8040:	0c 5c       	rla	r12		
    8042:	0d 6d       	rlc	r13		
    8044:	0c 5c       	rla	r12		
    8046:	0d 6d       	rlc	r13		
    8048:	0c 5c       	rla	r12		
    804a:	0d 6d       	rlc	r13		
    804c:	0c 5c       	rla	r12		
    804e:	0d 6d       	rlc	r13		
    8050:	0c 5c       	rla	r12		
    8052:	0d 6d       	rlc	r13		
    8054:	fe 40 03 00 	mov.b	#3,	0(r14)	;#0x0003, 0x0000(r14)
    8058:	00 00 
    805a:	3d 90 00 40 	cmp	#16384,	r13	;#0x4000
    805e:	0b 2c       	jc	$+24     	;abs 0x8076
    8060:	3f 40 81 ff 	mov	#-127,	r15	;#0xff81
    8064:	0c 5c       	rla	r12		
    8066:	0d 6d       	rlc	r13		
    8068:	0b 4f       	mov	r15,	r11	
    806a:	3f 53       	add	#-1,	r15	;r3 As==11
    806c:	3d 90 00 40 	cmp	#16384,	r13	;#0x4000
    8070:	f9 2b       	jnc	$-12     	;abs 0x8064
    8072:	8e 4b 02 00 	mov	r11,	2(r14)	;0x0002(r14)
    8076:	8e 4c 04 00 	mov	r12,	4(r14)	;0x0004(r14)
    807a:	8e 4d 06 00 	mov	r13,	6(r14)	;0x0006(r14)
    807e:	21 52       	add	#4,	r1	;r2 As==10
    8080:	1a 17       	popm	#2,	r11	
    8082:	30 41       	ret			
    8084:	3b 90 ff 00 	cmp	#255,	r11	;#0x00ff
    8088:	28 24       	jz	$+82     	;abs 0x80da
    808a:	3b 50 81 ff 	add	#-127,	r11	;#0xff81
    808e:	8e 4b 02 00 	mov	r11,	2(r14)	;0x0002(r14)
    8092:	fe 40 03 00 	mov.b	#3,	0(r14)	;#0x0003, 0x0000(r14)
    8096:	00 00 
    8098:	0c 5c       	rla	r12		
    809a:	0d 6d       	rlc	r13		
    809c:	0c 5c       	rla	r12		
    809e:	0d 6d       	rlc	r13		
    80a0:	0c 5c       	rla	r12		
    80a2:	0d 6d       	rlc	r13		
    80a4:	0c 5c       	rla	r12		
    80a6:	0d 6d       	rlc	r13		
    80a8:	0c 5c       	rla	r12		
    80aa:	0d 6d       	rlc	r13		
    80ac:	0c 5c       	rla	r12		
    80ae:	0d 6d       	rlc	r13		
    80b0:	0c 5c       	rla	r12		
    80b2:	0d 6d       	rlc	r13		
    80b4:	0a 4c       	mov	r12,	r10	
    80b6:	0b 4d       	mov	r13,	r11	
    80b8:	0a d3       	bis	#0,	r10	;r3 As==00
    80ba:	3b d0 00 40 	bis	#16384,	r11	;#0x4000
    80be:	8e 4a 04 00 	mov	r10,	4(r14)	;0x0004(r14)
    80c2:	8e 4b 06 00 	mov	r11,	6(r14)	;0x0006(r14)
    80c6:	21 52       	add	#4,	r1	;r2 As==10
    80c8:	1a 17       	popm	#2,	r11	
    80ca:	30 41       	ret			
    80cc:	0d 93       	tst	r13		
    80ce:	b1 23       	jnz	$-156    	;abs 0x8032
    80d0:	ee 43 00 00 	mov.b	#2,	0(r14)	;r3 As==10, 0x0000(r14)
    80d4:	21 52       	add	#4,	r1	;r2 As==10
    80d6:	1a 17       	popm	#2,	r11	
    80d8:	30 41       	ret			
    80da:	0c 93       	tst	r12		
    80dc:	10 24       	jz	$+34     	;abs 0x80fe
    80de:	0a 4c       	mov	r12,	r10	
    80e0:	0b 4d       	mov	r13,	r11	
    80e2:	0a f3       	and	#0,	r10	;r3 As==00
    80e4:	3b f0 10 00 	and	#16,	r11	;#0x0010
    80e8:	81 4a 00 00 	mov	r10,	0(r1)	;0x0000(r1)
    80ec:	81 4b 02 00 	mov	r11,	2(r1)	;0x0002(r1)
    80f0:	0a 93       	tst	r10		
    80f2:	02 20       	jnz	$+6      	;abs 0x80f8
    80f4:	0b 93       	tst	r11		
    80f6:	08 24       	jz	$+18     	;abs 0x8108
    80f8:	de 43 00 00 	mov.b	#1,	0(r14)	;r3 As==01, 0x0000(r14)
    80fc:	bc 3f       	jmp	$-134    	;abs 0x8076
    80fe:	0d 93       	tst	r13		
    8100:	ee 23       	jnz	$-34     	;abs 0x80de
    8102:	ee 42 00 00 	mov.b	#4,	0(r14)	;r2 As==10, 0x0000(r14)
    8106:	df 3f       	jmp	$-64     	;abs 0x80c6
    8108:	ce 43 00 00 	mov.b	#0,	0(r14)	;r3 As==00, 0x0000(r14)
    810c:	b4 3f       	jmp	$-150    	;abs 0x8076

0000810e <_unexpected_>:
    810e:	00 13       	reti			

Disassembly of section .vectors:

0000ff80 <__ivtbl_64>:
    ff80:	a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c     .\.\.\.\.\.\.\.\
    ff90:	a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c     .\.\.\.\.\.\.\.\
    ffa0:	a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c     .\.\.\.\.\.\.\.\
    ffb0:	a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c     .\.\.\.\.\.\.\.\
    ffc0:	a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c     .\.\.\.\.\.\.\.\
    ffd0:	a6 5c a6 5c a6 5c a6 5c 98 73 a6 5c a6 5c a6 5c     .\.\.\.\.s.\.\.\
    ffe0:	a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c ee 6d a6 5c     .\.\.\.\.\.\.m.\
    fff0:	a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c a6 5c 00 5c     .\.\.\.\.\.\.\.\
